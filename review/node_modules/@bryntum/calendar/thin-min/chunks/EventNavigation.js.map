{"version":3,"file":"EventNavigation.js","sources":["../../../../Scheduler/lib/Scheduler/localization/En.js","../../../../Scheduler/lib/Scheduler/data/mixin/AttachToProjectMixin.js","../../../../Scheduler/lib/Scheduler/data/mixin/ProjectConsumer.js","../../../../Scheduler/lib/Scheduler/tooltip/ClockTemplate.js","../../../../Scheduler/lib/Scheduler/feature/base/TimeSpanMenuBase.js","../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceConfirmationPopup.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceFrequencyCombo.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysCombo.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthDaysButtonGroup.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthsButtonGroup.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceStopConditionCombo.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrencePositionsCombo.js","../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditorPanel.js","../../../../Scheduler/lib/Scheduler/feature/EventMenu.js","../../../../Scheduler/lib/Scheduler/feature/ScheduleMenu.js","../../../../Scheduler/lib/Scheduler/view/mixin/RecurringEvents.js","../../../../Scheduler/lib/Scheduler/view/mixin/CurrentConfig.js","../../../../Scheduler/lib/Scheduler/view/mixin/EventNavigation.js"],"sourcesContent":["import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Grid/localization/En.js';\n\nconst locale = {\n\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n\n    Object : {\n        newEvent : 'New event'\n    },\n\n    ResourceInfoColumn : {\n        eventCountText : data => data + ' event' + (data !== 1 ? 's' : '')\n    },\n\n    Dependencies : {\n        from    : 'From',\n        to      : 'To',\n        valid   : 'Valid',\n        invalid : 'Invalid'\n    },\n\n    DependencyType : {\n        SS           : 'SS',\n        SF           : 'SF',\n        FS           : 'FS',\n        FF           : 'FF',\n        StartToStart : 'Start-to-Start',\n        StartToEnd   : 'Start-to-Finish',\n        EndToStart   : 'Finish-to-Start',\n        EndToEnd     : 'Finish-to-Finish',\n        short        : [\n            'SS',\n            'SF',\n            'FS',\n            'FF'\n        ],\n        long : [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n\n    DependencyEdit : {\n        From              : 'From',\n        To                : 'To',\n        Type              : 'Type',\n        Lag               : 'Lag',\n        'Edit dependency' : 'Edit dependency',\n        Save              : 'Save',\n        Delete            : 'Delete',\n        Cancel            : 'Cancel',\n        StartToStart      : 'Start to Start',\n        StartToEnd        : 'Start to End',\n        EndToStart        : 'End to Start',\n        EndToEnd          : 'End to End'\n    },\n\n    EventEdit : {\n        Name         : 'Name',\n        Resource     : 'Resource',\n        Start        : 'Start',\n        End          : 'End',\n        Save         : 'Save',\n        Delete       : 'Delete',\n        Cancel       : 'Cancel',\n        'Edit event' : 'Edit event',\n        Repeat       : 'Repeat'\n    },\n\n    EventDrag : {\n        eventOverlapsExisting : 'Event overlaps existing event for this resource',\n        noDropOutsideTimeline : 'Event may not be dropped completely outside the timeline'\n    },\n\n    SchedulerBase : {\n        'Add event'      : 'Add event',\n        'Delete event'   : 'Delete event',\n        'Unassign event' : 'Unassign event'\n    },\n\n    TimeAxisHeaderMenu : {\n        pickZoomLevel   : 'Zoom',\n        activeDateRange : 'Date range',\n        startText       : 'Start date',\n        endText         : 'End date',\n        todayText       : 'Today'\n    },\n\n    EventCopyPaste : {\n        copyEvent  : 'Copy event',\n        cutEvent   : 'Cut event',\n        pasteEvent : 'Paste event'\n    },\n\n    EventFilter : {\n        filterEvents : 'Filter tasks',\n        byName       : 'By name'\n    },\n\n    TimeRanges : {\n        showCurrentTimeLine : 'Show current timeline'\n    },\n\n    PresetManager : {\n        secondAndMinute : {\n            displayDateFormat : 'll LTS',\n            name              : 'Seconds'\n        },\n        minuteAndHour : {\n            topDateFormat     : 'ddd MM/DD, hA',\n            displayDateFormat : 'll LST'\n        },\n        hourAndDay : {\n            topDateFormat     : 'ddd MM/DD',\n            middleDateFormat  : 'LST',\n            displayDateFormat : 'll LST',\n            name              : 'Day'\n        },\n        day : {\n            name : 'Day/hours'\n        },\n        week : {\n            name : 'Week/hours'\n        },\n        dayAndWeek : {\n            displayDateFormat : 'll LST',\n            name              : 'Week/days'\n        },\n        dayAndMonth : {\n            name : 'Month'\n        },\n        weekAndDay : {\n            displayDateFormat : 'll LST',\n            name              : 'Week'\n        },\n        weekAndMonth : {\n            name : 'Weeks'\n        },\n        weekAndDayLetter : {\n            name : 'Weeks/weekdays'\n        },\n        weekDateAndMonth : {\n            name : 'Months/weeks'\n        },\n        monthAndYear : {\n            name : 'Months'\n        },\n        year : {\n            name : 'Years'\n        },\n        manyYears : {\n            name : 'Multiple years'\n        }\n    },\n\n    RecurrenceConfirmationPopup : {\n        'delete-title'              : 'You are deleting an event',\n        'delete-all-message'        : 'Do you want to delete all occurrences of this event?',\n        'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',\n        'delete-further-btn-text'   : 'Delete All Future Events',\n        'delete-only-this-btn-text' : 'Delete Only This Event',\n        'update-title'              : 'You are changing a repeating event',\n        'update-all-message'        : 'Do you want to change all occurrences of this event?',\n        'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',\n        'update-further-btn-text'   : 'All Future Events',\n        'update-only-this-btn-text' : 'Only This Event',\n        Yes                         : 'Yes',\n        Cancel                      : 'Cancel',\n        width                       : 600\n    },\n\n    RecurrenceLegend : {\n        ' and '                         : ' and ',\n        Daily                           : 'Daily',\n        'Weekly on {1}'                 : ({ days }) => `Weekly on ${days}`,\n        'Monthly on {1}'                : ({ days }) => `Monthly on ${days}`,\n        'Yearly on {1} of {2}'          : ({ days, months }) => `Yearly on ${days} of ${months}`,\n        'Every {0} days'                : ({ interval }) => `Every ${interval} days`,\n        'Every {0} weeks on {1}'        : ({ interval, days }) => `Every ${interval} weeks on ${days}`,\n        'Every {0} months on {1}'       : ({ interval, days }) => `Every ${interval} months on ${days}`,\n        'Every {0} years on {1} of {2}' : ({ interval, days, months }) => `Every ${interval} years on ${days} of ${months}`,\n        position1                       : 'the first',\n        position2                       : 'the second',\n        position3                       : 'the third',\n        position4                       : 'the fourth',\n        position5                       : 'the fifth',\n        'position-1'                    : 'the last',\n        day                             : 'day',\n        weekday                         : 'weekday',\n        'weekend day'                   : 'weekend day',\n        daysFormat                      : ({ position, days }) => `${position} ${days}`\n    },\n\n    RecurrenceEditor : {\n        'Repeat event'      : 'Repeat event',\n        Cancel              : 'Cancel',\n        Save                : 'Save',\n        Frequency           : 'Frequency',\n        Every               : 'Every',\n        DAILYintervalUnit   : 'day(s)',\n        WEEKLYintervalUnit  : 'week(s)',\n        MONTHLYintervalUnit : 'month(s)',\n        YEARLYintervalUnit  : 'year(s)',\n        Each                : 'Each',\n        'On the'            : 'On the',\n        'End repeat'        : 'End repeat',\n        'time(s)'           : 'time(s)'\n    },\n\n    RecurrenceDaysCombo : {\n        day           : 'day',\n        weekday       : 'weekday',\n        'weekend day' : 'weekend day'\n    },\n\n    RecurrencePositionsCombo : {\n        position1    : 'first',\n        position2    : 'second',\n        position3    : 'third',\n        position4    : 'fourth',\n        position5    : 'fifth',\n        'position-1' : 'last'\n    },\n\n    RecurrenceStopConditionCombo : {\n        Never     : 'Never',\n        After     : 'After',\n        'On date' : 'On date'\n    },\n\n    RecurrenceFrequencyCombo : {\n        None    : 'No repeat',\n        Daily   : 'Daily',\n        Weekly  : 'Weekly',\n        Monthly : 'Monthly',\n        Yearly  : 'Yearly'\n    },\n\n    RecurrenceCombo : {\n        None   : 'None',\n        Custom : 'Custom...'\n    },\n\n    Summary : {\n        'Summary for' : date => `Summary for ${date}`\n    },\n\n    ScheduleRangeCombo : {\n        completeview : 'Complete schedule',\n        currentview  : 'Visible schedule',\n        daterange    : 'Date range',\n        completedata : 'Complete schedule (for all events)'\n    },\n\n    SchedulerExportDialog : {\n        'Schedule range' : 'Schedule range',\n        'Export from'    : 'From',\n        'Export to'      : 'To'\n    },\n\n    ExcelExporter : {\n        'No resource assigned' : 'No resource assigned'\n    },\n\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n\n    DurationColumn : {\n        Duration : 'Duration'\n    }\n};\n\nexport default LocaleHelper.publishLocale(locale);\n","/**\n * @module Scheduler/data/mixin/AttachToProjectMixin\n */\n\n/**\n * Mixin that calls the target class `attachToProject()` function when a new project is assigned to Scheduler/Gantt.\n *\n * @mixin\n */\nexport default Target => class AttachToProjectMixin extends Target {\n    static get $name() {\n        return 'AttachToProjectMixin';\n    }\n\n    async afterConstruct() {\n        super.afterConstruct();\n\n        const\n            me            = this,\n            projectHolder = (me.client || me.grid),\n            { project }   = projectHolder;\n\n        projectHolder.projectSubscribers.push(me);\n\n        // Attach to already existing stores\n        if (project) {\n            me.attachToProject(project);\n            me.attachToResourceStore(project.resourceStore);\n            me.attachToEventStore(project.eventStore);\n            me.attachToAssignmentStore(project.assignmentStore);\n            me.attachToDependencyStore(project.dependencyStore);\n            me.attachToCalendarManagerStore(project.calendarManagerStore);\n        }\n    }\n\n    /**\n     * Override to take action when the project instance is replaced.\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     */\n    attachToProject(project) {\n        this.detachListeners('project');\n\n        this._project = project;\n    }\n\n    /**\n     * Override to take action when the EventStore instance is replaced, either from being replaced on the project or\n     * from assigning a new project.\n     *\n     * @param {Scheduler.data.EventStore} store\n     */\n    attachToEventStore(store) {\n        this.detachListeners('eventStore');\n    }\n\n    /**\n     * Override to take action when the ResourceStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.ResourceStore} store\n     */\n    attachToResourceStore(store) {\n        this.detachListeners('resourceStore');\n    }\n\n    /**\n     * Override to take action when the AssignmentStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.AssignmentStore} store\n     */\n    attachToAssignmentStore(store) {\n        this.detachListeners('assignmentStore');\n    }\n\n    /**\n     * Override to take action when the DependencyStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.DependencyStore} store\n     */\n    attachToDependencyStore(store) {\n        this.detachListeners('dependencyStore');\n    }\n\n    // TODO: Move attachToCalendarMangerStore to Pro somehow\n\n    /**\n     * Override to take action when the CalendarManagerStore instance is replaced, either from being replaced on the\n     * project or from assigning a new project.\n     *\n     * @param {Core.data.Store} store\n     */\n    attachToCalendarManagerStore(store) {\n        this.detachListeners('calendarManagerStore');\n    }\n\n    get project() {\n        return this._project;\n    }\n\n    get calendarManagerStore() {\n        return this.project.calendarManagerStore;\n    }\n\n    get assignmentStore() {\n        return this.project.assignmentStore;\n    }\n\n    get resourceStore() {\n        return this.project.resourceStore;\n    }\n\n    get eventStore() {\n        return this.project.eventStore;\n    }\n\n    get dependencyStore() {\n        return this.project.dependencyStore;\n    }\n};\n","import Base from '../../../Core/Base.js';\nimport ProjectModel from '../../model/ProjectModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\n\n/**\n * @module Scheduler/data/mixin/ProjectConsumer\n */\n\nconst engineStoreNames = [\n    'assignmentStore',\n    'dependencyStore',\n    'eventStore',\n    'resourceStore'\n];\n\n/**\n * Creates a Project using any configured stores, and sets the stores configured into the project into\n * the host object.\n *\n * @mixin\n */\nexport default Target => class ProjectConsumer extends (Target || Base) {\n    static get $name() {\n        return 'ProjectConsumer';\n    }\n\n    //region Default config\n\n    static get declarable() {\n        return ['projectStores'];\n    }\n\n    static get configurable() {\n        return {\n            projectModelClass : ProjectModel,\n\n            // TODO: move to SchedulerProBase and SchedulerBase to specify different types\n            /**\n             * The {@link Scheduler.model.ProjectModel} instance, containing the data visualized by the Scheduler.\n             *\n             * **Note:** In SchedulerPro the project is instance of SchedulerPro.model.ProjectModel class.\n             * @member {Scheduler.model.ProjectModel} project\n             * @typings {ProjectModel}\n             * @category Data\n             */\n            /**\n             * A {@link Scheduler.model.ProjectModel} instance or a config object. The project holds all Scheduler data.\n             * Can be omitted in favor of individual store configs or {@link Scheduler.view.mixin.SchedulerStores#config-crudManager} config.\n             *\n             * **Note:** This config is **mandatory** in SchedulerPro. See SchedulerPro.model.ProjectModel class.\n             * @config {Scheduler.model.ProjectModel|ProjectModelConfig} project\n             * @category Data\n             */\n            project : {},\n\n            /**\n             * Configure as `true` to destroy the Project and stores when `this` is destroyed.\n             * @config {Boolean}\n             * @category Data\n             */\n            destroyStores : null,\n\n            // Will be populated by AttachToProjectMixin which features mix in\n            projectSubscribers : []\n        };\n    }\n\n    //endregion\n\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n\n        super.startConfigure(config);\n    }\n\n    //region Project\n\n    // This is where all the ingestion happens.\n    // At config time, the changers inject incoming values into the project config object\n    // that we are building. At the end we instantiate the project with all incoming\n    // config values filled in.\n    changeProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectStoreNames,\n                projectDataNames\n            }  = me.constructor;\n\n        me.projectCallbacks = new Set();\n\n        if (project) {\n            // Flag for changes to know what stage we are at\n            me.buildingProjectConfig = true;\n\n            if (!project.isModel) {\n                // When configuring, prio order:\n                // 1. If using an already existing CrudManager, it is assumed to already have the stores we should use,\n                //    adopt them as ours.\n                // 2. If a supplied store already has a project, it is assumed to be shared with another scheduler and\n                //    that project is adopted as ours. Unless we are given some store not part of that project,\n                //    in which case we create a new project.\n                // 3. Use stores from a supplied project config.\n                // 4. Use stores configured on scheduler.\n                // + Pass on inline data (events, resources, dependencies, assignments -> xxData on the project config)\n                //\n                // What happens during project initialization is this:\n                // this._project is the project *config* object.\n                // changeXxxx methods put incoming values directly into it through this.project\n                // to be used as its configuration.\n                // So when it is instantiated, it has had all configs injected.\n                if (me.isConfiguring) {\n                    // Set property for changers to put incoming values into\n                    me._project = project;\n\n                    // crudManager will be a clone of the raw config if it is a raw config.\n                    const { crudManager } = me;\n\n                    // Pull in stores from the crudManager config first\n                    if (crudManager) {\n                        const { isCrudManager } = crudManager;\n\n                        for (const storeName of projectStoreNames) {\n                            if (crudManager[storeName]) {\n\n                                // We configure the project with the stores, and *not* the CrudManager.\n                                // The CrudManager ends up having its project set and thereby adopting ours.\n                                me[storeName] = crudManager[storeName];\n\n                                // If it's just a config, take the stores out.\n                                // We will *configure* it with this project and it will ingest\n                                // its stores from there.\n                                if (!isCrudManager) {\n                                    delete crudManager[storeName];\n                                }\n                            }\n                        }\n                    }\n\n                    // Pull in all our configured stores into the project config object.\n                    // That also extracts any project into this._sharedProject\n                    me.getConfig('projectStores');\n\n                    // Referencing these data configs causes them to be pulled into\n                    // the _project.xxxData config property if they are present.\n                    for (const dataName of projectDataNames) {\n                        me.getConfig(dataName);\n                    }\n                }\n\n                const { eventStore } = project;\n                let { _sharedProject : sharedProject } = me;\n\n                // Delay autoLoading until listeners are set up, to be able to inject params\n                if (eventStore && !eventStore.isEventStoreMixin && eventStore.autoLoad && !eventStore.count) {\n                    eventStore.autoLoad = false;\n                    me.delayAutoLoad = true;\n                }\n\n                // We should not adopt a project from a store if we are given any store not part of that project\n                if (sharedProject && engineStoreNames.some(store => project[store] && project[store] !== sharedProject[store])) {\n                    // We have to chain any store used by the other project, they can only belong to one\n                    for (const store of engineStoreNames) {\n                        if (project[store] && project[store] === sharedProject[store]) {\n                            project[store] = project[store].chain();\n                        }\n                    }\n\n                    sharedProject = null;\n                }\n\n                // Use sharedProject if found, else instantiate our config.\n                project = sharedProject || new me.projectModelClass(project);\n\n                // Clear the property so that the updater is called.\n                delete me._project;\n            }\n\n            // In the updater, configs are live\n            me.buildingProjectConfig = false;\n        }\n\n        return project;\n    }\n\n    /**\n     * Implement in subclass to take action when project is replaced.\n     *\n     * __`super.updateProject(...arguments)` must be called first.__\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     * @category Data\n     */\n    updateProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectListeners,\n                crudManager\n            }  = me;\n\n        me.detachListeners('projectConsumer');\n\n        // When we set the crudManager now, it will go through to the CrudManagerVIew\n        delete me._crudManager;\n\n        if (project) {\n            projectListeners.thisObj = me;\n            project.ion(projectListeners);\n\n            // If the project is a CrudManager, use it as such.\n            if (project.isCrudManager) {\n                me.crudManager = project;\n            }\n            // Apply the project to CrudManager, making sure the same stores are used there and here\n            else if (crudManager) {\n                crudManager.project = project;\n\n                // CrudManager goes through the changer as usual and is initialized\n                // from the Project, not any stores it was originally configured with.\n                me.crudManager = crudManager;\n            }\n\n            // Notifies classes that mix AttachToProjectMixin that we have a new project\n            me.projectSubscribers.forEach(subscriber => subscriber.attachToProject(project));\n\n            // Sets the project's stores into the host object\n            for (const storeName of me.constructor.projectStoreNames) {\n                me[storeName] = project[storeName];\n            }\n\n            // Listeners are set up, if EventStore was configured with autoLoad now is the time to load\n            if (me.delayAutoLoad) {\n                // Restore the flag, not needed but to look good on inspection\n                project.eventStore.autoLoad = true;\n                project.eventStore.load();\n            }\n\n        }\n\n        me.trigger('projectChange', { project });\n    }\n\n    // Implementation here because we need to get first look at it to adopt its stores\n    changeCrudManager(crudManager) {\n        // Set the property to be scanned for incoming stores.\n        // If it's a config, it will be stripped of those stores prior to construction.\n        if (this.buildingProjectConfig) {\n            this._crudManager = crudManager.isCrudManager ? crudManager : Object.assign({}, crudManager);\n        }\n        else {\n            return super.changeCrudManager(crudManager);\n        }\n    }\n\n    // Called when project changes are committed, after data is written back to records\n    onProjectDataReady() {\n        const me = this;\n\n        // Only update the UI when we are visible\n        me.whenVisible(() => {\n            if (me.projectCallbacks.size) {\n                me.projectCallbacks.forEach(callback => callback());\n                me.projectCallbacks.clear();\n            }\n        }, null, null, 'onProjectDataReady');\n    }\n\n    // When project changes time zone, change start and end dates\n    onTimeZoneChange({ timeZone, oldTimeZone }) {\n        const me = this;\n\n        if (me.startDate) {\n            const startDate = oldTimeZone ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n        }\n    }\n\n    /**\n     * Accepts a callback that will be called when the underlying project is ready (no commit pending and current commit\n     * finalized)\n     * @param {Function} callback\n     * @category Data\n     */\n    whenProjectReady(callback) {\n        // Might already be ready, call directly\n        if (this.isEngineReady) {\n            callback();\n        }\n        else {\n            this.projectCallbacks.add(callback);\n        }\n    }\n\n    /**\n     * Returns `true` if engine is in a stable calculated state, `false` otherwise.\n     * @property {Boolean}\n     */\n    get isEngineReady() {\n        // NonWorkingTime calls this during destruction, hence the ?.\n        return Boolean(this.project.isEngineReady?.());\n    }\n\n    //endregion\n\n    //region Destroy\n\n    // Cleanup, destroys stores if this.destroyStores is true.\n    doDestroy() {\n        super.doDestroy();\n\n        if (this.destroyStores) {\n            // Shared project might already be destroyed\n            !this.project.isDestroyed && this.project.destroy();\n        }\n    }\n\n    //endregion\n\n    get projectStores() {\n        const { projectStoreNames } = this.constructor;\n\n        return projectStoreNames.map(storeName => this[storeName]);\n    }\n\n    static get projectStoreNames() {\n        return Object.keys(this.projectStores);\n    }\n\n    static get projectDataNames() {\n        return this.projectStoreNames.reduce((result, storeName) => {\n            const { dataName } = this.projectStores[storeName];\n\n            if (dataName) {\n                result.push(dataName);\n            }\n            return result;\n        }, []);\n    }\n\n    static setupProjectStores(cls, meta) {\n        const { projectStores } = cls;\n\n        if (projectStores) {\n            const\n                projectListeners  = {\n                    name           : 'projectConsumer',\n                    dataReady      : 'onProjectDataReady',\n                    change         : 'relayProjectDataChange',\n                    timeZoneChange : 'onTimeZoneChange'\n                },\n                storeConfigs      = {\n                    projectListeners\n                };\n\n            let previousDataName;\n\n            // Create a property and updater for each dataName and a changer for each store\n            for (const storeName in projectStores) {\n                const { dataName } = projectStores[storeName];\n\n                // Define \"eventStore\" and \"events\" configs\n                storeConfigs[storeName] = storeConfigs[dataName] = null;\n\n                // Define up the \"events\" property\n                if (dataName) {\n                    // Getter to return store data\n                    Object.defineProperty(meta.class.prototype, dataName, {\n                        configurable : true, // So that Config can add its setter.\n                        get() {\n                            // get events() { return this.project.eventStore.records; }\n                            return this.project[storeName]?.records;\n                        }\n                    });\n\n                    // Create an updater for the data name;\n                    this.createDataUpdater(storeName, dataName, previousDataName, meta);\n                }\n\n                this.createStoreDescriptor(meta, storeName, projectStores[storeName], projectListeners);\n\n                // The next data updater must reference this data name\n                previousDataName = dataName;\n            }\n\n            // Create the projectListeners config.\n            this.setupConfigs(meta, storeConfigs);\n        }\n    }\n\n    static createDataUpdater(storeName, dataName, previousDataName, meta) {\n        // Create eg \"updateEvents(data)\".\n        // We need it to call this.getConfig('resources') so that ordering of\n        // data ingestion is corrected.\n        meta.class.prototype[`update${StringHelper.capitalize(dataName)}`] = function(data) {\n            const { project } = this;\n\n            // Ensure a dataName that we depend on is called in.\n            // For example dependencies must load in order after the events.\n            previousDataName && this.getConfig(previousDataName);\n\n            if (this.buildingProjectConfig) {\n                // Set the property in the project config object.\n                // eg project.eventsData = [...]\n                project[`${dataName}Data`] = data;\n            }\n            else {\n                // Live update the project when in use.\n                project[storeName].data = data;\n            }\n        };\n    }\n\n    static createStoreDescriptor(meta, storeName, { listeners }, projectListeners) {\n        const\n            { prototype : clsProto } = meta.class,\n            storeNameCap             = StringHelper.capitalize(storeName);\n\n        // Set up onProjectEventStoreChange to set this.eventStore\n        projectListeners[`${storeName}Change`] = function({ store }) {\n            this[storeName] = store;\n        };\n\n        // create changeEventStore\n        clsProto[`change${storeNameCap}`] = function(store, oldStore) {\n            const\n                me           = this,\n                { project }  = me,\n                storeProject = store?.project;\n\n            if (me.buildingProjectConfig) {\n                // Capture any project found at project config time\n                // to use as our shared project\n                if (storeProject?.isProjectModel) {\n                    me._sharedProject = storeProject;\n                }\n\n                // Set the property in the project config object.\n                // Must not go through the updater. It's too early to\n                // inform host of store change.\n                project[storeName] = store;\n                return;\n            }\n\n            // Live update the project when in use.\n            if (!me.initializingProject) {\n                if (project[storeName] !== store) {\n                    project[`set${storeNameCap}`](store);\n                    store = project[storeName];\n                }\n            }\n\n            // Implement processing here instead of creating a separate updater.\n            // Subclasses can implement updaters.\n            if (store !== oldStore) {\n                if (listeners) {\n                    listeners.thisObj = me;\n                    listeners.name = `${storeName}Listeners`;\n\n                    me.detachListeners(listeners.name);\n\n                    store.ion(listeners);\n                }\n\n                // Set backing var temporarily, so it can be accessed from AttachToProjectMixin subscribers\n                me[`_${storeName}`] = store;\n\n                // Notifies classes that mix AttachToProjectMixin that we have a new XxxxxStore\n                me.projectSubscribers.forEach(subscriber => {\n                    subscriber[`attachTo${storeNameCap}`]?.(store);\n                });\n\n                me[`_${storeName}`] = null;\n            }\n            return store;\n        };\n    }\n\n    relayProjectDataChange(event) {\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each stores own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Scheduler.data.mixin.ProjectConsumer} source Owning component\n         * @param {Scheduler.model.mixin.ProjectModelMixin} project Project model\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('dataChange', { project : event.source, ...event, source : this });\n    }\n\n    //region WidgetClass\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    //endregion\n};\n","import Base from '../../Core/Base.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n\n/**\n * @module Scheduler/tooltip/ClockTemplate\n */\n\n/**\n * A template showing a clock, it consumes an object containing a date and a text\n * @private\n */\nexport default class ClockTemplate extends Base {\n    static get defaultConfig() {\n        return {\n            minuteHeight : 8,\n            minuteTop    : 2,\n            hourHeight   : 8,\n            hourTop      : 2,\n            handLeft     : 10,\n            div          : document.createElement('div'),\n            scheduler    : null, // may be passed to the constructor if needed\n            // `b-sch-clock-day` for calendar icon\n            // `b-sch-clock-hour` for clock icon\n            template(data) {\n                return `<div class=\"b-sch-clockwrap b-sch-clock-${data.mode || this.mode} ${data.cls || ''}\">\n                    <div class=\"b-sch-clock\">\n                        <div class=\"b-sch-hour-indicator\">${DateHelper.format(data.date, 'MMM')}</div>\n                        <div class=\"b-sch-minute-indicator\">${DateHelper.format(data.date, 'D')}</div>\n                        <div class=\"b-sch-clock-dot\"></div>\n                    </div>\n                    <span class=\"b-sch-clock-text\">${StringHelper.encodeHtml(data.text)}</span>\n                </div>`;\n            }\n        };\n    }\n\n    generateContent(data) {\n        return this.div.innerHTML = this.template(data);\n    }\n\n    updateDateIndicator(el, date) {\n        const\n            hourIndicatorEl   = el?.querySelector('.b-sch-hour-indicator'),\n            minuteIndicatorEl = el?.querySelector('.b-sch-minute-indicator');\n\n        if (date && hourIndicatorEl && minuteIndicatorEl && BrowserHelper.isBrowserEnv) {\n            if (this.mode === 'hour') {\n                hourIndicatorEl.style.transform   = `rotate(${(date.getHours() % 12) * 30}deg)`;\n                minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;\n            }\n            else {\n                hourIndicatorEl.style.transform   = 'none';\n                minuteIndicatorEl.style.transform = 'none';\n            }\n        }\n    }\n\n    set mode(mode) {\n        this._mode = mode;\n    }\n\n    // `day` mode for calendar icon\n    // `hour` mode for clock icon\n    get mode() {\n        if (this._mode) {\n            return this._mode;\n        }\n\n        //<debug>\n        if (!this.scheduler) {\n            throw new Error('`scheduler` config has to be specified for the clock template');\n        }\n        //</debug>\n\n        const\n            unitLessThanDay        = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,\n            formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);\n\n        return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';\n    }\n\n    set template(template) {\n        this._template = template;\n    }\n\n    /**\n     * Get the clock template, which accepts an object of format { date, text }\n     * @property {function(*): string}\n     */\n    get template() {\n        return this._template;\n    }\n}\n","import ContextMenuBase from '../../../Core/feature/base/ContextMenuBase.js';\n\n/**\n * @module Scheduler/feature/base/TimeSpanMenuBase\n */\n\n/**\n * Abstract base class used by other context menu features which show the context menu for TimeAxis.\n * Using this class you can make sure the menu expects the target to disappear,\n * since it can be scroll out of the scheduling zone.\n *\n * Features that extend this class are:\n *  * {@link Scheduler/feature/EventMenu};\n *  * {@link Scheduler/feature/ScheduleMenu};\n *  * {@link Scheduler/feature/TimeAxisHeaderMenu};\n *\n * @extends Core/feature/base/ContextMenuBase\n * @abstract\n */\nexport default class TimeSpanMenuBase extends ContextMenuBase {\n}\n","import Popup from '../../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceConfirmationPopup\n */\n\n/**\n * Confirmation dialog showing up before modifying a recurring event or some of its occurrences.\n * For recurring events the dialog notifies user that the event change/removal will cause all its occurrences\n * change/removal and asks to confirm the action.\n *\n * And for occurrences the dialog allows to choose if user wants to affect all further occurrences, this occurrence only or cancel the change.\n *\n * Usage example:\n *\n * ```javascript\n * const confirmation = new RecurrenceConfirmationPopup();\n *\n * confirmation.confirm({\n *     eventRecord : recurringEvent,\n *     actionType  : \"delete\",\n *     changerFn   : () => recurringEvent.remove(event)\n * });\n * ```\n *\n * @classType recurrenceconfirmation\n * @extends Core/widget/Popup\n */\nexport default class RecurrenceConfirmationPopup extends Popup {\n\n    static get $name() {\n        return 'RecurrenceConfirmationPopup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceconfirmation';\n    }\n\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            align                 : 'b-t',\n            autoShow              : false,\n            autoClose             : false,\n            closeAction           : 'onRecurrenceClose',\n            modal                 : true,\n            centered              : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            draggable             : true,\n            closable              : true,\n            floating              : true,\n            eventRecord           : null,\n            cls                   : 'b-sch-recurrenceconfirmation',\n            bbar                  : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    changeSingleButton : {\n                        weight  : 100,\n                        cls     : 'b-raised',\n                        color   : 'b-blue',\n                        text    : 'L{update-only-this-btn-text}',\n                        onClick : 'up.onChangeSingleButtonClick'\n                    },\n                    changeMultipleButton : {\n                        weight  : 200,\n                        color   : 'b-green',\n                        text    : 'L{Object.Yes}',\n                        onClick : 'up.onChangeMultipleButtonClick'\n                    },\n                    cancelButton : {\n                        weight  : 300,\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelButtonClick'\n                    }\n                }\n            }\n        };\n    }\n\n    /**\n     * Reference to the \"Apply changes to multiple occurrences\" button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeMultipleButton() {\n        return this.widgetMap.changeMultipleButton;\n    }\n\n    /**\n     * Reference to the button that causes changing of the event itself only, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeSingleButton() {\n        return this.widgetMap.changeSingleButton;\n    }\n\n    /**\n     * Reference to the cancel button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get cancelButton() {\n        return this.widgetMap.cancelButton;\n    }\n\n    /**\n     * Handler for \"Apply changes to multiple occurrences\" {@link #property-changeMultipleButton button}.\n     * It calls {@link #function-processMultipleRecords} and then hides the dialog.\n     */\n    onChangeMultipleButtonClick() {\n        this.processMultipleRecords();\n        this.hide();\n    }\n\n    /**\n     * Handler for the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     * It calls {@link #function-processSingleRecord} and then hides the dialog.\n     */\n    onChangeSingleButtonClick() {\n        this.processSingleRecord();\n        this.hide();\n    }\n\n    /**\n     * Handler for {@link #property-cancelButton cancel button}.\n     * It calls `cancelFn` provided to {@link #function-confirm} call and then hides the dialog.\n     */\n    onCancelButtonClick() {\n        this.cancelFn && this.cancelFn.call(this.thisObj);\n        this.hide();\n    }\n\n    onRecurrenceClose() {\n        if (this.cancelFn) {\n            this.cancelFn.call(this.thisObj);\n        }\n        this.hide();\n    }\n\n    /**\n     * Displays the confirmation.\n     * Usage example:\n     *\n     * ```javascript\n     * const popup = new RecurrenceConfirmationPopup();\n     *\n     * popup.confirm({\n     *     eventRecord,\n     *     actionType : \"delete\",\n     *     changerFn  : () => eventStore.remove(record)\n     * });\n     * ```\n     *\n     * @param {Object} config The following config options are supported:\n     * @param {Scheduler.model.EventModel} config.eventRecord   Event being modified.\n     * @param {'update'|'delete'} config.actionType Type of modification to be applied to the event. Can be\n     * either \"update\" or \"delete\".\n     * @param {Function} config.changerFn A function that should be called to apply the change to the event upon user\n     * choice.\n     * @param {Function} [config.thisObj] `changerFn` and `cancelFn` functions scope.\n     * @param {Function} [config.cancelFn] Function called on `Cancel` button click.\n     */\n    confirm(config = {}) {\n        const me = this;\n\n        //<debug>\n        if (!config || !config.actionType || !config.eventRecord) {\n            throw new Error('actionType and eventRecord must be specified for Scheduler.view.recurrence.RecurrenceConfirmationPopup');\n        }\n        //</debug>\n\n        [\n            'actionType',\n            'eventRecord',\n            'title',\n            'html',\n            'changerFn',\n            'cancelFn',\n            'finalizerFn',\n            'thisObj'\n        ].forEach(prop => {\n            if (prop in config) me[prop] = config[prop];\n        });\n\n        me.updatePopupContent();\n\n        return super.show(config);\n    }\n\n    updatePopupContent() {\n        const\n            me                                                         = this,\n            { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap,\n            { eventRecord, actionType = 'update' }                     = me,\n            isMaster                                                   = eventRecord?.isRecurring;\n\n        // Do not remove. Assertion strings for Localization sanity check.\n        // 'L{delete-further-message}'\n        // 'L{update-further-message}'\n        // 'L{delete-all-message}'\n        // 'L{update-all-message}'\n        // 'L{delete-further-btn-text}'\n        // 'L{update-further-btn-text}'\n        // 'L{delete-only-this-btn-text}'\n        // 'L{update-only-this-btn-text}'\n\n        if (isMaster) {\n            changeMultipleButton.text = me.L('L{Object.Yes}');\n            me.html = me.L(`${actionType}-all-message`);\n        }\n        else {\n            changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);\n            me.html = me.L(`${actionType}-further-message`);\n        }\n\n        changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);\n        cancelButton.text = me.L('L{Object.Cancel}');\n\n        me.width = me.L('L{width}');\n\n        // the following lines are added to satisfy the 904_unused localization test\n        // to let it know that these locales are used:\n        // this.L('L{delete-title}') not found\n        // this.L('L{update-title}') not found\n\n        me.title = me.L(`${actionType}-title`);\n    }\n\n    /**\n     * Applies changes to multiple occurrences as reaction on \"Apply changes to multiple occurrences\"\n     * {@link #property-changeMultipleButton button} click.\n     */\n    processMultipleRecords() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n\n        eventRecord.beginBatch();\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n\n        // afterChange will promote it to being an new recurring base because there's still recurrence\n        eventRecord.endBatch();\n\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n\n    /**\n     * Applies changes to a single record by making it a \"real\" event and adding an exception to the recurrence.\n     * The method is called as reaction on clicking the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     */\n    processSingleRecord() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n\n        eventRecord.beginBatch();\n\n        let firstOccurrence;\n\n        // If that's a master event get its very first occurrence\n        if (eventRecord?.isRecurring) {\n            eventRecord.recurrence.forEachOccurrence(eventRecord.startDate, null, (occurrence, isFirst, index) => {\n                // index 1 is used by to the event itself, > 1 since there might be exceptions\n                if (index > 1) {\n                    firstOccurrence = occurrence;\n                    return false;\n                }\n            });\n        }\n\n        // turn the 1st occurrence into a new \"master\" event\n        firstOccurrence?.convertToRealEvent();\n\n        // When the changes apply, because there's no recurrence, it will become an exception\n        eventRecord.recurrence = null;\n\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n\n        // Must also change after the callback in case the callback sets the rule.\n        // This will update the batch update data block to prevent it being set back to recurring.\n        eventRecord.recurrenceRule = null;\n\n        // afterChange will promote it to being an exception because there's no recurrence\n        eventRecord.endBatch();\n\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n\n    updateLocalization() {\n        this.updatePopupContent();\n        super.updateLocalization();\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceConfirmationPopup.initClass();\n","import Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n */\n\n/**\n * A combobox field allowing to pick frequency in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencefrequencycombo\n */\nexport default class RecurrenceFrequencyCombo extends Combo {\n\n    static $name = 'RecurrenceFrequencyCombo';\n\n    // Factoryable type name\n    static type = 'recurrencefrequencycombo';\n\n    static configurable = {\n        editable              : false,\n        displayField          : 'text',\n        valueField            : 'value',\n        localizeDisplayFields : true,\n        addNone               : false\n    };\n\n    buildItems() {\n        return [\n            ...(this.addNone ? [{ text : 'L{None}', value : 'NONE' }] : []),\n            { value : 'DAILY',   text : 'L{Daily}' },\n            { value : 'WEEKLY',  text : 'L{Weekly}' },\n            { value : 'MONTHLY', text : 'L{Monthly}' },\n            { value : 'YEARLY',  text : 'L{Yearly}' }\n        ];\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceFrequencyCombo.initClass();\n","import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysCombo\n */\n\n/**\n * A combobox field allowing to pick days for the `Monthly` and `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencedayscombo\n */\nexport default class RecurrenceDaysCombo extends Combo {\n\n    static get $name() {\n        return 'RecurrenceDaysCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedayscombo';\n    }\n\n    static get defaultConfig() {\n        const\n            allDaysValueAsArray = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'],\n            allDaysValue        = allDaysValueAsArray.join(',');\n\n        return {\n            allDaysValue,\n            editable            : false,\n            defaultValue        : allDaysValue,\n            workingDaysValue    : allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(','),\n            nonWorkingDaysValue : allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(','),\n            splitCls            : 'b-recurrencedays-split',\n            displayField        : 'text',\n            valueField          : 'value'\n        };\n    }\n\n    buildItems() {\n        const me = this;\n\n        me._weekDays = null;\n\n        return me.weekDays.concat([\n            { value : me.allDaysValue,        text : me.L('L{day}'), cls : me.splitCls },\n            { value : me.workingDaysValue,    text : me.L('L{weekday}') },\n            { value : me.nonWorkingDaysValue, text : me.L('L{weekend day}') }\n        ]);\n    }\n\n    get weekDays() {\n        const me = this;\n\n        if (!me._weekDays) {\n            const weekStartDay = DateHelper.weekStartDay;\n\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({ text, value : RecurrenceDayRuleEncoder.encodeDay(index) }));\n\n            // we should start week w/ weekStartDay\n            me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n\n        return me._weekDays;\n    }\n\n    set value(value) {\n        const me = this;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        let value = super.value;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        return value;\n    }\n}\n\n// Register this widget type with its Factory\nRecurrenceDaysCombo.initClass();\n","import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup\n */\n\n/**\n * A segmented button field allowing to pick days for the \"Weekly\" mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceDaysButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceDaysButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedaysbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                cls        : 'b-raised',\n                toggleable : true\n            }\n        };\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 7;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    updateItemText(item) {\n        const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];\n\n        item.text = DateHelper.getDayName(day).substring(0, 3);\n    }\n\n    buildItems() {\n        const me = this;\n\n        if (!me.__items) {\n            const weekStartDay = DateHelper.weekStartDay;\n\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({\n                text  : text.substring(0, 3),\n                value : RecurrenceDayRuleEncoder.encodeDay(index)\n            }));\n\n            // we should start week w/ weekStartDay\n            me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n\n        return me.__items;\n    }\n\n    set value(value) {\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        let value = super.value;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        return value;\n        // return value ? value.split(',') : [];\n    }\n\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceDaysButtonGroup.initClass();\n","import ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n\n/**\n * A segmented button field allowing to pick month days for the `Monthly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthDaysButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceMonthDaysButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthdaysbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n\n    get minValue() {\n        return 1;\n    }\n\n    get maxValue() {\n        return 31;\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 7;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    buildItems() {\n        const\n            me    = this,\n            items = [];\n\n        for (let value = me.minValue; value <= me.maxValue; value++) {\n            // button config\n            items.push({\n                text : value + '',\n                value\n            });\n        }\n\n        return items;\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceMonthDaysButtonGroup.initClass();\n","import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n\n/**\n * A segmented button field allowing to pick months for the `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthsButtonGroup extends ButtonGroup {\n\n    static get $name() {\n        return 'RecurrenceMonthsButtonGroup';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthsbuttongroup';\n    }\n\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n\n    construct(config = {}) {\n        const me = this;\n\n        config.columns = 4;\n        config.items   = me.buildItems();\n\n        super.construct(config);\n    }\n\n    buildItems() {\n        return DateHelper.getMonthNames().map((item, index) => ({\n            text  : item.substring(0, 3),\n            value : index + 1 // 1-based\n        }));\n    }\n\n    updateItemText(item) {\n        item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);\n    }\n\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrenceMonthsButtonGroup.initClass();\n","import Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceStopConditionCombo\n */\n\n/**\n * A combobox field allowing to choose stop condition for the recurrence in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencestopconditioncombo\n */\nexport default class RecurrenceStopConditionCombo extends Combo {\n\n    static get $name() {\n        return 'RecurrenceStopConditionCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencestopconditioncombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            placeholder  : 'Never',\n            displayField : 'text',\n            valueField   : 'value'\n        };\n    }\n\n    buildItems() {\n        return [\n            { value : 'never', text : this.L('L{Never}') },\n            { value : 'count', text : this.L('L{After}') },\n            { value : 'date',  text : this.L('L{On date}') }\n        ];\n    }\n\n    set value(value) {\n        // Use 'never' instead of falsy value\n        value = value || 'never';\n\n        super.value = value;\n    }\n\n    get value() {\n        return super.value;\n    }\n\n    get recurrence() {\n        return this._recurrence;\n    }\n\n    set recurrence(recurrence) {\n        let value = null;\n\n        if (recurrence.endDate) {\n            value = 'date';\n        }\n        else if (recurrence.count) {\n            value = 'count';\n        }\n\n        this._recurrence = recurrence;\n\n        this.value = value;\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceStopConditionCombo.initClass();\n","import ArrayHelper from '../../../../Core/helper/ArrayHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrencePositionsCombo\n */\n\n/**\n * A combobox field allowing to specify day positions in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence editor}.\n *\n * @extends Core/widget/Combo\n * @classType recurrencepositionscombo\n */\nexport default class RecurrencePositionsCombo extends Combo {\n\n    static get $name() {\n        return 'RecurrencePositionsCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencepositionscombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            splitCls     : 'b-sch-recurrencepositions-split',\n            displayField : 'text',\n            valueField   : 'value',\n            defaultValue : 1,\n            maxPosition  : 5\n        };\n    }\n\n    buildItems() {\n        const me = this;\n\n        return me.buildDayNumbers().concat([\n            // the following lines are added to satisfy the 904_unused localization test\n            // to let it know that these locales are used:\n            // this.L('L{position-1}')\n            { value : '-1', text : me.L('L{position-1}'), cls : me.splitCls }\n        ]);\n    }\n\n    buildDayNumbers() {\n        const me = this;\n\n        // the following lines are added to satisfy the 904_unused localization test\n        // to let it know that these locales are used:\n        // this.L('L{position1}')\n        // this.L('L{position2}')\n        // this.L('L{position3}')\n        // this.L('L{position4}')\n        // this.L('L{position5}')\n\n        return ArrayHelper.populate(me.maxPosition, i => (\n            { value : i + 1, text : me.L(`position${i + 1}`) }\n        ));\n    }\n\n    set value(value) {\n        const me = this;\n\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n\n        super.value = value;\n    }\n\n    get value() {\n        const value = super.value;\n\n        return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];\n    }\n\n};\n\n// Register this widget type with its Factory\nRecurrencePositionsCombo.initClass();\n","import RecurrenceDayRuleEncoder from '../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport Panel from '../../../Core/widget/Panel.js';\nimport '../../../Core/widget/Widget.js';\nimport '../../../Core/widget/Button.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/NumberField.js';\nimport './field/RecurrenceFrequencyCombo.js';\nimport './field/RecurrenceDaysCombo.js';\nimport './field/RecurrenceDaysButtonGroup.js';\nimport './field/RecurrenceMonthDaysButtonGroup.js';\nimport './field/RecurrenceMonthsButtonGroup.js';\nimport './field/RecurrenceStopConditionCombo.js';\nimport './field/RecurrencePositionsCombo.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditorPanel\n */\n\n/**\n * Panel containing fields used to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. Used by\n * {@link Scheduler/view/recurrence/RecurrenceEditor}, and by the recurrence tab in Scheduler Pro's event editor.\n *\n * Not intended to be used separately.\n *\n * @extends Core/widget/Panel\n * @classType recurrenceeditorpanel\n * @private\n */\nexport default class RecurrenceEditorPanel extends Panel {\n\n    static $name = 'RecurrenceEditorPanel';\n\n    static type = 'recurrenceeditorpanel';\n\n    static configurable = {\n        cls     : 'b-recurrenceeditor',\n        record  : false,\n        addNone : false,\n        items   : {\n            frequencyField : {\n                type     : 'recurrencefrequencycombo',\n                name     : 'frequency',\n                label    : 'L{RecurrenceEditor.Frequency}',\n                weight   : 10,\n                onChange : 'up.onFrequencyFieldChange',\n                addNone  : 'up.addNone'\n            },\n            intervalField : {\n                type     : 'numberfield',\n                weight   : 15,\n                name     : 'interval',\n                label    : 'L{RecurrenceEditor.Every}',\n                min      : 1,\n                required : true\n            },\n            daysButtonField : {\n                type         : 'recurrencedaysbuttongroup',\n                weight       : 20,\n                name         : 'days',\n                forFrequency : 'WEEKLY'\n            },\n            // the radio button enabling \"monthDaysButtonField\" in MONTHLY mode\n            monthDaysRadioField : {\n                type         : 'checkbox',\n                weight       : 30,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY',\n                label        : 'L{RecurrenceEditor.Each}',\n                checked      : true,\n                onChange     : 'up.onMonthDaysRadioFieldChange'\n            },\n            monthDaysButtonField : {\n                type         : 'recurrencemonthdaysbuttongroup',\n                weight       : 40,\n                name         : 'monthDays',\n                forFrequency : 'MONTHLY'\n            },\n            monthsButtonField : {\n                type         : 'recurrencemonthsbuttongroup',\n                weight       : 50,\n                name         : 'months',\n                forFrequency : 'YEARLY'\n            },\n            // the radio button enabling positions & days combos in MONTHLY & YEARLY modes\n            positionAndDayRadioField : {\n                type         : 'checkbox',\n                weight       : 60,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY|YEARLY',\n                label        : 'L{RecurrenceEditor.On the}',\n                onChange     : 'up.onPositionAndDayRadioFieldChange'\n            },\n            positionsCombo : {\n                type         : 'recurrencepositionscombo',\n                weight       : 80,\n                name         : 'positions',\n                forFrequency : 'MONTHLY|YEARLY'\n            },\n            daysCombo : {\n                type         : 'recurrencedayscombo',\n                weight       : 90,\n                name         : 'days',\n                forFrequency : 'MONTHLY|YEARLY',\n                flex         : 1\n            },\n            stopRecurrenceField : {\n                type     : 'recurrencestopconditioncombo',\n                weight   : 100,\n                label    : 'L{RecurrenceEditor.End repeat}',\n                onChange : 'up.onStopRecurrenceFieldChange'\n            },\n            countField : {\n                type     : 'numberfield',\n                weight   : 110,\n                name     : 'count',\n                min      : 2,\n                required : true,\n                disabled : true,\n                label    : ' '\n            },\n            endDateField : {\n                type     : 'datefield',\n                weight   : 120,\n                name     : 'endDate',\n                hidden   : true,\n                disabled : true,\n                label    : ' ',\n                required : true\n            }\n        }\n    }\n\n    updateRecord(record) {\n        super.updateRecord(record);\n\n        const\n            me = this,\n            {\n                frequencyField,\n                daysButtonField,\n                monthDaysButtonField,\n                monthsButtonField,\n                monthDaysRadioField,\n                positionAndDayRadioField,\n                stopRecurrenceField\n            }  = me.widgetMap;\n\n        if (record) {\n            const\n                event     = record.timeSpan,\n                startDate = event?.startDate;\n\n            // some fields default values are calculated based on event \"startDate\" value\n            if (startDate) {\n                // if no \"days\" value provided\n                if (!record.days || !record.days.length) {\n                    daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];\n                }\n\n                // if no \"monthDays\" value provided\n                if (!record.monthDays || !record.monthDays.length) {\n                    monthDaysButtonField.value = startDate.getDate();\n                }\n\n                // if no \"months\" value provided\n                if (!record.months || !record.months.length) {\n                    monthsButtonField.value = startDate.getMonth() + 1;\n                }\n            }\n\n            // if the record has both \"days\" & \"positions\" fields set check \"On the\" checkbox\n            if (record.days && record.positions) {\n                positionAndDayRadioField.check();\n                // TODO: if toggleGroup members are not painted automatic unchecking doesn't work\n                if (!me.isPainted) {\n                    monthDaysRadioField.uncheck();\n                }\n            }\n            else {\n                monthDaysRadioField.check();\n                // TODO: if toggleGroup members are not painted automatic unchecking doesn't work\n                if (!me.isPainted) {\n                    positionAndDayRadioField.uncheck();\n                }\n            }\n\n            stopRecurrenceField.recurrence = record;\n        }\n        else {\n            frequencyField.value = 'NONE';\n        }\n    }\n\n    /**\n     * Updates the provided recurrence model with the contained form data.\n     * If recurrence model is not provided updates the last loaded recurrence model.\n     * @internal\n     */\n    syncEventRecord(recurrence) {\n        // get values relevant to the RecurrenceModel (from enabled fields only)\n        const values = this.getValues((w) => w.name in recurrence && !w.disabled);\n\n        // Disabled field does not contribute to values, clear manually\n        if (!('endDate' in values)) {\n            values.endDate = null;\n        }\n        if (!('count' in values)) {\n            values.count = null;\n        }\n\n        recurrence.set(values);\n    }\n\n    toggleStopFields() {\n        const\n            me                           = this,\n            { countField, endDateField } = me.widgetMap;\n\n        switch (me.widgetMap.stopRecurrenceField.value) {\n\n            case 'count' :\n                countField.show();\n                countField.enable();\n                endDateField.hide();\n                endDateField.disable();\n                break;\n\n            case 'date' :\n                countField.hide();\n                countField.disable();\n                endDateField.show();\n                endDateField.enable();\n                break;\n\n            default :\n                countField.hide();\n                endDateField.hide();\n                countField.disable();\n                endDateField.disable();\n        }\n    }\n\n    onMonthDaysRadioFieldChange({ checked }) {\n        const { monthDaysButtonField } = this.widgetMap;\n\n        monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);\n    }\n\n    onPositionAndDayRadioFieldChange({ checked }) {\n        const { daysCombo, positionsCombo } = this.widgetMap;\n\n        // toggle day & positions combos\n        daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);\n    }\n\n    onStopRecurrenceFieldChange() {\n        this.toggleStopFields();\n    }\n\n    isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {\n        return !widget.forFrequency || widget.forFrequency.includes(frequency);\n    }\n\n    onFrequencyFieldChange({ value, oldValue, valid }) {\n        const\n            me    = this,\n            items = me.queryAll(w => 'forFrequency' in w),\n            {\n                intervalField,\n                stopRecurrenceField\n            }     = me.widgetMap;\n\n        if (valid && value) {\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n\n                if (me.isWidgetAvailableForFrequency(item, value)) {\n                    item.show();\n                    item.enable();\n                }\n                else {\n                    item.hide();\n                    item.disable();\n                }\n            }\n\n            // Special handling of NONE\n            intervalField.hidden = stopRecurrenceField.hidden = value === 'NONE';\n\n            if (value !== 'NONE') {\n                intervalField.hint = me.L(`L{RecurrenceEditor.${value}intervalUnit}`);\n            }\n\n            // When a non-recurring record is loaded, intervalField is set to empty. We want it to default to 1 here\n            // to not look weird (defaults to 1 on the data layer)\n            if (oldValue === 'NONE' && intervalField.value == null) {\n                intervalField.value = 1;\n            }\n\n            me.toggleFieldsState();\n        }\n    }\n\n    toggleFieldsState() {\n        const\n            me            = this,\n            { widgetMap } = me;\n\n        me.onMonthDaysRadioFieldChange({ checked : widgetMap.monthDaysRadioField.checked });\n        me.onPositionAndDayRadioFieldChange({ checked : widgetMap.positionAndDayRadioField.checked });\n        me.onStopRecurrenceFieldChange();\n    }\n\n    updateLocalization() {\n        // do extra labels translation (not auto-translated yet)\n        const { countField, intervalField, frequencyField } = this.widgetMap;\n\n        countField.hint = this.L('L{RecurrenceEditor.time(s)}');\n\n        if (frequencyField.value && frequencyField.value !== 'NONE') {\n            intervalField.hint = this.L(`L{RecurrenceEditor.${frequencyField.value}intervalUnit}`);\n        }\n\n        super.updateLocalization();\n    }\n\n}\n\n// Register this widget type with its Factory\nRecurrenceEditorPanel.initClass();\n","import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport TimeSpanMenuBase from './base/TimeSpanMenuBase.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\n\n/**\n * @module Scheduler/feature/EventMenu\n */\n\n/**\n * Displays a context menu for events. Items are populated by other features and/or application code.\n *\n * ### Default event menu items\n *\n * Here is the list of menu items provided by the feature and populated by the other features:\n *\n * | Reference       | Text           | Weight | Feature                                  | Description                                                       |\n * |-----------------|----------------|--------|------------------------------------------|-------------------------------------------------------------------|\n * | `editEvent`     | Edit event     | 100    | {@link Scheduler/feature/EventEdit}      | Edit in the event editor. Hidden when read-only                   |\n * | `copyEvent`     | Copy event     | 110    | {@link Scheduler/feature/EventCopyPaste} | Copy event or assignment. Hidden when read-only                   |\n * | `cutEvent `     | Cut event      | 120    | {@link Scheduler/feature/EventCopyPaste} | Cut event or assignment. Hidden when read-only                    |\n * | `deleteEvent`   | Delete event   | 200    | *This feature*                           | Remove event. Hidden when read-only                               |\n * | `unassignEvent` | Unassign event | 300    | *This feature*                           | Unassign event. Hidden when read-only, shown for multi-assignment |\n * | `splitEvent`    | Split event    | 650    | *Scheduler Pro only*                     | Split an event into two segments at the mouse position            |\n * | `renameSegment` | Rename segment | 660    | *Scheduler Pro only*                     | Show an inline editor to rename the segment                       |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Event menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({eventRecord}) {\n *                         eventRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent   : false,\n *                 unassignEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent : {\n *                     text : 'Delete booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items for all events or specific events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             // Process items before menu is shown\n *             processItems({eventRecord, items}) {\n *                  // Push an extra item for conferences\n *                  if (eventRecord.type === 'conference') {\n *                      items.showSessionItem = {\n *                          text : 'Show sessions',\n *                          onItem({eventRecord}) {\n *                              // ...\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for secret events\n *                  if (eventRecord.type === 'secret') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Note that the {@link #property-menuContext} is applied to the Menu's `item` event, so your `onItem`\n * handler's single event parameter also contains the following properties:\n *\n * - **source** The {@link Scheduler.view.Scheduler} who's UI was right clicked.\n * - **targetElement** The element right clicked on.\n * - **eventRecord** The {@link Scheduler.model.EventModel event record} clicked on.\n * - **resourceRecord** The {@link Scheduler.model.ResourceModel resource record} clicked on.\n * - **assignmentRecord** The {@link Scheduler.model.AssignmentModel assignment record} clicked on.\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @demo Scheduler/eventmenu\n * @classtype eventMenu\n * @feature\n */\nexport default class EventMenu extends TimeSpanMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'EventMenu';\n    }\n\n    /**\n     * @member {Object} menuContext\n     * An informational object containing contextual information about the last activation\n     * of the context menu. The base properties are listed below.\n     * @property {Event} menuContext.domEvent The initiating event.\n     * @property {Event} menuContext.event DEPRECATED: The initiating event.\n     * @property {Number[]} menuContext.point The client `X` and `Y` position of the initiating event.\n     * @property {HTMLElement} menuContext.targetElement The target to which the menu is being applied.\n     * @property {Object<String,MenuItemConfig>} menuContext.items The context menu **configuration** items.\n     * @property {Core.data.Model[]} menuContext.selection The record selection in the client (Grid, Scheduler, Gantt or Calendar).\n     * @property {Scheduler.model.EventModel} menuContext.eventRecord The event record clicked on.\n     * @property {Scheduler.model.ResourceModel} menuContext.resourceRecord The resource record clicked on.\n     * @property {Scheduler.model.AssignmentModel} menuContext.assignmentRecord The assignment record clicked on.\n     * @readonly\n     */\n\n    static get configurable() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    eventMenu : {\n             *         processItems({ items, eventRecord, assignmentRecord, resourceRecord }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${eventRecord.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *            if (!eventRecord.allowDelete) {\n             *                 items.deleteEvent.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.EventModel} context.eventRecord The record representing the current event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord The assignment record\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null,\n\n            type : 'event'\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the property names which you may\n             * configure:\n             *\n             * - `deleteEvent` Deletes the context event.\n             * - `unassignEvent` Unassigns the context event from the current resource (only added when multi assignment is used).\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventMenu : {\n             *             items : {\n             *                 deleteEvent   : null,\n             *                 unassignEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateEventMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event eventMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     * @param {MouseEvent} [event] Pointer event which triggered the context menu (if any)\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event eventMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event eventMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    //endregion\n\n    get resourceStore() {\n        // In horizontal mode, we use store (might be a display store), in vertical & calendar we use resourceStore\n        return this.client.isHorizontal ? this.client.store : this.client.resourceStore;\n    }\n\n    getDataFromEvent(event) {\n        const\n            data             = super.getDataFromEvent(event),\n            eventElement     = data.targetElement,\n            { client }       = this,\n            eventRecord      = client.resolveEventRecord(eventElement),\n            // For vertical mode the resource must be resolved from the event\n            resourceRecord   = eventRecord && (client.resolveResourceRecord(eventElement) || this.resourceStore.last)?.$original,\n            assignmentRecord = eventRecord && client.resolveAssignmentRecord(eventElement);\n\n        return Object.assign(data, {\n            eventElement,\n            eventRecord,\n            resourceRecord,\n            assignmentRecord\n        });\n    }\n\n    getTargetElementFromEvent({ target }) {\n        return target.closest(this.client.eventSelector) || target;\n    }\n\n    shouldShowMenu(eventParams) {\n        return eventParams.eventRecord;\n    }\n\n    /**\n     * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)\n     * menu won't appear.\n     * @param {Scheduler.model.EventModel} eventRecord Event record to show menu for.\n     * @param {Object} [options]\n     * @param {HTMLElement} options.targetElement Element to align context menu to.\n     * @param {MouseEvent} options.event Browser event.\n     * If provided menu will be aligned according to clientX/clientY coordinates.\n     * If omitted, context menu will be centered to event element.\n     */\n    showContextMenuFor(eventRecord, { targetElement, event } = {}) {\n        if (this.disabled) {\n            return;\n        }\n\n        if (!targetElement) {\n            targetElement = this.getElementFromRecord(eventRecord);\n\n            // If record is not rendered, do nothing\n            if (!targetElement) {\n                return;\n            }\n        }\n\n        DomHelper.triggerMouseEvent(targetElement, this.tiggerEvent);\n    }\n\n    getElementFromRecord(record) {\n        return this.client.getElementsFromEventRecord(record)[0];\n    }\n\n    populateEventMenu({ items, eventRecord, assignmentRecord }) {\n        const { client } = this;\n\n        items.deleteEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly\n        };\n        items.unassignEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly || client.eventStore.usesSingleAssignment\n        };\n    }\n\n    // This generates the fixed, unchanging part of the items and is only called once\n    // to generate the baseItems of the feature.\n    // The dynamic parts which are set by populateEventMenu have this merged into them.\n    changeItems(items) {\n        const { client } = this;\n\n        return Objects.merge({\n            deleteEvent : {\n                text   : 'L{SchedulerBase.Delete event}',\n                icon   : 'b-icon b-icon-trash',\n                weight : 200,\n                onItem({ menu, eventRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that the our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    client.removeEvents(client.isEventSelected(eventRecord) ? client.selectedEvents : [eventRecord]);\n                }\n            },\n            unassignEvent : {\n                text   : 'L{SchedulerBase.Unassign event}',\n                icon   : 'b-icon b-icon-unassign',\n                weight : 300,\n                onItem({ menu, eventRecord, resourceRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that the our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    eventRecord.unassign(resourceRecord);\n                }\n            }\n        }, items);\n    }\n}\n\nEventMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(EventMenu, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventMenu, false, 'ResourceHistogram');\n","import TimeSpanMenuBase from '../../Scheduler/feature/base/TimeSpanMenuBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/feature/ScheduleMenu\n */\n\n/**\n * Displays a context menu for empty parts of the schedule. Items are populated in the first place\n * by configurations of this Feature, then by other features and/or application code.\n *\n * ### Default scheduler zone menu items\n *\n * The Scheduler menu feature provides only one item:\n *\n * | Reference      | Text        | Weight | Feature                                  | Description                                                           |\n * |----------------|-------------|--------|------------------------------------------|-----------------------------------------------------------------------|\n * | `addEvent`     | Add event   | 100    | *This feature*                           | Add new event at the target time and resource. Hidden when read-only  |\n * | `pasteEvent`   | Paste event | 110    | {@link Scheduler/feature/EventCopyPaste} | Paste event at the target time and resource. Hidden when is read-only |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Scheduler menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({date, resourceRecord, items}) {\n *                         // Custom date based action\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : {\n *                     text : 'Create new booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             // Process items before menu is shown\n *             processItems({date, resourceRecord, items}) {\n *                  // Add an extra item for ancient times\n *                  if (date < new Date(2018, 11, 17)) {\n *                      items.modernize = {\n *                          text : 'Modernize',\n *                          ontItem({date}) {\n *                              // Custom date based action\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for Sundays\n *                  if (date.getDay() === 0) {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @demo Scheduler/basic\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @classtype scheduleMenu\n * @feature\n */\nexport default class ScheduleMenu extends TimeSpanMenuBase {\n    //region Config\n\n    static get $name() {\n        return 'ScheduleMenu';\n    }\n\n    static get defaultConfig() {\n        return {\n            type : 'schedule',\n\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the predefined property names which you may\n             * configure:\n             *\n             * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         scheduleMenu : {\n             *             items : {\n             *                 addEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    scheduleMenu : {\n             *         processItems({ items, date, resourceRecord }) {\n             *            // Add or hide existing items here as needed\n             *            items.myAction = {\n             *                text   : 'Cool action',\n             *                icon   : 'b-fa b-fa-cat',\n             *                onItem : () => console.log(`Clicked on ${resourceRecord.name} at ${date}`),\n             *                weight : 1000 // Move to end\n             *            };\n             *\n             *            if (!resourceRecord.allowAdd) {\n             *                items.addEvent.hidden = true;\n             *            }\n             *        }\n             *    }\n             * },\n             * ```\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Date} context.date The clicked date\n             * @param {Object<String,MenuItemConfig>} context.items An object containing the\n             * {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @config {Function}\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n\n        config.chain.push('populateScheduleMenu');\n\n        return config;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event scheduleMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event scheduleMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event scheduleMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n\n    //endregion\n\n    shouldShowMenu(eventParams) {\n        const\n            { client } = this,\n            {\n                targetElement,\n                resourceRecord\n            } = eventParams,\n            isTimeAxisColumn = client.timeAxisSubGridElement.contains(targetElement);\n\n        return !targetElement.closest(client.eventSelector) && isTimeAxisColumn && !(resourceRecord && resourceRecord.isSpecialRow);\n    }\n\n    getDataFromEvent(event) {\n        // Process event if it wasn't yet processed\n        if (DomHelper.isDOMEvent(event)) {\n            const\n                { client }     = this,\n                cellData       = client.getCellDataFromEvent?.(event),\n                date           = client.getDateFromDomEvent?.(event, 'floor'),\n                // For vertical mode the resource must be resolved from the event\n                resourceRecord = client.resolveResourceRecord(event) || client.isVertical && client.resourceStore.last;\n\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData, { date, resourceRecord });\n        }\n\n        return event;\n    }\n\n    populateScheduleMenu({ items, resourceRecord, date }) {\n        const { client } = this;\n\n        // Menu can work for ResourceHistogram which doesn't have event store\n        if (!client.readOnly && client.eventStore) {\n            items.addEvent = {\n                text     : 'L{SchedulerBase.Add event}',\n                icon     : 'b-icon b-icon-add',\n                disabled : !resourceRecord || resourceRecord.readOnly || !resourceRecord.isWorkingTime(date),\n                weight   : 100,\n                onItem() {\n                    client.createEvent(date, resourceRecord, client.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n}\n\nScheduleMenu.featureClass = '';\n\nGridFeatureManager.registerFeature(ScheduleMenu, true, 'Scheduler');\n","import Base from '../../../Core/Base.js';\nimport '../recurrence/RecurrenceConfirmationPopup.js';\n\n/**\n * @module Scheduler/view/mixin/RecurringEvents\n */\n\n/**\n * A mixin that adds recurring events functionality to the Scheduler.\n *\n * The main purpose of the code in here is displaying a {@link Scheduler.view.recurrence.RecurrenceConfirmationPopup special confirmation}\n * on user mouse dragging/resizing/deleting recurring events and their occurrences.\n *\n * @mixin\n */\nexport default Target => class RecurringEvents extends (Target || Base) {\n    static $name = 'RecurringEvents';\n\n    static configurable = {\n        /**\n         * Enables showing occurrences of recurring events across the scheduler's time axis.\n         *\n         * Enables extra recurrence UI fields in the system-provided event editor (not in Scheduler Pro's task editor).\n         * @config {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        enableRecurringEvents : false,\n\n        recurrenceConfirmationPopup : {\n            $config : ['lazy'],\n            value   : {\n                type : 'recurrenceconfirmation'\n            }\n        }\n    };\n\n    construct(config) {\n        super.construct(config);\n\n        this.ion({\n            beforeEventDropFinalize   : 'onRecurrableBeforeEventDropFinalize',\n            beforeEventResizeFinalize : 'onRecurrableBeforeEventResizeFinalize',\n            beforeAssignmentDelete    : 'onRecurrableAssignmentBeforeDelete'\n        });\n    }\n\n    changeRecurrenceConfirmationPopup(recurrenceConfirmationPopup, oldRecurrenceConfirmationPopup) {\n        // Widget.reconfigure reither reconfigures an existing instance, or creates a new one, or,\n        // if the configuration is null, destroys the existing instance.\n        const result = this.constructor.reconfigure(oldRecurrenceConfirmationPopup, recurrenceConfirmationPopup, 'recurrenceconfirmation');\n        result.owner = this;\n        return result;\n    }\n\n    findRecurringEventToConfirmDelete(eventRecords) {\n        // show confirmation if we deal with at least one recurring event (or its occurrence)\n        // and if the record is not being edited by event editor (since event editor has its own confirmation)\n        return eventRecords.find(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n    }\n\n    onRecurrableAssignmentBeforeDelete({ assignmentRecords, context }) {\n        const\n            eventRecords = assignmentRecords.map(as => as.event),\n            eventRecord  = this.findRecurringEventToConfirmDelete(eventRecords);\n\n        if (this.enableRecurringEvents && eventRecord) {\n            this.recurrenceConfirmationPopup.confirm({\n                actionType : 'delete',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n\n            return false;\n        }\n    }\n\n    onRecurrableBeforeEventDropFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecords } = context,\n                recurringEvents = eventRecords.filter(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n\n            if (recurringEvents.length) {\n                context.async = true;\n\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType  : 'update',\n                    eventRecord : recurringEvents[0],\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n\n    onRecurrableBeforeEventResizeFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecord } = context,\n                isRecurring     = eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);\n\n            if (isRecurring) {\n                context.async = true;\n\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType : 'update',\n                    eventRecord,\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n\n    // Make sure occurrence cache is up-to-date when reassigning events\n    onAssignmentChange({ action, records : assignments }) {\n        if (action !== 'dataset' && Array.isArray(assignments)) {\n            for (const assignment of assignments) {\n                if (assignment.event?.isRecurring && !assignment.event.isBatchUpdating) {\n                    assignment.event.removeOccurrences();\n                }\n            }\n        }\n    }\n\n    /**\n     * Returns occurrences of the provided recurring event across the date range of this Scheduler.\n     * @param  {Scheduler.model.TimeSpan} recurringEvent Recurring event for which occurrences should be retrieved.\n     * @returns {Scheduler.model.TimeSpan[]} Array of the provided timespans occurrences.\n     *\n     * __Empty if the passed event is not recurring, or has no occurrences in the date range.__\n     *\n     * __If the date range encompasses the start point, the recurring event itself will be the first entry.__\n     * @category Data\n     */\n    getOccurrencesFor(recurringEvent) {\n        return this.eventStore.getOccurrencesForTimeSpan(recurringEvent, this.timeAxis.startDate, this.timeAxis.endDate);\n    }\n\n    /**\n     * Internal utility function to remove events. Used when pressing [DELETE] or [BACKSPACE] or when clicking the\n     * delete button in the event editor. Triggers a preventable `beforeEventDelete` or `beforeAssignmentDelete` event.\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} eventRecords Records to remove\n     * @param {Function} [callback] Optional callback executed after triggering the event but before deletion\n     * @returns {Boolean} Returns `false` if the operation was prevented, otherwise `true`\n     * @internal\n     * @fires beforeEventDelete\n     * @fires beforeAssignmentDelete\n     */\n    async removeEvents(eventRecords, callback = null, popupOwner = this) {\n        const me = this;\n\n        if (!me.readOnly && eventRecords.length) {\n            const context = {\n                finalize(removeRecord = true) {\n                    if (callback) {\n                        callback(removeRecord);\n                    }\n\n                    if (removeRecord !== false) {\n                        if (eventRecords.some(record => record.isOccurrence || record.event?.isOccurrence)) {\n                            eventRecords.forEach(record => record.isOccurrenceAssignment ? record.event.remove() : record.remove());\n                        }\n                        else {\n                            const store = eventRecords[0].isAssignment ? me.assignmentStore : me.eventStore;\n\n                            store.remove(eventRecords);\n                        }\n                    }\n                }\n            };\n\n            let shouldFinalize;\n\n            if (eventRecords[0].isAssignment) {\n                /**\n                 * Fires before an assignment is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or\n                 * by the event editor. Can for example be used to display a custom dialog to confirm deletion, in which\n                 * case records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeAssignmentDelete({ assignmentRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the assignments on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the assignments if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeAssignmentDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]   Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeAssignmentDelete', { assignmentRecords : eventRecords, context });\n            }\n            else {\n                /**\n                 * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the\n                 * event editor. Can for example be used to display a custom dialog to confirm deletion, in which case\n                 * records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeEventDelete({ eventRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the events on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the events if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeEventDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]  Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeEventDelete', { eventRecords, context });\n            }\n\n            if (shouldFinalize !== false) {\n                const recurringEventRecord = eventRecords.find(eventRecord => eventRecord.isRecurring || eventRecord.isOccurrence);\n\n                if (recurringEventRecord) {\n                    me.recurrenceConfirmationPopup.owner = popupOwner;\n                    me.recurrenceConfirmationPopup.confirm({\n                        actionType  : 'delete',\n                        eventRecord : recurringEventRecord,\n                        changerFn() {\n                            context.finalize(true);\n                        },\n                        cancelFn() {\n                            context.finalize(false);\n                        }\n                    });\n                }\n                else {\n                    context.finalize(true);\n                }\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","/**\n * @module Scheduler/view/mixin/CurrentConfig\n */\n\nconst\n    stores = [\n        'eventStore',\n        'taskStore',\n        'assignmentStore',\n        'resourceStore',\n        'dependencyStore',\n        'timeRangeStore',\n        'resourceTimeRangeStore'\n    ],\n    inlineProperties = [\n        'events',\n        'tasks',\n        'resources',\n        'assignments',\n        'dependencies',\n        'timeRanges',\n        'resourceTimeRanges'\n    ];\n\n/**\n * Mixin that makes sure inline data & crud manager data are removed from current config for products using a project.\n * The data is instead inlined in the project (by ProjectModel.js)\n *\n * @mixin\n * @private\n */\nexport default Target => class CurrentConfig extends Target {\n\n    static get $name() {\n        return 'CurrentConfig';\n    }\n\n    preProcessCurrentConfigs(configs) {\n        // Remove inline data on the component\n        for (const prop of inlineProperties) {\n            delete configs[prop];\n        }\n\n        super.preProcessCurrentConfigs(configs);\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const\n            project = this.project.getCurrentConfig(options),\n            result = super.getCurrentConfig(options);\n\n        // Force project with inline data\n        if (project) {\n            result.project = project;\n\n            const { crudManager } = result;\n\n            // Transfer crud store configs to project (mainly fields)\n            if (crudManager) {\n                for (const store of stores) {\n                    if (crudManager[store]) {\n                        project[store] = crudManager[store];\n                    }\n                }\n            }\n\n            if (Object.keys(project).length === 0) {\n                delete result.project;\n            }\n        }\n\n        // Store (resource store) data is included in project\n        delete result.data;\n\n        // Remove CrudManager, since data will be placed inline\n        delete result.crudManager;\n\n        return result;\n    }\n\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport Navigator from '../../../Core/helper/util/Navigator.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport Location from '../../../Grid/util/Location.js';\n\n/**\n * @module Scheduler/view/mixin/EventNavigation\n */\n\nconst\n    preventDefault  = e => e.preventDefault(),\n    isArrowKey = {\n        ArrowRight : 1,\n        ArrowLeft  : 1,\n        ArrowUp    : 1,\n        ArrowDown  : 1\n    },\n    animate100 = {\n        animate : 100\n    },\n    emptyObject = Object.freeze({});\n\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventNavigation extends Delayable(Target || Base) {\n    static get $name() {\n        return 'EventNavigation';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * A config object to use when creating the {@link Core.helper.util.Navigator}\n             * to use to perform keyboard navigation in the timeline.\n             * @config {NavigatorConfig}\n             * @default\n             * @category Misc\n             * @internal\n             */\n            navigator : {\n                allowCtrlKey   : true,\n                scrollSilently : true,\n                keys           : {\n                    Space     : 'onEventSpaceKey',\n                    Enter     : 'onEventEnterKey',\n                    Delete    : 'onDeleteKey',\n                    Backspace : 'onDeleteKey',\n                    ArrowUp   : 'onArrowUpKey',\n                    ArrowDown : 'onArrowDownKey',\n                    Escape    : 'onEscapeKey',\n\n                    // These are processed by GridNavigation's handlers\n                    Tab         : 'onTab',\n                    'SHIFT+Tab' : 'onShiftTab'\n                }\n            },\n\n            isNavigationKey : {\n                ArrowDown  : 1,\n                ArrowUp    : 1,\n                ArrowLeft  : 1,\n                ArrowRight : 1\n            }\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS class name to add to focused events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            focusCls : 'b-active',\n\n            /**\n             * Allow using [Delete] and [Backspace] to remove events/assignments\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            enableDeleteKey : true,\n\n            // Number in milliseconds to buffer handlers execution. See `Delayable.throttle` function docs.\n            onDeleteKeyBuffer      : 500,\n            navigatePreviousBuffer : 200,\n            navigateNextBuffer     : 200,\n\n            testConfig : {\n                onDeleteKeyBuffer : 1\n            }\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired when a user gesture causes the active item to change.\n     * @event navigate\n     * @param {Event} event The browser event which instigated navigation. May be a click or key or focus event.\n     * @param {HTMLElement|null} item The newly active item, or `null` if focus moved out.\n     * @param {HTMLElement|null} oldItem The previously active item, or `null` if focus is moving in.\n     */\n\n    //endregion\n\n    construct(config) {\n        const me = this;\n\n        me.isInTimeAxis = me.isInTimeAxis.bind(me);\n        me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me);\n\n        super.construct(config);\n    }\n\n    changeNavigator(navigator) {\n        const me = this;\n\n        me.getConfig('subGridConfigs');\n\n        return new Navigator(me.constructor.mergeConfigs({\n            ownerCmp         : me,\n            target           : me.timeAxisSubGridElement,\n            processEvent     : me.processEvent,\n            itemSelector     : `.${me.eventCls}-wrap`,\n            focusCls         : me.focusCls,\n            navigatePrevious : me.throttle(me.navigatePrevious, { delay : me.navigatePreviousBuffer, throttled : preventDefault }),\n            navigateNext     : me.throttle(me.navigateNext, { delay : me.navigateNextBuffer, throttled : preventDefault })\n        }, navigator));\n    }\n\n    doDestroy() {\n        this.navigator.destroy();\n        super.doDestroy();\n    }\n\n    isInTimeAxis(record) {\n        // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta\n        // We still need to check if time span is included in axis\n        return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);\n    }\n\n    onElementKeyDown(keyEvent) {\n        const\n            me              = this,\n            { navigator }   = me;\n\n        // If we're focused in the time axis, and *not* on an event, then ENTER means\n        // jump down into the first visible assignment in the cell.\n        if (me.focusedCell?.rowIndex !== -1 && me.focusedCell?.column === me.timeAxisColumn && !keyEvent.target.closest(navigator.itemSelector) && keyEvent.key === 'Enter') {\n            const firstAssignment = me.getFirstVisibleAssignment();\n            if (firstAssignment) {\n                me.navigateTo(firstAssignment, {\n                    uiEvent : keyEvent\n                });\n                return false;\n            }\n        }\n        else {\n            super.onElementKeyDown?.(keyEvent);\n        }\n    }\n\n    getFirstVisibleAssignment(location = this.focusedCell) {\n        const\n            me = this,\n            {\n                currentOrientation,\n                rowManager,\n                eventStore\n            } = me;\n\n        if (me.isHorizontal) {\n            let renderedEvents = currentOrientation.rowMap.get(rowManager.getRow(location.rowIndex));\n\n            if (renderedEvents?.length) {\n                return renderedEvents[0]?.elementData.assignmentRecord;\n            }\n            else {\n                renderedEvents = currentOrientation.resourceMap.get(location.id)?.eventsData;\n                if (renderedEvents?.length) {\n                    // When events are gathered from resource, we need to check they're available\n                    return renderedEvents.filter(e => eventStore.isAvailable(e.eventRecord))[0]?.assignmentRecord;\n                }\n            }\n        }\n        else {\n            const\n                firstResource = [...currentOrientation.resourceMap.values()][0],\n                renderedEvents = firstResource && Object.values(firstResource);\n\n            if (renderedEvents?.length) {\n                return renderedEvents.filter(e => eventStore.isAvailable(e.renderData.eventRecord))[0].renderData.assignmentRecord;\n            }\n        }\n    }\n\n    onGridBodyFocusIn(focusEvent) {\n        const isGridCellFocus = focusEvent.target.closest(this.focusableSelector);\n\n        // Event navigation only has a say when navigation is inside the TimeAxisSubGrid\n        if (this.timeAxisSubGridElement.contains(focusEvent.target)) {\n            const\n                me                  = this,\n                { navigationEvent } = me,\n                { target }          = focusEvent,\n                eventFocus          = target.closest(me.navigator.itemSelector),\n                destinationCell     = eventFocus ? me.normalizeCellContext({\n                    rowIndex : me.isVertical ? 0\n                        : me.resourceStore.indexOf(me.resolveResourceRecord(target)),\n                    column : me.timeAxisColumn,\n                    target\n                }) : new Location(target);\n\n            // Don't take over what the event navigator does if it's doing event navigation.\n            // Just silently cache our actionable location.\n            if (eventFocus) {\n                const { _focusedCell } = me;\n\n                me._focusedCell = destinationCell;\n                me.onCellNavigate?.(me, _focusedCell, destinationCell, navigationEvent, true);\n                return;\n            }\n\n            // Depending on how we got here, try to focus the first event in the cell *if we're in a cell*.\n            if (isGridCellFocus && (!navigationEvent || isArrowKey[navigationEvent.key])) {\n                const firstAssignment = me.getFirstVisibleAssignment(destinationCell);\n                if (firstAssignment) {\n                    me.navigateTo(firstAssignment, {\n                        // Only change scroll if focus came from key press\n                        scrollIntoView : Boolean(navigationEvent && navigationEvent.type !== 'mousedown'),\n                        uiEvent        : navigationEvent || focusEvent\n                    });\n                    return;\n                }\n            }\n        }\n\n        // Grid-level focus movement, let superclass handle it.\n        if (isGridCellFocus) {\n            super.onGridBodyFocusIn(focusEvent);\n        }\n    }\n\n    /*\n     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.\n     * Not needed until we implement full keyboard accessibility.\n     */\n    accessibleFocusCell(cellSelector, options) {\n        const me                     = this;\n\n        cellSelector = me.normalizeCellContext(cellSelector);\n\n        if (cellSelector.columnId === me.timeAxisColumn.id) {\n            // const lastFocusedCell        = me.lastFocusedCell = me._focusedCell,\n            //     lastFocusedCellElement = lastFocusedCell && me.getCell(lastFocusedCell),\n            //     newCell = me.getCell(cellSelector),\n            //     // Flag if the lastFocusedCellElement is DOCUMENT_POSITION_FOLLOWING newCell\n            //     backwards = !!(lastFocusedCellElement && (newCell.compareDocumentPosition(lastFocusedCellElement) & 4));\n\n            // // Navigating into the Scheduler, need to enable this back (for situations where we know focus was requested as a result of a keyboard input)...\n            // let newEvent = me.getRecordFromElement(newCell);\n\n            // me._focusedCell = cellSelector;\n\n            // // Scheduler where row is a Resource which might have many events\n            // // TODO: https://app.assembla.com/spaces/bryntum/tickets/6526 this class should\n            // // not know about Gantt.\n            // if (!newEvent.isTask) {\n            //     const resourceEvents = newEvent.getEvents().filter(me.isInTimeAxis).sort(sortByStartDate);\n            //     newEvent = resourceEvents[backwards ? resourceEvents.length - 1 : 0];\n            // }\n\n            // options.event.eventRecord = newEvent;\n\n            // if (newEvent && me.activeEvent !== newEvent) {\n            //     lastFocusedCellElement && lastFocusedCellElement.classList.remove('b-focused');\n            //     me.scrollResourceEventIntoView(me.store.getById(cellSelector.id), newEvent, {\n            //         animate : 100\n            //     }).then(() => {\n            //         me.activeEvent = newEvent;\n            //     });\n            // }\n        }\n        else {\n            return super.focusCell(cellSelector, options);\n        }\n    }\n\n    // Interface method to extract the navigated to record from a populated 'navigate' event.\n    // Gantt, Scheduler and Calendar handle event differently, adding different properties to it.\n    // This method is meant to be overridden to return correct target from event\n    normalizeTarget(event) {\n        return event.assignmentRecord;\n    }\n\n    getPrevious(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n\n        let resourceRecord = assignmentRecord.resource,\n            previousEvent  = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];\n\n        // At first event for resource, traverse up the resource store.\n        if (!previousEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (\n                let rowIdx = resourceStore.indexOf(resourceRecord) - 1;\n                (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0;\n                rowIdx--\n            ) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n\n                previousEvent = events.length && events[events.length - 1];\n            }\n        }\n\n        return me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord);\n    }\n\n    navigatePrevious(keyEvent) {\n        const\n            me                 = this,\n            previousAssignment = me.getPrevious(me.normalizeTarget(keyEvent));\n\n        keyEvent.preventDefault();\n        if (previousAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(previousAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n\n        // No previous event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n\n    getNext(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    // start/end are required to limit time\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n\n        let resourceRecord = assignmentRecord.resource,\n            nextEvent      = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];\n\n        // At last event for resource, traverse down the resource store\n        if (!nextEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count; rowIdx++) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n\n                nextEvent = events[0];\n            }\n        }\n\n        return me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord);\n    }\n\n    navigateNext(keyEvent) {\n        const\n            me             = this,\n            nextAssignment = me.getNext(me.normalizeTarget(keyEvent));\n\n        keyEvent.preventDefault();\n        if (nextAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(nextAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n\n        // No next event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n\n    doGridNavigation(keyEvent) {\n        if (!keyEvent.handled && keyEvent.key.indexOf('Arrow') === 0) {\n            this[`navigate${keyEvent.key.substring(5)}ByKey`](keyEvent);\n        }\n    }\n\n    async navigateTo(targetAssignment, {\n        scrollIntoView = true,\n        uiEvent        = {}\n    } = emptyObject) {\n        const\n            me                      = this,\n            { navigator }           = me,\n            { skipScrollIntoView }  = navigator;\n\n        if (targetAssignment) {\n            if (scrollIntoView) {\n                // No key processing during scroll\n                navigator.disabled = true;\n                await me.scrollAssignmentIntoView(targetAssignment, animate100);\n                navigator.disabled = false;\n            }\n            else {\n                navigator.skipScrollIntoView = true;\n            }\n\n            // Panel can be destroyed before promise is resolved\n            // Perform a sanity check to make sure element is still in the DOM (syncIdMap actually).\n            if (!me.isDestroyed && this.getElementFromAssignmentRecord(targetAssignment)) {\n                me.activeAssignment = targetAssignment;\n                navigator.skipScrollIntoView = skipScrollIntoView;\n                navigator.trigger('navigate', {\n                    event : uiEvent,\n                    item  : me.getElementFromAssignmentRecord(targetAssignment).closest(navigator.itemSelector)\n                });\n            }\n        }\n    }\n\n    set activeAssignment(assignmentRecord) {\n        const assignmentEl = this.getElementFromAssignmentRecord(assignmentRecord, true);\n\n        if (assignmentEl) {\n            this.navigator.activeItem = assignmentEl;\n        }\n    }\n\n    get activeAssignment() {\n        const { activeItem } = this.navigator;\n\n        if (activeItem) {\n            return this.resolveAssignmentRecord(activeItem);\n        }\n    }\n\n    get previousActiveEvent() {\n        const { previousActiveItem } = this.navigator;\n\n        if (previousActiveItem) {\n            return this.resolveEventRecord(previousActiveItem);\n        }\n    }\n\n    processEvent(keyEvent) {\n        const\n            me           = this,\n            eventElement = keyEvent.target.closest(me.eventSelector);\n\n        if (!me.navigator.disabled && eventElement) {\n            keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);\n            keyEvent.eventRecord = me.resolveEventRecord(eventElement);\n            keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);\n        }\n\n        return keyEvent;\n    }\n\n    onDeleteKey(keyEvent) {\n        const me = this;\n        if (!me.readOnly && me.enableDeleteKey) {\n            const records = me.eventStore.usesSingleAssignment ? me.selectedEvents : me.selectedAssignments;\n\n            me.removeEvents(records.filter(r => !r.readOnly));\n        }\n    }\n\n    onArrowUpKey(keyEvent) {\n        this.focusCell({\n            rowIndex : this.focusedCell.rowIndex - 1,\n            column   : this.timeAxisColumn\n        });\n        keyEvent.handled = true;\n    }\n\n    onArrowDownKey(keyEvent) {\n        if (this.focusedCell.rowIndex < this.resourceStore.count - 1) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex + 1,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n\n    onEscapeKey(keyEvent) {\n        if (!keyEvent.target.closest('.b-dragging')) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n\n    onEventSpaceKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n\n    onEventEnterKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n\n    get isActionableLocation() {\n        // Override from grid if the Navigator's location is an event (or task if we're in Gantt)\n        // Being focused on a task/event means that it's *not* actionable. It's not valid to report\n        // that we're \"inside\" the cell in a TimeLine, so ESC must not attempt to focus the cell.\n        if (!this.navigator.activeItem) {\n            return super.isActionableLocation;\n        }\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n"],"names":["LocaleHelper","publishLocale","localeName","localeDesc","localeCode","Object","newEvent","ResourceInfoColumn","eventCountText","data","Dependencies","from","to","valid","invalid","DependencyType","SS","SF","FS","FF","StartToStart","StartToEnd","EndToStart","EndToEnd","short","long","DependencyEdit","From","To","Type","Lag","Save","Delete","Cancel","EventEdit","Name","Resource","Start","End","Repeat","EventDrag","eventOverlapsExisting","noDropOutsideTimeline","SchedulerBase","TimeAxisHeaderMenu","pickZoomLevel","activeDateRange","startText","endText","todayText","EventCopyPaste","copyEvent","cutEvent","pasteEvent","EventFilter","filterEvents","byName","TimeRanges","showCurrentTimeLine","PresetManager","secondAndMinute","displayDateFormat","name","minuteAndHour","topDateFormat","hourAndDay","middleDateFormat","day","week","dayAndWeek","dayAndMonth","weekAndDay","weekAndMonth","weekAndDayLetter","weekDateAndMonth","monthAndYear","year","manyYears","RecurrenceConfirmationPopup","Yes","width","RecurrenceLegend","Daily","Weekly on {1}","days","Monthly on {1}","Yearly on {1} of {2}","months","Every {0} days","interval","Every {0} weeks on {1}","Every {0} months on {1}","Every {0} years on {1} of {2}","position1","position2","position3","position4","position5","weekday","daysFormat","position","RecurrenceEditor","Frequency","Every","DAILYintervalUnit","WEEKLYintervalUnit","MONTHLYintervalUnit","YEARLYintervalUnit","Each","RecurrenceDaysCombo","RecurrencePositionsCombo","RecurrenceStopConditionCombo","Never","After","RecurrenceFrequencyCombo","None","Weekly","Monthly","Yearly","RecurrenceCombo","Custom","Summary","date","ScheduleRangeCombo","completeview","currentview","daterange","completedata","SchedulerExportDialog","ExcelExporter","CrudManagerView","serverResponseLabel","DurationColumn","Duration","Target","$name","afterConstruct","super","me","this","projectHolder","client","grid","project","projectSubscribers","push","attachToProject","attachToResourceStore","resourceStore","attachToEventStore","eventStore","attachToAssignmentStore","assignmentStore","attachToDependencyStore","dependencyStore","attachToCalendarManagerStore","calendarManagerStore","detachListeners","_project","store","engineStoreNames","Base","declarable","configurable","projectModelClass","ProjectModel","destroyStores","startConfigure","config","getConfig","changeProject","oldProject","projectStoreNames","projectDataNames","constructor","projectCallbacks","Set","buildingProjectConfig","isModel","isConfiguring","crudManager","isCrudManager","storeName","dataName","_sharedProject","sharedProject","isEventStoreMixin","autoLoad","count","delayAutoLoad","some","chain","updateProject","projectListeners","_crudManager","thisObj","ion","forEach","subscriber","load","trigger","changeCrudManager","assign","onProjectDataReady","whenVisible","size","callback","clear","onTimeZoneChange","timeZone","oldTimeZone","startDate","TimeZoneHelper","fromTimeZone","toTimeZone","whenProjectReady","isEngineReady","add","_this$project$isEngin","_this$project","Boolean","call","doDestroy","isDestroyed","destroy","projectStores","map","keys","reduce","result","setupProjectStores","cls","meta","dataReady","change","timeZoneChange","storeConfigs","previousDataName","defineProperty","class","prototype","get","_this$project$storeNa","records","createDataUpdater","createStoreDescriptor","setupConfigs","StringHelper","capitalize","listeners","clsProto","storeNameCap","oldStore","_store","storeProject","isProjectModel","initializingProject","_subscriber","relayProjectDataChange","event","_objectSpread","source","widgetClass","ClockTemplate","defaultConfig","minuteHeight","minuteTop","hourHeight","hourTop","handLeft","div","document","createElement","scheduler","template","mode","DateHelper","format","encodeHtml","text","generateContent","innerHTML","updateDateIndicator","el","hourIndicatorEl","querySelector","minuteIndicatorEl","BrowserHelper","isBrowserEnv","style","transform","getHours","getMinutes","_mode","unitLessThanDay","compareUnits","timeAxisViewModel","timeResolution","unit","formatContainsHourInfo","_template","_$name","TimeSpanMenuBase","ContextMenuBase","Popup","type","localizableProperties","align","autoShow","autoClose","closeAction","modal","centered","scrollAction","constrainTo","globalThis","draggable","closable","floating","eventRecord","bbar","defaults","localeClass","items","changeSingleButton","weight","color","onClick","changeMultipleButton","cancelButton","widgetMap","onChangeMultipleButtonClick","processMultipleRecords","hide","onChangeSingleButtonClick","processSingleRecord","onCancelButtonClick","cancelFn","onRecurrenceClose","confirm","prop","updatePopupContent","show","actionType","isRecurring","L","html","title","changerFn","finalizerFn","beginBatch","endBatch","_firstOccurrence","firstOccurrence","recurrence","forEachOccurrence","occurrence","isFirst","index","convertToRealEvent","recurrenceRule","updateLocalization","initClass","Combo","buildItems","addNone","value","_defineProperty","editable","displayField","valueField","localizeDisplayFields","allDaysValueAsArray","allDaysValue","join","defaultValue","workingDaysValue","filter","nonWorkingDays","nonWorkingDaysValue","splitCls","_weekDays","weekDays","concat","weekStartDay","dayNames","getDayNames","RecurrenceDayRuleEncoder","encodeDay","slice","Array","isArray","findRecord","RecurrenceDaysButtonGroup","ButtonGroup","toggleable","construct","columns","updateItemText","item","decodeDay","getDayName","substring","__items","onLocaleChange","widgetClassList","classList","RecurrenceMonthDaysButtonGroup","minValue","maxValue","RecurrenceMonthsButtonGroup","getMonthNames","getMonthName","placeholder","_recurrence","endDate","maxPosition","buildDayNumbers","ArrayHelper","populate","i","split","parseInt","RecurrenceEditorPanel","Panel","updateRecord","record","frequencyField","daysButtonField","monthDaysButtonField","monthsButtonField","monthDaysRadioField","positionAndDayRadioField","stopRecurrenceField","timeSpan","length","getDay","monthDays","getDate","getMonth","positions","check","isPainted","uncheck","syncEventRecord","values","getValues","w","disabled","set","toggleStopFields","countField","endDateField","enable","disable","onMonthDaysRadioFieldChange","checked","isWidgetAvailableForFrequency","onPositionAndDayRadioFieldChange","daysCombo","positionsCombo","onStopRecurrenceFieldChange","widget","frequency","forFrequency","includes","onFrequencyFieldChange","oldValue","queryAll","intervalField","hidden","hint","toggleFieldsState","label","onChange","min","required","toggleGroup","flex","EventMenu","processItems","pluginConfig","isHorizontal","getDataFromEvent","_ref","eventElement","targetElement","resolveEventRecord","resourceRecord","resolveResourceRecord","last","$original","assignmentRecord","resolveAssignmentRecord","getTargetElementFromEvent","target","closest","eventSelector","shouldShowMenu","eventParams","showContextMenuFor","getElementFromRecord","DomHelper","triggerMouseEvent","tiggerEvent","getElementsFromEventRecord","populateEventMenu","deleteEvent","readOnly","unassignEvent","usesSingleAssignment","changeItems","Objects","merge","icon","onItem","menu","_menu$focusInEvent","revertTarget","focusInEvent","relatedTarget","focus","navigator","activeItem","removeEvents","isEventSelected","selectedEvents","_menu$focusInEvent2","unassign","featureClass","GridFeatureManager","registerFeature","ScheduleMenu","isTimeAxisColumn","timeAxisSubGridElement","contains","isSpecialRow","isDOMEvent","_client$getCellDataFr","_client$getDateFromDo","cellData","getCellDataFromEvent","getDateFromDomEvent","isVertical","ObjectHelper","populateScheduleMenu","addEvent","isWorkingTime","createEvent","getRowFor","_class","beforeEventDropFinalize","beforeEventResizeFinalize","beforeAssignmentDelete","changeRecurrenceConfirmationPopup","recurrenceConfirmationPopup","oldRecurrenceConfirmationPopup","reconfigure","owner","findRecurringEventToConfirmDelete","eventRecords","find","supportsRecurring","isOccurrence","onRecurrableAssignmentBeforeDelete","assignmentRecords","context","as","enableRecurringEvents","finalize","onRecurrableBeforeEventDropFinalize","recurringEvents","async","onRecurrableBeforeEventResizeFinalize","onAssignmentChange","action","assignments","assignment","_assignment$event","isBatchUpdating","removeOccurrences","getOccurrencesFor","recurringEvent","getOccurrencesForTimeSpan","timeAxis","popupOwner","removeRecord","_record$event","isOccurrenceAssignment","remove","isAssignment","shouldFinalize","recurringEventRecord","$config","stores","inlineProperties","preProcessCurrentConfigs","configs","getCurrentConfig","options","preventDefault","e","isArrowKey","ArrowRight","ArrowLeft","ArrowUp","ArrowDown","animate100","animate","emptyObject","freeze","Delayable","allowCtrlKey","scrollSilently","Space","Enter","Backspace","Escape","Tab","isNavigationKey","focusCls","enableDeleteKey","onDeleteKeyBuffer","navigatePreviousBuffer","navigateNextBuffer","testConfig","isInTimeAxis","bind","onDeleteKey","throttle","changeNavigator","Navigator","mergeConfigs","ownerCmp","processEvent","itemSelector","eventCls","navigatePrevious","delay","throttled","navigateNext","instanceMeta","excluded","isTimeSpanInAxis","onElementKeyDown","keyEvent","_me$focusedCell","_me$focusedCell2","focusedCell","rowIndex","column","timeAxisColumn","key","_super$onElementKeyDo","firstAssignment","getFirstVisibleAssignment","navigateTo","uiEvent","location","currentOrientation","rowManager","_renderedEvents","renderedEvents","rowMap","getRow","_renderedEvents$","_currentOrientation$r","_renderedEvents2","_renderedEvents$filte","elementData","resourceMap","id","eventsData","isAvailable","firstResource","renderData","onGridBodyFocusIn","focusEvent","isGridCellFocus","focusableSelector","navigationEvent","eventFocus","destinationCell","normalizeCellContext","indexOf","Location","_me$onCellNavigate","_focusedCell","onCellNavigate","scrollIntoView","accessibleFocusCell","cellSelector","columnId","focusCell","normalizeTarget","getPrevious","isDelete","eventSorter","resourceEvents","getEvents","resource","sort","previousEvent","rowIdx","getAt","events","getAssignmentForEventAndResource","previousAssignment","ctrlKey","clearEventSelection","doGridNavigation","getNext","nextEvent","nextAssignment","handled","targetAssignment","skipScrollIntoView","scrollAssignmentIntoView","getElementFromAssignmentRecord","activeAssignment","assignmentEl","previousActiveEvent","previousActiveItem","selectedAssignments","r","onArrowUpKey","onArrowDownKey","onEscapeKey","onEventSpaceKey","onEventEnterKey","isActionableLocation"],"mappings":"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"}