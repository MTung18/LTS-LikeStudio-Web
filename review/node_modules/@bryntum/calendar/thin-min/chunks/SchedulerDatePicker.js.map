{"version":3,"file":"SchedulerDatePicker.js","sources":["../../../../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceLegend.js","../../../../Scheduler/lib/Scheduler/feature/base/EditBase.js","../../../../Scheduler/lib/Scheduler/view/EventEditor.js","../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceCombo.js","../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceLegendButton.js","../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditor.js","../../../../Scheduler/lib/Scheduler/feature/mixin/RecurringEventEdit.js","../../../../Scheduler/lib/Scheduler/widget/ResourceCombo.js","../../../../Scheduler/lib/Scheduler/feature/EventEdit.js","../../../../Scheduler/lib/Scheduler/widget/ResourceFilter.js","../../../../Scheduler/lib/Scheduler/widget/SchedulerDatePicker.js"],"sourcesContent":["import Localizable from '../../../../Core/localization/Localizable.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n\n/**\n * @module Scheduler/data/util/recurrence/RecurrenceLegend\n */\n\n/**\n * A static class allowing to get a human readable description of the provided recurrence.\n *\n * ```javascript\n * const event = new EventModel({ startDate : new Date(2018, 6, 3), endDate : new Date(2018, 6, 4) });\n * const recurrence = new RecurrenceModel({ frequency : 'WEEKLY', days : ['MO', 'TU', 'WE'] });\n * event.recurrence = recurrence;\n * // \"Weekly on  Mon, Tue and Wed\"\n * RecurrenceLegend.getLegend(recurrence);\n * ```\n * @mixes Core/localization/Localizable\n */\nexport default class RecurrenceLegend extends Localizable() {\n\n    static get $name() {\n        return 'RecurrenceLegend';\n    }\n\n    static get allDaysValueAsArray() {\n        return ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n    }\n\n    static get allDaysValue() {\n        return this.allDaysValueAsArray.join(',');\n    }\n\n    static get workingDaysValue() {\n        return this.allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(',');\n    }\n\n    static get nonWorkingDaysValue() {\n        return this.allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(',');\n    }\n\n    /**\n     * Returns the provided recurrence description. The recurrence might be assigned to a timespan model,\n     * in this case the timespan start date should be provided in the second argument.\n     * @param {Scheduler.model.RecurrenceModel} recurrenceRecurrence model.\n     * @param {Date} [timeSpanStartDate] The recurring timespan start date. Can be omitted if the recurrence is assigned\n     * to a timespan model (and the timespan has {@link Scheduler.model.TimeSpan#field-startDate} filled). Then start\n     * date will be retrieved from the model.\n     * @returns {String} The recurrence description.\n     */\n    static getLegend(recurrence, timeSpanStartDate) {\n        const\n            me                                                         = this,\n            { timeSpan, interval, days, monthDays, months, positions } = recurrence,\n            startDate                                                  = timeSpanStartDate || timeSpan.startDate,\n            tplData                                                    = { interval };\n\n        let fn;\n\n        switch (recurrence.frequency) {\n            case 'DAILY':\n                return interval === 1 ? me.L('L{Daily}') : me.L('L{Every {0} days}', tplData);\n\n            case 'WEEKLY':\n                if (days && days.length) {\n                    tplData.days = me.getDaysLegend(days);\n                }\n                else if (startDate) {\n                    tplData.days = DateHelper.getDayName(startDate.getDay());\n                }\n\n                return me.L(interval === 1 ? 'L{Weekly on {1}}' : 'L{Every {0} weeks on {1}}', tplData);\n\n            case 'MONTHLY':\n                if (days && days.length && positions && positions.length) {\n                    tplData.days = me.getDaysLegend(days, positions);\n                }\n                else if (monthDays && monthDays.length) {\n                    // sort dates to output in a proper order\n                    monthDays.sort((a, b) => a - b);\n\n                    tplData.days = me.arrayToText(monthDays);\n                }\n                else if (startDate) {\n                    tplData.days = startDate.getDate();\n                }\n\n                return me.L(interval === 1 ? 'L{Monthly on {1}}' : 'L{Every {0} months on {1}}', tplData);\n\n            case 'YEARLY':\n\n                if (days && days.length && positions && positions.length) {\n                    tplData.days = me.getDaysLegend(days, positions);\n                }\n                else {\n                    tplData.days = startDate.getDate();\n                }\n\n                if (months && months.length) {\n                    // sort months to output in a proper order\n                    months.sort((a, b) => a - b);\n\n                    if (months.length > 2) {\n                        fn = month => DateHelper.getMonthShortName(month - 1);\n                    }\n                    else {\n                        fn = month => DateHelper.getMonthName(month - 1);\n                    }\n\n                    tplData.months = me.arrayToText(months, fn);\n                }\n                else {\n                    tplData.months = DateHelper.getMonthName(startDate.getMonth());\n                }\n\n                return me.L(interval === 1 ? 'L{Yearly on {1} of {2}}' : 'L{Every {0} years on {1} of {2}}', tplData);\n        }\n    }\n\n    static getDaysLegend(days, positions) {\n        const\n            me      = this,\n            tplData = { position : '' };\n        let fn;\n\n        if (positions && positions.length) {\n            // Do not remove. Assertion strings for Localization sanity check.\n            // 'L{position1}'\n            // 'L{position2}'\n            // 'L{position3}'\n            // 'L{position4}'\n            // 'L{position5}'\n            // 'L{position-1}'\n            tplData.position = me.arrayToText(positions, position => me.L(`L{position${position}}`));\n        }\n\n        if (days.length) {\n            days.sort((a, b) => DayRuleEncoder.decodeDay(a)[0] - DayRuleEncoder.decodeDay(b)[0]);\n\n            switch (days.join(',')) {\n                case me.allDaysValue :\n                    tplData.days = me.L('L{day}');\n                    break;\n\n                case me.workingDaysValue :\n                    tplData.days = me.L('L{weekday}');\n                    break;\n\n                case me.nonWorkingDaysValue :\n                    tplData.days = me.L('L{weekend day}');\n                    break;\n\n                default :\n                    if (days.length > 2) {\n                        fn = day => DateHelper.getDayShortName(DayRuleEncoder.decodeDay(day)[0]);\n                    }\n                    else {\n                        fn = day => DateHelper.getDayName(DayRuleEncoder.decodeDay(day)[0]);\n                    }\n\n                    tplData.days = me.arrayToText(days, fn);\n            }\n        }\n\n        return me.L('L{daysFormat}', tplData);\n    }\n\n    // Converts array of items to a human readable list.\n    // For example: [1,2,3,4]\n    // to: \"1, 2, 3 and 4\"\n    static arrayToText(array, fn) {\n        if (fn) {\n            array = array.map(fn);\n        }\n\n        return array.join(', ').replace(/,(?=[^,]*$)/, this.L('L{ and }'));\n    }\n\n}\n","import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateField from '../../../Core/widget/DateField.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Config from '../../../Core/Config.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n\n/**\n * @module Scheduler/feature/base/EditBase\n */\n\nconst\n    DH             = DateHelper,\n    scheduleFields = ['startDate', 'endDate', 'resource', 'recurrenceRule'],\n    makeDate       = (fields) => {\n        // single field, update record directly\n        if (fields.length === 1) return fields[0].value;\n        // two fields, date + time\n        else if (fields.length === 2) {\n            const\n                [date, time] = fields[0] instanceof DateField ? fields : fields.reverse(),\n                dateValue    = DH.parse(date.value);\n\n            if (dateValue && time.value) {\n                dateValue.setHours(\n                    time.value.getHours(),\n                    time.value.getMinutes(),\n                    time.value.getSeconds(),\n                    time.value.getMilliseconds()\n                );\n            }\n\n            // Clone to not end up sharing dates\n            return dateValue ? DateHelper.clone(dateValue) : null;\n        }\n        // shouldn't happen...\n        return null;\n    },\n    copyTime       = (dateTo, dateFrom) => {\n        const d = new Date(dateTo.getTime());\n        d.setHours(dateFrom.getHours(), dateFrom.getMinutes());\n        return d;\n    },\n    adjustEndDate  = (startDate, startTime, me) => {\n        // The end datetime just moves in response to the changed start datetime, keeping the same duration.\n        if (startDate && startTime && me.endDateField && me.endTimeField) {\n            const newEndDate = DH.add(copyTime(me.startDateField.value, me.startTimeField.value), me.eventRecord.durationMS, 'milliseconds');\n            me.endDateField.value = newEndDate;\n            me.endTimeField.value = DH.clone(newEndDate);\n        }\n    };\n\n/**\n * Base class for EventEdit. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n */\nexport default class EditBase extends InstancePlugin {\n    //region Config\n\n    static get configurable() {\n        return {\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n\n            triggerEvent : null,\n\n            /**\n             * This config parameter is passed to the `startDateField` and `endDateField` constructor.\n             * @config {String}\n             * @default\n             * @category Editor widgets\n             */\n            dateFormat : 'L', // date format that uses browser locale\n\n            /**\n             * This config parameter is passed to the `startTimeField` and `endTimeField` constructor.\n             * @config {String}\n             * @default\n             * @category Editor widgets\n             */\n            timeFormat : 'LT', // date format that uses browser locale\n\n            /**\n             * Default editor configuration, which widgets it shows etc.\n             *\n             * This is the entry point into configuring any aspect of the editor.\n             *\n             * The {@link Core.widget.Container#config-items} configuration of a Container\n             * is *deeply merged* with its default `items` value. This means that you can specify\n             * an `editorConfig` object which configures the editor, or widgets inside the editor:\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 autoClose : false,\n             *                 modal     : true,\n             *                 cls       : 'editor-widget-cls',\n             *                 items : {\n             *                     resourceField : {\n             *                         hidden : true\n             *                     },\n             *                     // Add our own event owner field at the top of the form.\n             *                     // Weight -100 will make it sort top the top.\n             *                     ownerField : {\n             *                         weight : -100,\n             *                         type   : 'usercombo',\n             *                         name   : 'owner',\n             *                         label  : 'Owner'\n             *                     }\n             *                 },\n             *                 bbar : {\n             *                     items : {\n             *                         deleteButton : false\n             *                     }\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : null,\n\n            /**\n             * An object to merge with the provided items config of the editor to override the\n             * configuration of provided fields, or add new fields.\n             *\n             * To remove existing items, set corresponding keys to `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             items : {\n             *                 // Merged with provided config of the resource field\n             *                 resourceField : {\n             *                     label : 'Calendar'\n             *                 },\n             *                 recurrenceCombo : null,\n             *                 owner : {\n             *                     weight : -100, // Will sort above system-supplied fields which are weight 0\n             *                     type   : 'usercombo',\n             *                     name   : 'owner',\n             *                     label  : 'Owner'\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             *```\n             *\n             * The provided fields are called\n             *  - `nameField`\n             *  - `resourceField`\n             *  - `startDateField`\n             *  - `startTimeField`\n             *  - `endDateField`\n             *  - `endTimeField`\n             *  - `recurrenceCombo`\n             *  - `editRecurrenceButton`\n             * @config {Object<String,ContainerItemConfig|Boolean|null>}\n             * @category Editor widgets\n             */\n            items : null,\n\n            /**\n             * The week start day used in all date fields of the feature editor form by default.\n             * 0 means Sunday, 6 means Saturday.\n             * Defaults to the locale's week start day.\n             * @config {Number}\n             */\n            weekStartDay : null\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        client.eventEdit = me;\n\n        super.construct(client, ObjectHelper.assign({\n            weekStartDay : client.weekStartDay\n        }, config));\n\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : 'onActivateEditor',\n            dragCreateEnd     : 'onDragCreateEnd',\n\n            // Not fired at the Scheduler level.\n            // Calendar, which inherits this, implements this event.\n            eventAutoCreated : 'onEventAutoCreated',\n            thisObj          : me\n        });\n    }\n\n    doDestroy() {\n        this.clientListenersDetacher();\n\n        this._editor?.destroy();\n\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Editing\n\n    // Not implemented at this level.\n    // Scheduler Editing relies on being called at point of event creation.\n    onEventAutoCreated() {}\n\n    changeEditorConfig(editorConfig) {\n        const { items } = this;\n\n        // Merge items which is an Object with the default editorConfig's items\n        if (items) {\n            editorConfig = Objects.clone(editorConfig);\n            editorConfig.items = Config.merge(items, editorConfig.items);\n        }\n\n        return editorConfig;\n    }\n\n    changeItems(items) {\n        this.cleanItemsConfig(items);\n        return items;\n    }\n\n    // Remove any items configured as === true which just means default config options\n    cleanItemsConfig(items) {\n        for (const ref in items) {\n            const itemCfg = items[ref];\n\n            if (itemCfg === true) {\n                delete items[ref];\n            }\n            else if (itemCfg?.items) {\n                this.cleanItemsConfig(itemCfg.items);\n            }\n        }\n    }\n\n    onDatesChange(params) {\n        const\n            me    = this,\n            field = params.source,\n            value = params.value;\n\n        // End date can never be less than start date\n        if (me.startDateField && me.endDateField) {\n            me.endDateField.min = me.startDateField.value;\n        }\n\n        if (me.endTimeField) {\n            // If the event starts and ends on the same day, the time fields need\n            // to have their min and max set against each other.\n            if (DH.isEqual(DH.clearTime(me.startDateField?.value), DH.clearTime(me.endDateField?.value))) {\n                me.endTimeField.min = me.startTimeField.value;\n            }\n            else {\n                me.endTimeField.min = null;\n            }\n        }\n\n        switch (field.ref) {\n            case 'startDateField':\n                me.startTimeField?.value && adjustEndDate(value, me.startTimeField.value, me);\n                break;\n\n            case 'startTimeField':\n                me.startDateField?.value && adjustEndDate(me.startDateField.value, value, me);\n                break;\n        }\n    }\n\n    //endregion\n\n    //region Save\n\n    async save() {\n        throw new Error('Implement in subclass');\n    }\n\n    get values() {\n        const\n            me          = this,\n            { editor }  = me,\n            startFields = [],\n            endFields   = [],\n            { values }  = editor;\n\n        // The standard values getter will produce (almost) what we want, however, there are some special fields that\n        // we need to take over. Remove those fields:\n        scheduleFields.forEach(f => delete values[f]);\n\n        editor.eachWidget(widget => {\n            const { name } = widget;\n\n            // If the widget is part of the recurrence editor, we don't gather it.\n            if (!name || widget.hidden || widget.up(w => w === me.recurrenceEditor)) {\n                delete values[name];\n                return;\n            }\n\n            switch (name) {\n                case 'startDate':\n                    startFields.push(widget);\n                    break;\n                case 'endDate':\n                    endFields.push(widget);\n                    break;\n                case 'resource':\n                    values[name] = widget.record;\n                    break;\n                case 'recurrenceRule':\n                    // If recurrence set to null, completely clear the recurrenceRule.\n                    // Otherwise it will still be perceived as recurring with the rule 'FREQ=none'\n                    values[name] = editor.widgetMap.recurrenceCombo?.value === 'none' ? '' : widget.value;\n                    break;\n                // Ignore other widgets and allow the standard values getter to provide them:\n                // default:\n                //     values[name] = widget.value;\n            }\n        }, true);\n\n        // if is changing from not allDay to allDay should consider time fields to not change them on makeDate\n        if (values.allDay && !me.eventRecord.allDay) {\n            startFields.push(me.startTimeField);\n            endFields.push(me.endTimeField);\n        }\n\n        // Handle fields being configured away\n        if (startFields.length) {\n            values.startDate = makeDate(startFields);\n        }\n        if (endFields.length) {\n            values.endDate = makeDate(endFields);\n        }\n\n        // Since there is no duration field in the editor,\n        // we don't need to recalc duration value on each date change.\n        // It's enough to return correct duration value in `values`,\n        // so the record will get updated with the correct data.\n        if (('startDate' in values) && ('endDate' in values)) {\n            values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);\n        }\n\n        return values;\n    }\n\n    /**\n     * Template method, intended to be overridden. Called before the event record has been updated.\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     *\n     **/\n    onBeforeSave(eventRecord) {}\n\n    /**\n     * Template method, intended to be overridden. Called after the event record has been updated.\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     *\n     **/\n    onAfterSave(eventRecord) {}\n\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(record) {\n        const { values } = this;\n\n        // Clean resourceId / resources out of values when using assignment store, it will handle the assignment\n        if (this.assignmentStore) {\n            delete values.resource;\n        }\n\n        return record.set(values);\n    }\n\n    //endregion\n\n    //region Events\n\n    onBeforeEditorShow() {\n        const\n            { eventRecord, editor } = this.editingContext,\n            { nameField } = editor.widgetMap;\n\n        // Editing new event. Make sure user doesn't have to clear the input field.\n        // Record field value still should be there because a rendered event block\n        // looks bad with no text in it.\n        // nameField may have been configured away.\n        if (nameField && eventRecord.isCreating) {\n            // Avoid initial invalid because required state.\n            editor.assigningValues = true;\n            nameField.value = '';\n            editor.assigningValues = false;\n\n            // Show new event text as a placeholder\n            nameField._configuredPlaceholder = nameField.placeholder;\n            nameField.placeholder = eventRecord.name;\n        }\n    }\n\n    resetEditingContext() {\n        const me = this;\n\n        if (!me.editingContext) {\n            return;\n        }\n\n        const\n            { client }              = me,\n            { editor, eventRecord } = me.editingContext,\n            { eventStore }          = client,\n            { nameField }           = editor.widgetMap;\n\n        // This will remove the record from the store, *and* from the added bag, so no sync will take place.\n        if (eventRecord.isCreating) {\n            // Ensure that during the engine's async processing of the remove, the element is non-interactive.\n            // Mousedown on the just-created element itself passes through here, and the immediate mouseup\n            // after that instigates a click which will find no corresponding event.\n            if (client.isTimelineBase) {\n                me.editingContext.eventElement?.closest('[data-event-id]').classList.add('b-released');\n            }\n\n            eventStore.remove(eventRecord);\n\n            // Clear isCreating *after* removal.\n            // Store doesn't register as a removed record if isCreating is set\n            eventRecord.isCreating = false;\n        }\n\n        // Revert any placeholder that we may have set\n        // nameField may have been configured away.\n        if (nameField) {\n            nameField.placeholder = nameField._configuredPlaceholder;\n        }\n\n        client.element.classList.remove('b-eventeditor-editing');\n\n        // Reset context\n        me.targetEventElement = me.editingContext = editor._record = null;\n    }\n\n    onPopupKeyDown({ event }) {\n        const me = this;\n\n        if (!me.readOnly && event.key === 'Enter' && me.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            // If enter key was hit in an input element of a start field, need to adjust end date fields (the same way as if #onDatesChange handler was called)\n            if (event.target.name === 'startDate') {\n                me.startTimeField && adjustEndDate(me.startDateField.value, me.startTimeField.value, me);\n            }\n\n            me.onSaveClick();\n        }\n    }\n\n    async onSaveClick() {\n        // TODO add new API on Container: blurFocusedField which manages this scenario\n        // of blurring active field just before hiding\n        this.editor.focus();\n\n        const saved = await this.save();\n\n        if (saved) {\n            this.editor.close();\n\n            /**\n             * Fires on the owning Scheduler after editor is closed by any action - save, delete or cancel\n             * @event afterEventEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             */\n            this.client.trigger('afterEventEdit');\n        }\n        return saved;\n    }\n\n    async onDeleteClick() {\n        const removed = await this.deleteEvent();\n\n        if (removed) {\n            const { editor } = this;\n            // We expect deleteEvent will trigger close if autoClose is true and focus has moved out,\n            // otherwise need to call it manually\n            if (!editor.autoClose || editor.containsFocus) {\n                editor.close();\n            }\n            this.client.trigger('afterEventEdit');\n        }\n    }\n\n    onCancelClick() {\n        this.editor.close();\n        this.client.trigger('afterEventEdit');\n    }\n\n    //endregion\n}\n","import Store from '../../Core/data/Store.js';\nimport Popup from '../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/EventEditor\n */\n\n/**\n * Provided event editor dialog.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class EventEditor extends Popup {\n    // Factoryable type name\n    static get type() {\n        return 'eventeditor';\n    }\n\n    static get $name() {\n        return 'EventEditor';\n    }\n\n    static get configurable() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // Ignore buttons and field inners\n            },\n            axisLock : 'flexible',\n\n            scrollable : {\n                // In case editor is very tall or window is small, make it scrollable\n                overflowY : true\n            },\n            readOnly : null,\n\n            /**\n             * A Function (or *name* of a function) which produces a customized Panel header based upon the event being edited.\n             * @config {Function|String}\n             * @param {Scheduler.model.EventModel} eventRecord The record being edited\n             * @returns {String} The Panel title.\n             */\n            titleRenderer : null\n        };\n    }\n\n    updateLocalization() {\n        super.updateLocalization(...arguments);\n\n        // Use this if there's no titleRenderer\n        this.initialTitle = this.title || '';\n    }\n\n    chainResourceStore() {\n        return this.eventEditFeature.resourceStore.chain(\n            record => !record.isSpecialRow,\n            null,\n            {\n                // It doesn't need to be a Project-based Store\n                storeClass              : Store,\n                // Need to show all records in the combo. Required in case resource store is a tree.\n                excludeCollapsedRecords : false\n            }\n        );\n    }\n\n    processWidgetConfig(widget) {\n        if (widget.type?.includes('date') && widget.weekStartDay == null) {\n            widget.weekStartDay = this.weekStartDay;\n        }\n\n        if (widget.type === 'extraItems') {\n            return false;\n        }\n\n        const\n            { eventEditFeature } = this,\n            fieldConfig          = {};\n\n        if (widget.ref === 'resourceField') {\n            const { store } = widget;\n\n            // Can't use store directly since it may be grouped and then contains irrelevant group records\n            widget.store = this.chainResourceStore();\n\n            // Allow the incoming widget's config to augment its store\n            if (store) {\n                widget.store.setConfig(store);\n            }\n\n            // When events are loaded with resourceId, we should only support single select.\n            // Only override this if the widget has not been explicitly configured\n            // with multiSelect.\n            if (!('multiSelect' in widget)) {\n                widget.multiSelect = !eventEditFeature.eventStore.usesSingleAssignment;\n            }\n        }\n\n        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'date') {\n            fieldConfig.format = eventEditFeature.dateFormat;\n        }\n\n        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'time') {\n            fieldConfig.format = eventEditFeature.timeFormat;\n        }\n\n        Object.assign(widget, fieldConfig);\n\n        return super.processWidgetConfig(widget);\n    }\n\n    onBeforeShow(...args) {\n        const\n            me               = this,\n            {\n                record,\n                titleRenderer\n            }                = me,\n            { deleteButton } = me.widgetMap;\n\n        // Hide delete button if we are readOnly or the event is in a create phase\n        // which means we are editing a dblclick-created or drag-created event.\n        if (deleteButton) {\n            deleteButton.hidden = me.readOnly || record.isCreating;\n        }\n\n        if (titleRenderer) {\n            me.title = me.callback(titleRenderer, me, [record]);\n        }\n        else {\n            me.title = me.initialTitle;\n        }\n\n        super.onBeforeShow?.(...args);\n    }\n\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n\n    updateReadOnly(readOnly) {\n        const\n            {\n                deleteButton,\n                saveButton,\n                cancelButton\n            } = this.widgetMap;\n\n        super.updateReadOnly(readOnly);\n\n        if (deleteButton) {\n            deleteButton.hidden = readOnly;\n        }\n\n        if (saveButton) {\n            saveButton.hidden = readOnly;\n        }\n\n        if (cancelButton) {\n            cancelButton.hidden = readOnly;\n        }\n    }\n}\n\n// Register this widget type with its Factory\nEventEditor.initClass();\n","import RecurrenceFrequencyCombo from './RecurrenceFrequencyCombo.js';\n\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceCombo\n */\n\n/**\n * A combobox field displaying the recurrence by either mode: `Daily`, `Weekly`, `Monthly` or `Yearly` if the recurrence\n * has no other non-default settings, or `Custom...` if the recurrence has custom setting applied.\n *\n * @extends Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n * @classType recurrencecombo\n */\nexport default class RecurrenceCombo extends RecurrenceFrequencyCombo {\n\n    static get $name() {\n        return 'RecurrenceCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencecombo';\n    }\n\n    static get defaultConfig() {\n        return {\n            customValue             : 'custom',\n            placeholder             : 'None',\n            // TODO: draw a splitting line\n            splitCls                : 'b-recurrencecombo-split',\n            items                   : true,\n            highlightExternalChange : false\n        };\n    }\n\n    buildItems() {\n        const me = this;\n\n        return [\n            { value : 'none', text : 'L{None}' },\n            ...super.buildItems(),\n            { value : me.customValue, text : 'L{Custom}', cls : me.splitCls }\n        ];\n    }\n\n    set value(value) {\n        // Use 'none' instead of falsy value\n        value = value || 'none';\n\n        super.value = value;\n    }\n\n    get value() {\n        return super.value;\n    }\n\n    set recurrence(recurrence) {\n        const me = this;\n\n        if (recurrence) {\n            me.value = me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.frequency;\n        }\n        else {\n            me.value = null;\n        }\n    }\n\n    isCustomRecurrence(recurrence) {\n        const { interval, days, monthDays, months } = recurrence;\n\n        return Boolean(interval > 1 || (days && days.length) || (monthDays && monthDays.length) || (months && months.length));\n    }\n};\n\n// Register this widget type with its Factory\nRecurrenceCombo.initClass();\n","import Button from '../../../Core/widget/Button.js';\nimport RecurrenceLegend from '../../data/util/recurrence/RecurrenceLegend.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceLegendButton\n */\n\n/**\n * Class implementing a button which text displays the associated recurrence info in a human readable form.\n * @extends Core/widget/Button\n * @classType recurrencelegendbutton\n */\nexport default class RecurrenceLegendButton extends Button {\n\n    static get $name() {\n        return 'RecurrenceLegendButton';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrencelegendbutton';\n    }\n\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            recurrence            : null\n        };\n    }\n\n    /**\n     * Sets / gets the recurrence to display description for.\n     * @property {Scheduler.model.RecurrenceModel}\n     */\n    set recurrence(recurrence) {\n        this._recurrence = recurrence;\n        this.updateLegend();\n    }\n\n    get recurrence() {\n        return this._recurrence;\n    }\n\n    set eventStartDate(eventStartDate) {\n        this._eventStartDate = eventStartDate;\n        this.updateLegend();\n    }\n\n    get eventStartDate() {\n        return this._eventStartDate;\n    }\n\n    updateLegend() {\n        const { recurrence } = this;\n\n        this.text = recurrence ? RecurrenceLegend.getLegend(recurrence, this.eventStartDate) : '';\n    }\n\n    onLocaleChange() {\n        // on locale switch we update the button text to use proper language\n        this.updateLegend();\n    }\n\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n}\n\n// Register this widget type with its Factory\nRecurrenceLegendButton.initClass();\n","import Popup from '../../../Core/widget/Popup.js';\nimport './RecurrenceEditorPanel.js';\n\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditor\n */\n\n/**\n * Class implementing a dialog to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. The class is used by\n * the {@link Scheduler.view.mixin.RecurringEvents recurring events} feature, and you normally don't need to instantiate\n * it.\n *\n * Before showing the dialog need to use {@link Core.widget.Container#property-record} to load a\n * {@link Scheduler.model.RecurrenceModel recurrence model} data into the editor fields. For example:\n *\n * ```javascript\n * // make the editor instance\n * const editor = new RecurrenceEditor();\n * // load recurrence model into it\n * editor.record = new RecurrenceModel({ frequency : \"WEEKLY\" });\n * // display the editor\n * editor.show();\n * ```\n *\n * @extends Core/widget/Popup\n * @classType recurrenceeditor\n */\nexport default class RecurrenceEditor extends Popup {\n\n    static get $name() {\n        return 'RecurrenceEditor';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceeditor';\n    }\n\n    static get configurable() {\n        return {\n            draggable : true,\n            closable  : true,\n            floating  : true,\n            cls       : 'b-recurrenceeditor',\n            title     : 'L{Repeat event}',\n            autoClose : true,\n            width     : 470,\n            items     : {\n                recurrenceEditorPanel : {\n                    type  : 'recurrenceeditorpanel',\n                    title : null\n                }\n            },\n            bbar : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    foo : {\n                        type   : 'widget',\n                        cls    : 'b-label-filler',\n                        weight : 100\n                    },\n                    saveButton : {\n                        color   : 'b-green',\n                        text    : 'L{Save}',\n                        onClick : 'up.onSaveClick',\n                        weight  : 200\n                    },\n                    cancelButton : {\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelClick',\n                        weight  : 300\n                    }\n                }\n            }\n        };\n    }\n\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(readOnly);\n\n        // No save or cancel buttons. It's purely for information display when in readOnly mode\n        this.bbar.hidden = readOnly;\n    }\n\n    get recurrenceEditorPanel() {\n        return this.widgetMap.recurrenceEditorPanel;\n    }\n\n    // The following lines are added to satisfy the 904_unused localization test\n    // to let it know that these locales are used:\n    // 'L{DAILYintervalUnit}'\n    // 'L{WEEKLYintervalUnit}'\n    // 'L{MONTHLYintervalUnit}'\n    // 'L{YEARLYintervalUnit}'\n\n    updateRecord(record) {\n        this.recurrenceEditorPanel.record = record;\n    }\n\n    onSaveClick() {\n        const me = this;\n\n        if (me.saveHandler) {\n            me.saveHandler.call(me.thisObj || me, me, me.record);\n        }\n        else {\n            me.recurrenceEditorPanel.syncEventRecord();\n            me.close();\n        }\n    }\n\n    onCancelClick() {\n        const me = this;\n\n        if (me.cancelHandler) {\n            me.cancelHandler.call(me.thisObj || me, me, me.record);\n        }\n        else {\n            me.close();\n        }\n    }\n\n}\n\n// Register this widget type with its Factory\nRecurrenceEditor.initClass();\n","import Widget from '../../../Core/widget/Widget.js';\nimport Base from '../../../Core/Base.js';\nimport '../../view/recurrence/RecurrenceConfirmationPopup.js';\nimport '../../view/recurrence/field/RecurrenceCombo.js';\nimport '../../view/recurrence/RecurrenceLegendButton.js';\nimport '../../view/recurrence/RecurrenceEditor.js';\n\n/**\n * @module Scheduler/feature/mixin/RecurringEventEdit\n */\n\n/**\n * This mixin class provides recurring events functionality to the {@link Scheduler.feature.EventEdit event editor}.\n * @mixin\n */\nexport default Target => class RecurringEventEdit extends (Target || Base) {\n    static get $name() {\n        return 'RecurringEventEdit';\n    }\n\n    static get configurable() {\n        return {\n            recurringEventsItems : {\n                /**\n                 * Reference to the `Repeat` event field, if used\n                 * @member {Scheduler.view.recurrence.field.RecurrenceCombo} recurrenceCombo\n                 * @readonly\n                 */\n                recurrenceCombo : {\n                    type   : 'recurrencecombo',\n                    label  : 'L{EventEdit.Repeat}',\n                    ref    : 'recurrenceCombo',\n                    weight : 700\n                },\n                /**\n                 * Reference to the button that opens the event repeat settings dialog, if used\n                 * @member {Scheduler.view.recurrence.RecurrenceLegendButton} editRecurrenceButton\n                 * @readonly\n                 */\n                editRecurrenceButton : {\n                    type                 : 'recurrencelegendbutton',\n                    ref                  : 'editRecurrenceButton',\n                    name                 : 'recurrenceRule',\n                    color                : 'b-gray',\n                    menuIcon             : null,\n                    flex                 : 1,\n                    weight               : 800,\n                    ignoreParentReadOnly : true\n                }\n            },\n\n            /**\n             * Set to `false` to hide recurring fields in event editor, even if the\n             * {@link Scheduler.view.mixin.RecurringEvents#config-enableRecurringEvents Recurring Events} is `true`\n             * and a recurring event is being edited.\n             * @config {Boolean}\n             * @category Recurring\n             */\n            showRecurringUI : null\n        };\n    }\n\n    changeEditorConfig(editorConfig) {\n        editorConfig.items = { ...editorConfig.items, ...this.recurringEventsItems };\n\n        // EditBase inserts extraItems *after* all default items are in\n        editorConfig = super.changeEditorConfig(editorConfig);\n\n        return editorConfig;\n    }\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        this.scheduler.ion({\n            beforeEventSave : 'onRecurrableEventBeforeSave',\n            thisObj         : this\n        });\n    }\n\n    doDestroy() {\n        this._recurrenceConfirmation?.destroy();\n        this._recurrenceEditor?.destroy();\n\n        super.doDestroy();\n    }\n\n    onEditorConstructed(editor) {\n        const me = this;\n\n        editor.ion({\n            hide    : me.onRecurringEventEditorHide,\n            thisObj : me\n        });\n\n        if (me.editRecurrenceButton) {\n            me.editRecurrenceButton.menu = me.recurrenceEditor;\n        }\n\n        me.recurrenceCombo?.ion({\n            change  : me.onRecurrenceComboChange,\n            thisObj : me\n        });\n    }\n\n    updateReadOnly(readOnly) {\n        if (this._recurrenceEditor) {\n            this._recurrenceEditor.readOnly = readOnly;\n        }\n    }\n\n    internalShowEditor() {\n        this.toggleRecurringFieldsVisibility(this.client.enableRecurringEvents && this.showRecurringUI !== false);\n    }\n\n    toggleRecurringFieldsVisibility(show = true) {\n        const methodName = show ? 'show' : 'hide';\n\n        this.editRecurrenceButton?.[methodName]?.();\n        this.recurrenceCombo?.[methodName]?.();\n    }\n\n    onRecurringEventEditorHide() {\n        if (this.recurrenceEditor?.isVisible) {\n            this.recurrenceEditor.hide();\n        }\n\n        if (this.recurrenceConfirmation?.isVisible) {\n            this.recurrenceConfirmation.hide();\n        }\n    }\n\n    // Builds RecurrenceModel to load into the recurrenceEditor\n    // It builds the model based on either:\n    // - recurrence rule string (if provided)\n    // - or the event being edited recurrence (if the event is repeating)\n    // - or simply make a recurrence model w/ default state (by default means: Frequency=Daily, Interval=1)\n    makeRecurrence(rule) {\n        const\n            event     = this.eventRecord,\n            eventCopy = event.copy();\n\n        let recurrence = event.recurrence;\n\n        if (!rule && recurrence) {\n            recurrence = recurrence.copy();\n        }\n        else {\n            recurrence = new event.recurrenceModel(rule ? { rule } : {});\n        }\n\n        // bind cloned recurrence to the cloned event\n        recurrence.timeSpan = eventCopy;\n        // update cloned event w/ start date from the UI field\n        eventCopy.setStartDate(this.values.startDate);\n\n        recurrence.suspendTimeSpanNotifying();\n\n        return recurrence;\n    }\n\n    onRecurrableEventBeforeSave({ eventRecord, context }) {\n        const me = this;\n\n        // Other views features may trigger beforeEventSave, so only react when *we* are editing.\n        if (me.isEditing && !eventRecord.isCreating && eventRecord.supportsRecurring &&\n                (eventRecord.isRecurring || eventRecord.isOccurrence)) {\n            me.recurrenceConfirmation.confirm({\n                actionType : 'update',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n\n            // signalizes that we plan to decide save or not asynchronously\n            context.async = true;\n        }\n    }\n\n    set recurrenceConfirmation(recurrenceConfirmation) {\n        this._recurrenceConfirmation = recurrenceConfirmation;\n    }\n\n    get recurrenceConfirmation() {\n        const me = this;\n\n        let recurrenceConfirmation = me._recurrenceConfirmation;\n\n        if (!recurrenceConfirmation || !recurrenceConfirmation.$$name) {\n            recurrenceConfirmation = Widget.create({\n                type  : 'recurrenceconfirmation',\n                owner : me.editor,\n                ...recurrenceConfirmation\n            });\n\n            me._recurrenceConfirmation = recurrenceConfirmation;\n        }\n\n        return recurrenceConfirmation;\n    }\n\n    set recurrenceEditor(recurrenceEditor) {\n        this._recurrenceEditor = recurrenceEditor;\n    }\n\n    get recurrenceEditor() {\n        const me = this;\n\n        let recurrenceEditor = me._recurrenceEditor;\n\n        // Recurrence editor is centered and modal.\n        if (!recurrenceEditor || !recurrenceEditor.$$name) {\n            me._recurrenceEditor = recurrenceEditor = Widget.create({\n                type         : 'recurrenceeditor',\n                autoShow     : false,\n                centered     : true,\n                modal        : true,\n                constrainTo  : globalThis,\n                anchor       : false,\n                rootElement  : me.rootElement,\n                saveHandler  : me.recurrenceEditorSaveHandler,\n                onBeforeShow : me.onBeforeShowRecurrenceEditor.bind(me),\n                thisObj      : me,\n                ...recurrenceEditor\n            });\n\n            // Must set *after* construction, otherwise it becomes the default state\n            // to reset readOnly back to.  Must use direct property access because\n            // getter consults state of editor.\n            recurrenceEditor.readOnly = me._readOnly;\n        }\n\n        return recurrenceEditor;\n    }\n\n    onBeforeShowRecurrenceEditor() {\n        const\n            me                                = this,\n            { recurrenceEditor, eventRecord } = me;\n\n        if (recurrenceEditor && eventRecord?.supportsRecurring) {\n            // if the event has no recurrence yet ..initialize it before showing recurrence editor\n            if (!me.recurrence) {\n                me.recurrence = me.makeRecurrence();\n            }\n\n            // update the cloned recurrence w/ up to date start date value\n            me.recurrence.timeSpan.setStartDate(me.values.startDate);\n\n            // load RecurrenceModel record into the recurrence editor\n            recurrenceEditor.record = me.recurrence;\n\n            // In case they drag it. Centered falls off if the widget has position set.\n            recurrenceEditor.centered = true;\n        }\n    }\n\n    loadRecurrenceData(recurrence) {\n        this.recurrence = recurrence;\n\n        this.updateRecurrenceFields(recurrence);\n    }\n\n    updateRecurrenceFields(recurrence) {\n        const\n            me                       = this,\n            { editRecurrenceButton } = me;\n\n        if (me.recurrenceCombo) {\n            me.recurrenceCombo.recurrence = recurrence;\n        }\n\n        // update the recurrence legend\n        if (editRecurrenceButton) {\n            editRecurrenceButton.recurrence = recurrence;\n            editRecurrenceButton.value = recurrence ? recurrence.rule : null;\n\n            if (recurrence && me.client.enableRecurringEvents && me.showRecurringUI !== false) {\n                editRecurrenceButton.show();\n            }\n            else {\n                editRecurrenceButton.hide();\n            }\n        }\n    }\n\n    onRecurrenceComboChange({ source, value, userAction }) {\n        if (userAction) {\n            const\n                me                   = this,\n                { recurrenceEditor } = me;\n\n            if (value === source.customValue) {\n                // if user picked \"Custom\" - show recurrence editor\n                // This will recurse through the change event into the opposite side\n                // of the value test which will call updateRecurrenceFields, where the\n                // assignment to the value of the recurrenceCombo will be a non-change.\n                // That will sync the state of the recurrenceButton.\n                me.recurrenceCombo.recurrence = me.makeRecurrence();\n\n                if (recurrenceEditor.centered) {\n                    recurrenceEditor.show();\n                }\n                else {\n                    recurrenceEditor.show((me.editRecurrenceButton || source).element);\n                }\n            }\n            // user has picked some frequency -> make a new recurrence based on it\n            else {\n                me.loadRecurrenceData(value && value !== 'none' ? me.makeRecurrence(`FREQ=${value}`) : null);\n            }\n        }\n    }\n\n    recurrenceEditorSaveHandler(editor, recurrence) {\n        // apply changes to the kept recurrence\n        editor.recurrenceEditorPanel.syncEventRecord(recurrence);\n\n        // update the recurrence related UI\n        this.updateRecurrenceFields(recurrence);\n\n        editor.close();\n    }\n\n    onDatesChange(...args) {\n        super.onDatesChange(...args);\n\n        if (!this.loadingRecord && this.editRecurrenceButton) {\n            const { startDate } = this.values;\n\n            if (startDate) {\n                this.editRecurrenceButton.eventStartDate = startDate;\n            }\n        }\n    }\n\n    internalLoadRecord(eventRecord) {\n        if (eventRecord?.supportsRecurring) {\n            this.loadRecurrenceData(eventRecord.recurrence ? this.makeRecurrence() : null);\n        }\n    }\n\n    updateRecord(record) {\n        // Special handling for when setting recurrence to \"None\". Since button gets hidden its value is not picked up\n        // by the normal flow.\n        if (record.recurrenceRule && !this.recurrence) {\n            record.recurrenceRule = null;\n        }\n\n        return super.updateRecord(record);\n    }\n};\n","import Combo from '../../Core/widget/Combo.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/widget/ResourceCombo\n */\n\n/**\n * A Combo subclass which selects resources, optionally displaying the {@link Scheduler.model.ResourceModel#field-eventColor}\n * of each resource in the picker and in the input area.\n *\n * {@inlineexample Scheduler/widget/ResourceCombo.js}\n *\n * @extends Core/widget/Combo\n * @classType resourceCombo\n * @inputfield\n */\nexport default class ResourceCombo extends Combo {\n    static get $name() {\n        return 'ResourceCombo';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'resourcecombo';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Show the {@link Scheduler.model.ResourceModel#field-eventColor event color} for each resource\n             * @config {Boolean}\n             * @default\n             */\n            showEventColor : false,\n\n            picker : {\n                cls : 'b-resourcecombo-picker',\n\n                itemIconTpl(record, i) {\n                    const\n                        { eventColor } = record,\n                        isStyleColor   = !DomHelper.isNamedColor(eventColor),\n                        style          = eventColor ? (isStyleColor ? ` style=\"color:${eventColor}\"` : '') : ' style=\"display:none\"',\n                        colorClass     = !eventColor || isStyleColor ? '' : ` b-sch-foreground-${eventColor}`;\n\n                    return `<div class=\"b-icon b-icon-square${colorClass}\"${style}></div>`;\n                }\n            }\n        };\n    }\n\n    changeShowEventColor(showEventColor) {\n        return Boolean(showEventColor);\n    }\n\n    updateShowEventColor(showEventColor) {\n        const\n            { _picker } = this,\n            methodName  = showEventColor ? 'add' : 'remove';\n\n        this.element.classList[methodName]('b-show-event-color');\n        _picker?.element.classList[methodName]('b-show-event-color');\n    }\n\n    changePicker(picker, oldPicker) {\n        picker = super.changePicker(picker, oldPicker);\n        picker?.element.classList[this.showEventColor ? 'add' : 'remove']('b-show-event-color');\n        return picker;\n    }\n\n    // Implementation needed at this level because it has two inner elements in its inputWrap\n    get innerElements() {\n        return [\n            {\n                class     : 'b-icon b-resource-icon b-icon-square b-hide-display',\n                reference : 'resourceIcon'\n            },\n            this.inputElement\n        ];\n    }\n\n    syncInputFieldValue() {\n        const\n            me            = this,\n            {\n                resourceIcon,\n                lastResourceIconCls\n            }             = me,\n            { classList } = resourceIcon,\n            eventColor    = me.selected?.eventColor ?? '';\n\n        super.syncInputFieldValue();\n\n        // Remove last colour whichever way it was done\n        resourceIcon.style.color = '';\n        lastResourceIconCls && classList.remove(lastResourceIconCls);\n        me.lastResourceIconCls = null;\n\n        if (eventColor) {\n            if (DomHelper.isNamedColor(eventColor)) {\n                me.lastResourceIconCls = `b-sch-foreground-${eventColor}`;\n                classList.add(me.lastResourceIconCls);\n            }\n            else {\n                resourceIcon.style.color = eventColor;\n            }\n            classList.remove('b-hide-display');\n        }\n        else {\n            classList.add('b-hide-display');\n        }\n    }\n}\n\n// Register this widget type with its Factory\nResourceCombo.initClass();\n","import EditBase from './base/EditBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../view/EventEditor.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport RecurringEventEdit from './mixin/RecurringEventEdit.js';\nimport '../../Core/widget/TextField.js';\nimport '../../Scheduler/widget/ResourceCombo.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport '../../Core/widget/Button.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n\n/**\n * @module Scheduler/feature/EventEdit\n */\n\nconst punctuation = /[^\\w\\d]/g;\n\n/**\n * Feature that displays a popup containing widgets for editing event data.\n *\n * {@inlineexample Scheduler/feature/EventEdit.js}\n *\n * To customize its contents you can:\n *\n * * Reconfigure built in widgets by providing override configs in the {@link Scheduler.feature.base.EditBase#config-items} config.\n * * Change the date format of the date & time fields: {@link Scheduler.feature.base.EditBase#config-dateFormat} and {@link Scheduler.feature.base.EditBase#config-timeFormat }\n * * Configure provided widgets in the editor and add your own in the {@link Scheduler.feature.base.EditBase#config-items} config.\n * * Remove fields related to recurring events configuration (such as `recurrenceCombo`) by setting {@link Scheduler.feature.mixin.RecurringEventEdit#config-showRecurringUI} config to `false`.\n * * Advanced: Reconfigure the whole editor widget using {@link #config-editorConfig}\n *\n * ## Built in widgets\n *\n * The built in widgets are:\n *\n * | Widget ref             | Type                                                     | Weight | Description                                                    |\n * |------------------------|----------------------------------------------------------|--------|----------------------------------------------------------------|\n * | `nameField`            | {@link Core.widget.TextField}                            | 100    | Edit name                                                      |\n * | `resourceField`        | {@link Scheduler.widget.ResourceCombo}                   | 200    | Pick resource(s)                                               |\n * | `startDateField`       | {@link Core.widget.DateField}                            | 300    | Edit startDate (date part)                                     |\n * | `startTimeField`       | {@link Core.widget.TimeField}                            | 400    | Edit startDate (time part)                                     |\n * | `endDateField`         | {@link Core.widget.DateField}                            | 500    | Edit endDate (date part)                                       |\n * | `endTimeField`         | {@link Core.widget.TimeField}                            | 600    | Edit endDate (time part)                                       |\n * | `recurrenceCombo`      | {@link Scheduler.view.recurrence.field.RecurrenceCombo}  | 700    | Select recurrence rule (only visible if recurrence is used)    |\n * | `editRecurrenceButton` | {@link Scheduler.view.recurrence.RecurrenceLegendButton} | 800    | Edit the recurrence rule  (only visible if recurrence is used) |\n *\n * The built in buttons are:\n *\n * | Widget ref             | Type                                                                     | Weight | Description                                                    |\n * |------------------------|--------------------------------------------------------------------------|--------|----------------------------------------------------------------|\n * | `saveButton`           | {@link Core.widget.Button}                                               | 100    | Save event button on the bbar                                  |\n * | `deleteButton`         | {@link Core.widget.Button}                                               | 200    | Delete event button on the bbar                                |\n * | `cancelButton`         | {@link Core.widget.Button}                                               | 300    | Cancel event editing button on the bbar                        |\n *\n * ## Removing a built in item\n *\n * To remove a built in widget, specify its `ref` as `null` in the `items` config:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // Remove the start time field\n *                 startTimeField : null\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * Bottom buttons may be hidden using `bbar` config passed to `editorConfig`:\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             editorConfig : {\n *                 bbar : {\n *                     items : {\n *                         deleteButton : null\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * To remove fields related to recurring events configuration (such as `recurrenceCombo`), set {@link Scheduler.feature.mixin.RecurringEventEdit#config-showRecurringUI} config to `false`.\n *\n * ## Customizing a built in widget\n *\n * To customize a built in widget, use its `ref` as the key in the `items` config and specify the configs you want\n * to change (they will merge with the widgets default configs):\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // ref for an existing field\n *                 nameField : {\n *                     // Change its label\n *                     label : 'Description'\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * ## Adding custom widgets\n *\n * To add a custom widget, add an entry to the `items` config. The `name` property links the input field to a field in\n * the loaded event record:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // Key to use as fields ref (for easier retrieval later)\n *                 color : {\n *                     type  : 'combo',\n *                     label : 'Color',\n *                     items : ['red', 'green', 'blue'],\n *                     // name will be used to link to a field in the event record when loading and saving in the editor\n *                     name  : 'eventColor'\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * For more info on customizing the event editor, please see \"Customize event editor\" guide.\n *\n * This feature is **enabled** by default\n *\n * @mixes Scheduler/feature/mixin/RecurringEventEdit\n * @extends Scheduler/feature/base/EditBase\n * @demo Scheduler/eventeditor\n * @classtype eventEdit\n * @feature\n */\nexport default class EventEdit extends EditBase.mixin(RecurringEventEdit, Delayable) {\n    //region Config\n\n    static get $name() {\n        return 'EventEdit';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `''` or null to\n             * disable editing of existing events.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'eventdblclick',\n\n            /**\n             * The data field in the model that defines the eventType.\n             * Applied as class (b-eventtype-xx) to the editors element, to allow showing/hiding fields depending on\n             * eventType. Dynamic toggling of fields in the editor is activated by adding an `eventTypeField` field to\n             * your widget:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *    features : {\n             *       eventEdit : {\n             *           items : {\n             *               eventTypeField : {\n             *                  type  : 'combo',\n             *                  name  : 'eventType',\n             *                  label : 'Type',\n             *                  items : ['Appointment', 'Internal', 'Meeting']\n             *               }\n             *           }\n             *        }\n             *     }\n             * });\n             * ```\n             * Note, your event model class also must declare this field:\n             * ```javascript\n             *  class MyEvent extends EventModel {\n             *      static get fields() {\n             *          return [\n             *              { name : 'eventType' }\n             *          ];\n             *      }\n             *  }\n             * ```\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            typeField : 'eventType',\n\n            /**\n             * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.\n             * @property {Scheduler.model.EventModel}\n             * @readonly\n             */\n            eventRecord : null,\n\n            /**\n             * Specify `true` to put the editor in read only mode.\n             * @config {Boolean}\n             * @default false\n             */\n            readOnly : null,\n\n            /**\n             * The configuration for the internal editor widget. With this config you can control the *type*\n             * of editor (defaults to `Popup`) and which widgets to show,\n             * change the items in the `bbar`, or change whether the popup should be modal etc.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 modal  : true,\n             *                 cls    : 'my-editor' // A CSS class,\n             *                 items  : {\n             *                     owner : {\n             *                         weight : -100, // Will sort above system-supplied fields which are weight 100 to 800\n             *                         type   : 'usercombo',\n             *                         name   : 'owner',\n             *                         label  : 'Owner'\n             *                     },\n             *                     agreement : {\n             *                         weight : 1000, // Will sort below system-supplied fields which are weight 100 to 800\n             *                         type   : 'checkbox',\n             *                         name   : 'agreement',\n             *                         label  : 'Agree to terms'\n             *                     },\n             *                     resourceField : {\n             *                         // Apply a special filter to limit the Combo's access\n             *                         // to resources.\n             *                         store  {\n             *                             filters : [{\n             *                                 filterBy(resource) {\n             *                                     return shouldShowResource(record);\n             *                                 }\n             *                             }]\n             *                         }\n             *                     }\n             *                 },\n             *                 bbar : {\n             *                     items : {\n             *                         deleteButton : {\n             *                             hidden : true\n             *                         }\n             *                     }\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * Or to use your own custom editor:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 type : 'myCustomEditorType'\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Object}\n             * @category Editor\n             */\n            editorConfig : {\n                type        : 'eventeditor',\n                title       : 'L{EventEdit.Edit event}',\n                closable    : true,\n                localeClass : this,\n\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the name field, if used\n                     * @member {Core.widget.TextField} nameField\n                     * @readonly\n                     */\n                    nameField : {\n                        type      : 'text',\n                        label     : 'L{Name}',\n                        clearable : true,\n                        name      : 'name',\n                        weight    : 100,\n                        required  : true\n                    },\n                    /**\n                     * Reference to the resource field, if used\n                     * @member {Core.widget.Combo} resourceField\n                     * @readonly\n                     */\n                    resourceField : {\n                        type                    : 'resourcecombo',\n                        label                   : 'L{Resource}',\n                        name                    : 'resource',\n                        editable                : true,\n                        valueField              : 'id',\n                        displayField            : 'name',\n                        highlightExternalChange : false,\n                        destroyStore            : true,\n                        weight                  : 200\n                    },\n                    /**\n                     * Reference to the start date field, if used\n                     * @member {Core.widget.DateField} startDateField\n                     * @readonly\n                     */\n                    startDateField : {\n                        type             : 'date',\n                        cls              : 'b-inline',\n                        clearable        : false,\n                        required         : true,\n                        label            : 'L{Start}',\n                        name             : 'startDate',\n                        validateDateOnly : true,\n                        weight           : 300\n                    },\n                    /**\n                     * Reference to the start time field, if used\n                     * @member {Core.widget.TimeField} startTimeField\n                     * @readonly\n                     */\n                    startTimeField : {\n                        type      : 'time',\n                        clearable : false,\n                        required  : true,\n                        name      : 'startDate',\n                        cls       : 'b-match-label',\n                        weight    : 400\n                    },\n                    /**\n                     * Reference to the end date field, if used\n                     * @member {Core.widget.DateField} endDateField\n                     * @readonly\n                     */\n                    endDateField : {\n                        type             : 'date',\n                        cls              : 'b-inline',\n                        clearable        : false,\n                        required         : true,\n                        label            : 'L{End}',\n                        name             : 'endDate',\n                        validateDateOnly : true,\n                        weight           : 500\n                    },\n                    /**\n                     * Reference to the end time field, if used\n                     * @member {Core.widget.TimeField} endTimeField\n                     * @readonly\n                     */\n                    endTimeField : {\n                        type      : 'time',\n                        clearable : false,\n                        required  : true,\n                        name      : 'endDate',\n                        cls       : 'b-match-label',\n                        weight    : 600\n                    }\n                },\n\n                bbar : {\n                    // When readOnly, child buttons are hidden\n                    hideWhenEmpty : true,\n\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color  : 'b-blue',\n                            cls    : 'b-raised',\n                            text   : 'L{Save}',\n                            weight : 100\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            text   : 'L{Delete}',\n                            weight : 200\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            text   : 'L{Object.Cancel}',\n                            weight : 300\n                        }\n                    }\n                }\n            },\n\n            targetEventElement : null\n        };\n    }\n\n    static get pluginConfig() {\n        return {\n            chain : [\n                'populateEventMenu',\n                'onEventEnterKey',\n                'editEvent'\n            ]\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(scheduler, config) {\n        // Default to the scheduler's state, but configs may override\n        this.readOnly = scheduler.readOnly;\n\n        super.construct(scheduler, config);\n\n        scheduler.ion({\n            projectChange : 'onChangeProject',\n            readOnly      : 'onClientReadOnlyToggle',\n            thisObj       : this\n        });\n    }\n\n    get scheduler() {\n        return this.client;\n    }\n\n    //endregion\n\n    //region Editing\n\n    /**\n     * Get/set readonly state\n     * @property {Boolean}\n     */\n    get readOnly() {\n        return this._editor ? this.editor.readOnly : this._readOnly;\n    }\n\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(readOnly);\n\n        if (this._editor) {\n            this.editor.readOnly = readOnly;\n        }\n    }\n\n    onClientReadOnlyToggle({ readOnly }) {\n        this.readOnly = readOnly;\n    }\n\n    /**\n     * Returns the editor widget representing this feature\n     * @member {Core.widget.Popup}\n     */\n    get editor() {\n        const\n            me              = this,\n            editorListeners = {\n                beforehide : 'resetEditingContext',\n                beforeshow : 'onBeforeEditorShow',\n                keydown    : 'onPopupKeyDown',\n                thisObj    : me\n            };\n\n        let { _editor : editor } = me;\n\n        if (editor) {\n            return editor;\n        }\n\n        editor = me._editor = Widget.create(me.getEditorConfig());\n\n        // If the default Popup has been reconfigured to be static, add it as a child of our client.\n        if (!editor.floating && !editor.positioned) {\n            // If not configured with an appendTo, we add it as a child of our client.\n            if (!editor.element.parentNode) {\n                me.client.add(editor);\n            }\n            delete editorListeners.beforehide;\n            delete editorListeners.beforShow;\n            editorListeners.beforeToggleReveal = 'onBeforeEditorToggleReveal';\n        }\n\n        // Must set *after* construction, otherwise it becomes the default state\n        // to reset readOnly back to. Must use direct property access because\n        // getter consults state of editor.\n        editor.readOnly = me._readOnly;\n\n        if (editor.items.length === 0) {\n            console.warn('Event Editor configured without any `items`');\n        }\n\n        // add listeners programmatically so users cannot override them accidentally\n        editor.ion(editorListeners);\n\n        /**\n         * Fired before the editor will load the event record data into its input fields. This is useful if you\n         * want to modify the fields before data is loaded (e.g. set some input field to be readonly)\n         * @on-owner\n         * @event eventEditBeforeSetRecord\n         * @param {Core.widget.Container} source The editor widget\n         * @param {Scheduler.model.EventModel} record The record\n         */\n        me.scheduler.relayEvents(editor, ['beforeSetRecord'], 'eventEdit');\n\n        // assign widget variables, using widget name: startDate -> me.startDateField\n        // widgets with id set use that instead, id -> me.idField\n        Object.values(editor.widgetMap).forEach(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n\n                switch (widget.name) {\n                    case 'startDate':\n                    case 'endDate':\n                        widget.ion({ change : 'onDatesChange', thisObj : me });\n                        break;\n                }\n            }\n        });\n\n        // launch onEditorConstructed hook if provided\n        me.onEditorConstructed?.(editor);\n\n        me.eventTypeField?.ion({ change : 'onEventTypeChange', thisObj : me });\n\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n\n        return editor;\n    }\n\n    getEditorConfig() {\n        const\n            me                 = this,\n            // must result in longest format, ie 2 digits for date and all time parts.\n            time               = new Date(2000, 12, 31, 23, 55, 55),\n            dateLength         = DateHelper.format(time, me.dateFormat).replace(punctuation, '').length,\n            timeLength         = DateHelper.format(time, me.timeFormat).replace(punctuation, '').length,\n            dateTimeLength     = dateLength + timeLength,\n            { cls, scheduler } = me,\n            result             = ObjectHelper.assign({\n                owner            : scheduler,\n                eventEditFeature : me,\n                weekStartDay     : me.weekStartDay,\n                align            : 'b-t',\n                id               : `${scheduler.id}-event-editor`,\n                autoShow         : false,\n                anchor           : true,\n                scrollAction     : 'realign',\n                constrainTo      : globalThis,\n                cls\n            }, me.editorConfig);\n\n        // User configuration may have included a render target which means the editor\n        // will not be floating.\n        if (Widget.prototype.getRenderContext(result)[0]) {\n            result.floating = false;\n        }\n\n        // If the default Popup has been reconfigured to be static, ensure it starts\n        // life as a visible but collapsed panel.\n        if (result.floating === false && !result.positioned) {\n            result.collapsible = {\n                type           : 'overlay',\n                direction      : 'right',\n                autoClose      : false,\n                tool           : null,\n                recollapseTool : null\n            };\n            result.collapsed = true;\n            result.hidden = result.anchor = false;\n            result.hide = function() {\n                this.collapsible.toggleReveal(false);\n            };\n        }\n\n        // Layout-affecting props must be available early so that appendTo ends up with\n        // correct layout.\n        result.onElementCreated = function({ element }) {\n            element.style.setProperty('--date-time-length', `${dateTimeLength}em`);\n            element.style.setProperty('--date-width-difference', `${(dateLength - timeLength) / 2}em`);\n        };\n        return result;\n    }\n\n    // Called from editEvent() to actually show the editor\n    internalShowEditor(eventRecord, resourceRecord, align = null) {\n        const\n            me            = this,\n            { scheduler } = me,\n            // Align to the element (b-sch-event) and not the wrapper\n            eventElement = align?.target?.nodeType === Element.ELEMENT_NODE\n                ? align.target\n                : scheduler.getElementFromEventRecord(eventRecord, resourceRecord),\n            isPartOfStore = eventRecord.isPartOfStore(scheduler.eventStore);\n\n        align = align ?? {\n            // Align to the element (b-sch-event) and not the wrapper\n            target : eventElement,\n            anchor : true\n        };\n\n        // Event not in current TimeAxis - cannot be edited without extending the TimeAxis.\n        // If there's no event element and the eventRecord is not in the store, we still\n        // edit centered on the Scheduler - we're adding a new event\n        if (align.target || !isPartOfStore || eventRecord.isCreating) {\n            /**\n             * Fires on the owning Scheduler before an event is displayed in an editor.\n             * This may be listened for to allow an application to take over event editing duties. Returning `false`\n             * stops the default editing UI from being shown.\n             * @event beforeEventEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature\n             * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.\n             * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event\n             * is being created, it will not contain a resource, so this parameter specifies the resource the\n             * event is being created for.\n             * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.\n             * @preventable\n             */\n            if (scheduler.trigger('beforeEventEdit', {\n                eventEdit : me,\n                eventRecord,\n                resourceRecord,\n                eventElement\n            }) === false) {\n                scheduler.element.classList.remove('b-eventeditor-editing');\n                return false;\n            }\n\n            me.resourceRecord = resourceRecord;\n\n            const { editor } = me;\n\n            me.editingContext = {\n                eventRecord,\n                resourceRecord,\n                eventElement,\n                editor,\n                isPartOfStore\n            };\n\n            super.internalShowEditor?.(eventRecord, resourceRecord, align);\n\n            if (me.typeField) {\n                me.toggleEventType(eventRecord.get(me.typeField));\n            }\n\n            me.loadRecord(eventRecord, resourceRecord);\n\n            // If it's a static child of the client which is collapsed, expand it.\n            // Floating components focusOnShow by default, this will need to be focused.\n            if (editor.collapsed) {\n                // The *initial* reveal does not animate unless the toggleReveal call is delayed.\n                editor.setTimeout(async() => {\n                    await editor.collapsible.toggleReveal(true);\n                    editor.focus();\n                }, 100);\n            }\n            // Honour alignment settings \"anchor\" and \"centered\" which may be injected from editorConfig.\n            else if (editor.centered || !editor.anchor || !editor.floating) {\n                editor.show();\n            }\n            else if (eventElement) {\n                me.targetEventElement = eventElement;\n                editor.showBy(align);\n            }\n            // We are adding an unrendered event. Display the editor centered\n            else {\n                editor.show();\n\n                // Must be done after show because show always reverts to its configured centered setting.\n                editor.updateCentered(true);\n            }\n\n            // Adjust time field step increment based on timeAxis resolution\n            const timeResolution = scheduler.timeAxisViewModel.timeResolution;\n\n            if (timeResolution.unit === 'hour' || timeResolution.unit === 'minute') {\n                const step = `${timeResolution.increment}${timeResolution.unit}`;\n                if (me.startTimeField) {\n                    me.startTimeField.step = step;\n                }\n                if (me.endTimeField) {\n                    me.endTimeField.step = step;\n                }\n            }\n\n            // Might end up here with the old listener still around in monkey test for stress demo in turbo mode.\n            // Some action happening during edit, but cannot track down how what is going on\n            me.detachListeners('changesWhileEditing');\n\n            scheduler.eventStore.ion({\n                change  : me.onChangeWhileEditing,\n                refresh : me.onChangeWhileEditing,\n                thisObj : me,\n                name    : 'changesWhileEditing'\n            });\n        }\n    }\n\n    onChangeWhileEditing() {\n        const me = this;\n        // If event was removed, cancel editing\n        if (me.isEditing && me.editingContext.isPartOfStore && !me.eventRecord.isPartOfStore(me.scheduler.eventStore)) {\n            me.onCancelClick();\n        }\n    }\n\n    // Fired in a listener so that it's after the auto-called onBeforeShow listeners so that\n    // subscribers to the beforeEventEditShow are called at exactly the correct lifecycle point.\n    onBeforeEditorShow() {\n        super.onBeforeEditorShow(...arguments);\n\n        /**\n         * Fires on the owning Scheduler when the editor for an event is available but before it is populated with\n         * data and shown. Allows manipulating fields etc.\n         * @event beforeEventEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event\n         * is being created, it will not contain a resource, so this parameter specifies the resource the\n         * event is being created for.\n         * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.\n         * @param {Core.widget.Popup} editor The editor\n         */\n        this.scheduler.trigger('beforeEventEditShow', {\n            eventEdit : this,\n            ...this.editingContext\n        });\n    }\n\n    updateTargetEventElement(targetEventElement, oldTargetEventElement) {\n        targetEventElement?.classList.add('b-editing');\n        oldTargetEventElement?.classList.remove('b-editing');\n    }\n\n    /**\n     * Opens an editor for the passed event. This function is exposed on Scheduler and can be called as\n     * `scheduler.editEvent()`.\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @on-owner\n     */\n    editEvent(eventRecord, resourceRecord, element = null) {\n        const\n            me                  = this,\n            { simpleEventEdit } = me.client.features;\n\n        if (me.isEditing) {\n            // old editing flow already running, clean it up\n            me.resetEditingContext();\n        }\n\n        // If simple edit feature is active, use it when a new event is created\n        if (me.disabled || eventRecord.readOnly || (eventRecord.isCreating && simpleEventEdit?.enabled)) {\n            return;\n        }\n\n        // Implementations may be async, so the return value must always be propagated.\n        const result = me.doEditEvent(...arguments);\n\n        // The Promise being async allows a mouseover to trigger the event tip\n        // unless we add the editing class immediately (But only if we actually began editing).\n        if (me.isEditing) {\n            me.scheduler.element.classList.add('b-eventeditor-editing');\n        }\n\n        return result;\n    }\n\n    /**\n     * Returns true if the editor is currently active\n     * @readonly\n     * @property {Boolean}\n     */\n    get isEditing() {\n        const { _editor } = this;\n\n        return Boolean(\n            // Editor is not visible if it is collapsed and not expanded\n            _editor?.isVisible && !(_editor.collapsed && !_editor.revealed)\n        );\n    }\n\n    // editEvent is the single entry point in the base class.\n    // Subclass implementations of the action may differ, so are implemented in doEditEvent\n    doEditEvent(eventRecord, resourceRecord, element = null) {\n        const\n            me            = this,\n            { scheduler } = me,\n            isNewRecord   = eventRecord.isCreating;\n\n        if (!resourceRecord) {\n            // Need to handle resourceId for edge case when creating an event with resourceId and editing it before\n            // adding it to the EventStore\n            resourceRecord = eventRecord.resource || me.resourceStore.getById(eventRecord.resourceId);\n        }\n\n        if (isNewRecord) {\n            // Ensure temporal data fields are ready when the editor is shown\n            TimeSpan.prototype.normalize.call(eventRecord);\n        }\n\n        // If element is specified (call triggered by EventDragCreate)\n        // Then we can align to that, and no scrolling is necessary.\n        // If we are simply being asked to edit a new event which is not\n        // yet added, the editor is centered, and no scroll is necessary\n        if (element || isNewRecord) {\n            me.internalShowEditor(eventRecord, resourceRecord, element ? {\n                target : element\n            } : null);\n        }\n        else {\n            // Ensure event is in view before showing the editor.\n            // Note that we first need to extend the time axis to include\n            // currently out of range events.\n            scheduler.scrollResourceEventIntoView(resourceRecord, eventRecord, {\n                animate        : true,\n                edgeOffset     : 0,\n                extendTimeAxis : false\n            }).then(() => me.internalShowEditor(eventRecord, resourceRecord), () => scheduler.element.classList.remove('b-eventeditor-editing'));\n        }\n    }\n\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(eventRecord, resourceRecord) {\n        this.loadingRecord = true;\n\n        this.internalLoadRecord(eventRecord, resourceRecord);\n\n        this.loadingRecord = false;\n    }\n\n    get eventRecord() {\n        return this._editor?.record;\n    }\n\n    internalLoadRecord(eventRecord, resourceRecord) {\n        const\n            me                        = this,\n            { eventStore }            = me.client,\n            { editor, resourceField } = me;\n\n        me.resourceRecord = resourceRecord;\n\n        // Update chained store early, to have records in place when setting value below (avoids adding the resource to\n        // empty combo store, https://github.com/bryntum/support/issues/5378). It is not done automatically for\n        // grouping/trees or when project is replaced\n        if (resourceField && resourceField.store?.masterStore !== me.resourceStore) {\n            resourceField.store = editor.chainResourceStore();\n        }\n\n        editor.record = eventRecord;\n\n        if (resourceField) {\n            const resources = eventStore.assignmentStore.getResourcesForEvent(eventRecord);\n\n            // Flag on parent Container to indicate that initially blank fields are valid\n            editor.assigningValues = true;\n\n            // If this is an unassigned event, select the resource we've been provided\n            if (!eventRecord.isOccurrence && !eventStore.storage.includes(eventRecord, true) && resourceRecord) {\n                me.resourceField.value = resourceRecord[me.resourceField.valueField];\n            }\n            else if (me.assignmentStore) {\n                me.resourceField.value = resources.map((resource) => resource[me.resourceField.valueField]);\n            }\n            editor.assigningValues = false;\n        }\n\n        super.internalLoadRecord(eventRecord, resourceRecord);\n    }\n\n    toggleEventType(eventType) {\n        // expose eventType in dataset, for querying and styling\n        this.editor.element.dataset.eventType = eventType || '';\n\n        this.editor.eachWidget(widget => { // need {}'s here so we don't return false and end iteration\n            widget.dataset?.eventType && (widget.hidden = widget.dataset.eventType !== eventType);\n        });\n    }\n\n    //endregion\n\n    //region Save\n\n    async finalizeEventSave(eventRecord, resourceRecords, resolve, reject) {\n        const\n            me = this,\n            {\n                scheduler,\n                assignmentStore\n            }  = me;\n\n        const aborted = false;\n\n        // Prevent multiple commits from this flow\n        assignmentStore.suspendAutoCommit();\n\n        // Avoid multiple redraws, from event changes + assignment changes\n        scheduler.suspendRefresh();\n\n        me.onBeforeSave(eventRecord);\n\n        eventRecord.beginBatch();\n        me.updateRecord(eventRecord);\n        eventRecord.endBatch();\n\n        if (!eventRecord.isOccurrence) {\n            if (me.resourceField) {\n                assignmentStore.assignEventToResource(eventRecord, resourceRecords, null, true);\n            }\n        }\n        // An occurrence event record may have changed only resources value. In that case we'll never get into afterChange() method that\n        // apply changed data and make an event \"real\", because resources is not a field and a record won't be marked as dirty.\n        // We used temporary field to save updated resources list and get into afterChange() method.\n        else if (resourceRecords) {\n            eventRecord.set('resourceRecords', resourceRecords);\n        }\n\n        // If it was a provisional event, passed in here from drag-create or dblclick or contextmenu,\n        // it's now it's no longer a provisional event and will not be removed in resetEditingContext\n        // Also, when promoted to be permanent, auto syncing will kick in if configured.\n        eventRecord.isCreating = false;\n\n        if (!aborted) {\n            await scheduler.project.commitAsync();\n        }\n\n        assignmentStore.resumeAutoCommit();\n\n        // Redraw once\n        scheduler.resumeRefresh(true);\n\n        if (!aborted) {\n            /**\n             * Fires on the owning Scheduler after an event is successfully saved\n             * @event afterEventSave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.EventModel} eventRecord The record about to be saved\n             */\n            scheduler.trigger('afterEventSave', { eventRecord });\n            me.onAfterSave(eventRecord);\n        }\n        resolve(aborted ? false : eventRecord);\n    }\n\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeEventSave\n     * @fires beforeEventAdd\n     * @fires afterEventSave\n     * @async\n     */\n    save() {\n        return new Promise((resolve, reject) => {\n            const\n                me                         = this,\n                { scheduler, eventRecord } = me;\n\n            if (!eventRecord || !me.editor.isValid) {\n                resolve(false);\n                return;\n            }\n\n            const\n                { eventStore, values } = me,\n                resourceRecords        = me.resourceField?.records || (me.resourceRecord ? [me.resourceRecord] : []);\n\n            // Check for potential overlap scenarios before saving. TODO needs to be indicated in the UI\n            if (!me.scheduler.allowOverlap && eventStore) {\n                let { startDate, endDate } = values;\n\n                // Should support using a duration field instead of the end date field\n                if (!endDate) {\n                    if ('duration' in values) {\n                        endDate = DateHelper.add(startDate, values.duration, values.durationUnit || eventRecord.durationUnit);\n                    }\n                    else if ('fullDuration' in values) {\n                        endDate = DateHelper.add(startDate, values.fullDuration);\n                    }\n                    else {\n                        endDate = eventRecord.endDate;\n                    }\n                }\n\n                const abort = resourceRecords.some(resource => {\n                    return !eventStore.isDateRangeAvailable(startDate, endDate, eventRecord, resource);\n                });\n\n                if (abort) {\n                    resolve(false);\n                    return;\n                }\n            }\n\n            const context = {\n                finalize(saveEvent) {\n                    try {\n                        if (saveEvent !== false) {\n                            me.finalizeEventSave(eventRecord, resourceRecords, resolve, reject);\n                        }\n                        else {\n                            resolve(false);\n                        }\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n            };\n\n            /**\n             * Fires on the owning Scheduler before an event is saved, return `false` to prevent the save.\n             * @event beforeEventSave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.EventModel} eventRecord The record about to be saved\n             * @param {Scheduler.model.ResourceModel[]} resourceRecords The resources to which the event is assigned\n             * @param {Object} values The new values\n             * @param {Object} context Extended save context:\n             * @param {Boolean} [context.async] Set this to `true` in a listener to indicate that the listener will asynchronously decide to prevent or not the event save.\n             * @param {Function} context.finalize Function to call to finalize the save. Used when `async` is `true`. Provide `false` to the function to prevent the save.\n             * @preventable\n             */\n            if (scheduler.trigger('beforeEventSave', { eventRecord, resourceRecords, values, context }) === false) {\n                resolve(false);\n                return;\n            }\n            // truthy context.async means than a listener will decide to approve saving asynchronously\n            if (!context.async) {\n                context.finalize();\n            }\n        });\n    }\n\n    //endregion\n\n    //region Delete\n\n    /**\n     * Delete event being edited\n     * @fires beforeEventDelete\n     * @private\n     * @async\n     */\n    deleteEvent() {\n        this.detachListeners('changesWhileEditing');\n\n        return new Promise((resolve, reject) => {\n            const\n                me                      = this,\n                { eventRecord, editor } = me;\n\n            me.scheduler.removeEvents([eventRecord], removeRecord => {\n                // The reason it does it here is to move focus *before* it gets deleted,\n                // and then there's code in the delete to see that it's deleting the focused one,\n                // and jump forwards or backwards to move to the next or previous event\n                // See 'Should allow key activation' test in tests/view/mixins/EventNavigation.t.js\n                if (removeRecord && editor.containsFocus) {\n                    editor.revertFocus();\n                }\n\n                resolve(removeRecord);\n            }, editor);\n        });\n    }\n\n    //endregion\n\n    //region Stores\n\n    onChangeProject() {\n        // Release resource store on project change, it will be re-chained on next show\n        if (this.resourceField) {\n            this.resourceField.store = {}; // Cannot use null\n        }\n    }\n\n    get eventStore() {\n        return this.scheduler.project.eventStore;\n    }\n\n    get resourceStore() {\n        return this.scheduler.project.resourceStore;\n    }\n\n    get assignmentStore() {\n        return this.scheduler.project.assignmentStore;\n    }\n\n    //endregion\n\n    //endregion\n\n    //region Events\n\n    onActivateEditor({ eventRecord, resourceRecord, eventElement }) {\n        this.editEvent(eventRecord, resourceRecord, eventElement);\n    }\n\n    onDragCreateEnd({ eventRecord, resourceRecord, proxyElement }) {\n        this.editEvent(eventRecord, resourceRecord, proxyElement);\n    }\n\n    // chained from EventNavigation\n    onEventEnterKey({ assignmentRecord, eventRecord, target }) {\n        const\n            { client }  = this,\n            // Event can arrive from the wrap element in some products (such as Calendar)\n            // so in these cases, we must use querySelector to look *inside* the element.\n            element     = target[target.matches(client.eventSelector) ? 'querySelector' : 'closest'](client.eventInnerSelector);\n\n        if (assignmentRecord) {\n            this.editEvent(eventRecord, assignmentRecord.resource, element);\n        }\n        else if (eventRecord) {\n            this.editEvent(eventRecord, eventRecord.resource, element);\n        }\n    }\n\n    // Toggle fields visibility when changing eventType\n    onEventTypeChange({ value }) {\n        this.toggleEventType(value);\n    }\n\n    //endregion\n\n    //region Context menu\n\n    populateEventMenu({ eventRecord, resourceRecord, items }) {\n        if (!this.scheduler.readOnly && !this.disabled) {\n            items.editEvent = {\n                text        : 'L{EventEdit.Edit event}',\n                localeClass : this,\n                icon        : 'b-icon b-icon-edit',\n                weight      : 100,\n                disabled    : eventRecord.readOnly,\n                onItem      : () => {\n                    this.editEvent(eventRecord, resourceRecord);\n                }\n            };\n        }\n    }\n\n    //endregion\n\n    onBeforeEditorToggleReveal({ reveal }) {\n        // reveal true/false is analogous to show/hide\n        this[reveal ? 'onBeforeEditorShow' : 'resetEditingContext']();\n    }\n\n    resetEditingContext() {\n        this.detachListeners('changesWhileEditing');\n        super.resetEditingContext();\n        // Clear to prevent retaining project\n        this.resourceRecord = null;\n    }\n}\n\nGridFeatureManager.registerFeature(EventEdit, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventEdit, false, ['SchedulerPro', 'ResourceHistogram']);\n\nEventEdit.initClass();\n","import List from '../../Core/widget/List.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Scheduler/widget/ResourceFilter\n */\n\n/**\n * A List which allows selection of resources to filter a specified eventStore to only show\n * events for the selected resources.\n *\n * Because this widget maintains a state that can be changed through the UI, it offers some of the\n * API of an input field. It has a read only {@link #property-value} property, and it fires a\n * {@link #event-change} event.\n *\n * @extends Core/widget/List\n * @classType resourceFilter\n * @widget\n */\nexport default class ResourceFilter extends List {\n    static get $name() {\n        return 'ResourceFilter';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'resourcefilter';\n    }\n\n    static get delayable() {\n        return {\n            applyFilter : 'raf'\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * The {@link Scheduler.data.EventStore EventStore} to filter.\n             * Events for resources which are deselected in this List will be filtered out.\n             * @config {Scheduler.data.EventStore}\n             */\n            eventStore : null,\n\n            multiSelect            : true,\n            toggleAllIfCtrlPressed : true,\n            itemTpl                : record => StringHelper.encodeHtml(record.name || ''),\n\n            /**\n             * An optional filter function to apply when loading resources from the project's\n             * resource store. Defaults to loading all resources.\n             *\n             * **This is called using this `ResourceFilter` as the `this` object.**\n             * @config {Function}\n             * @default\n             */\n            masterFilter : () => true\n        };\n    }\n\n    itemIconTpl(record, i) {\n        const\n            { eventColor } = record,\n            // Named colors are applied using CSS\n            cls            = DomHelper.isNamedColor(eventColor) ? ` b-sch-foreground-${eventColor}` : '',\n            // CSS style color is used as is\n            style          = !cls && eventColor ? ` style=\"color:${eventColor}\"` : '';\n\n        return this.multiSelect ? `<div class=\"b-selected-icon b-icon${cls}\"${style}></div>` : '';\n    }\n\n    updateEventStore(eventStore) {\n        const\n            me                 = this,\n            // HACK: Temp workaround until List's store is dynamically updatable.\n            chainedStoreConfig = me.initialConfig.store?.isStore ? me.initialConfig.store.initialConfig : me.store?.config,\n            // Allow configuration of the filter for loading records from the master store.\n            { resourceStore }  = eventStore,\n            store              = me.store = resourceStore.chain(me.masterFilter, null, {\n                ...chainedStoreConfig,\n                syncOrder : true\n            }),\n            changeListeners    = {\n                change  : 'onStoreChange',\n                thisObj : me\n            };\n\n        // We need to sync selection and rendering on changes fired from master store\n        store.un(changeListeners);\n        resourceStore.ion(changeListeners);\n\n        if (!resourceStore.count) {\n            resourceStore.project.ion({\n                name    : 'project',\n                refresh : 'initFilter',\n                thisObj : me\n            });\n        }\n        else {\n            me.initFilter();\n        }\n    }\n\n    changeMasterFilter(masterFilter) {\n        // Cannot use bind, otherwise fillFromMaster's check for whether its a filter function fails.\n        const me = this;\n\n        return function(r) {\n            return masterFilter.call(me, r);\n        };\n    }\n\n    initFilter() {\n        const { eventStore, selected } = this;\n\n        if (eventStore.count && eventStore.resourceStore.count) {\n            // We default to all resources selected unless this was configured with\n            // an initialSelection. See List#changeSelection\n            if (!this.initialSelection) {\n                selected.add(this.store.getRange());\n            }\n            this.detachListeners('project');\n        }\n    }\n\n    onStoreRefresh({ source : store, action }) {\n        // We need to re-enable the filter if the store becomes filtered.\n        // We only disable the filter if we know that we have selected all available\n        // resources.\n        if (action === 'filter' && this.resourceFilter) {\n            const\n                { resourceFilter } = this,\n                { disabled }       = resourceFilter,\n                newDisabled        = !store.isFiltered && this.allSelected;\n\n            if (newDisabled !== disabled) {\n                resourceFilter.disabled = newDisabled;\n                this.applyFilter();\n            }\n        }\n        super.onStoreRefresh(...arguments);\n    }\n\n    onSelectionChange({ source : selected, added, removed }) {\n        // Filter disabled if all resources selected\n        const\n            me       = this,\n            // Only disable the filter if the allSelected method is seeing *all* of the\n            // records from its masterStore with no filtering.\n            disabled = !me.store.isFiltered && me.allSelected;\n\n        super.onSelectionChange(...arguments);\n\n        // If this is the first selection change triggered from the first project refresh\n        // in which all the resources are selected, then we ony need to apply the filters.\n        // if *not* all resources are selected, ie if added.length !== entire store length.\n        if (!me.resourceFilter) {\n            // Our client EventStore is filtered to only show events for our selected resources.\n            // Events without an associated resource are filtered into visibility.\n            // The addFilter function with silent param adds the filter but don't reevaluate filtering.\n            me.resourceFilter = me.eventStore.addFilter({\n                id       : `${me.id}-filter-instance`,\n                filterBy : e => !e.resource || me.selected.includes(e.resources),\n                disabled\n            }, added.length === me.store.count);\n\n            return;\n        }\n\n        // Filter disabled if all resources selected\n        me.resourceFilter.disabled = disabled;\n\n        // Have the client EventStore refresh its filtering but after a small delay so the List UI updates immediately.\n        me.applyFilter();\n\n        if (me.eventListeners.change) {\n            const\n                value    = selected.values,\n                oldValue = value.concat(removed);\n\n            ArrayHelper.remove(oldValue, added);\n\n            /**\n             * Fired when this widget's selection changes\n             * @event change\n             * @param {String} value - This field's value\n             * @param {String} oldValue - This field's previous value\n             * @param {Core.widget.Field} source - This ResourceFilter\n             */\n            me.triggerFieldChange({\n                value,\n                oldValue\n            });\n        }\n    }\n\n    /**\n     * An array encapsulating the currently selected resources.\n     * @member {Scheduler.model.ResourceModel[]}\n     * @readonly\n     */\n    get value() {\n        return this.selected.values;\n    }\n\n    applyFilter() {\n        this.eventStore.filter();\n    }\n}\n\n// Register this widget type with its Factory\nResourceFilter.initClass();\n","import DatePicker from '../../Core/widget/DatePicker.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n\n/**\n * @module Scheduler/widget/SchedulerDatePicker\n */\n\n/**\n * A subclass of {@link Core.widget.DatePicker} which is able to show the presence of\n * events in its cells if configured with an {@link #config-eventStore}, and\n * {@link #config-showEvents} is set to a truthy value.\n *\n * The `datepicker` Widget type is implemented by this class when this class is imported, or built\n * into a bundle, and so any {@link Core.widget.DateField} may have its\n * {@link Core.widget.PickerField#config-picker} configured to use its capabilities of showing\n * the presence of events in its date cells.\n *\n * @classtype datepicker\n * @extends Core/widget/DatePicker\n * @inlineexample Scheduler/widget/SchedulerDatePicker.js\n * @widget\n */\nexport default class SchedulerDatePicker extends DatePicker {\n    static get $name() {\n        return 'SchedulerDatePicker';\n    }\n\n    static get type() {\n        return 'datepicker';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * How to show presence of events in the configured {@link #config-eventStore} in the\n             * day cells. Values may be:\n             *\n             * * `false` - Do not show events in cells.\n             * * `true` - Show a themeable bullet to indicate the presence of events for a date.\n             * * `'count'` - Show a themeable badge containing the event count for a date.\n             * @config {Boolean|'count'}\n             * @default false\n             */\n            showEvents : null,\n\n            /**\n             * The {@link Scheduler.data.EventStore event store} from which the in-cell event presence\n             * indicators are drawn.\n             * @config {Scheduler.data.EventStore}\n             */\n            eventStore : null\n        };\n    }\n\n    construct(config) {\n        // Handle deprecated events config. It is now showEvents.\n        // events conflicts with the events data which may be passed in\n        if ('events' in config) {\n            config = {\n                ...config,\n                showEvents : config.events\n            };\n            delete config.events;\n\n            VersionHelper.deprecate(VersionHelper['calendar'] ? 'Calendar' : 'Scheduler', '6.0.0', 'DatePicker#events should be configured as showEvents');\n        }\n        super.construct(config);\n    }\n\n    doRefresh() {\n        this.refreshEventsMap();\n        return super.doRefresh(...arguments);\n    }\n\n    updateShowEvents(showEvents, oldShowEvents) {\n        const\n            me            = this,\n            { classList } = me.contentElement;\n\n        let { eventStore } = me;\n\n        // Begin any animations in the next AF\n        me.requestAnimationFrame(() => {\n            me.element.classList.toggle('b-datepicker-with-events', Boolean(showEvents));\n            me.owner?.element.classList.toggle('b-datepicker-with-events', Boolean(showEvents));\n            showEvents && classList.add(`b-show-events-${showEvents}`);\n            classList.remove(`b-show-events-${oldShowEvents}`);\n        });\n\n        if (showEvents) {\n            if (!eventStore) {\n                const eventStoreOwner = me.up(w => w.eventStore);\n\n                if (eventStoreOwner) {\n                    eventStore = eventStoreOwner.eventStore;\n                }\n                else {\n                    throw new Error('DatePicker configured with events but no eventStore');\n                }\n            }\n        }\n        else {\n            me.eventsMap = null;\n        }\n        if (!me.isConfiguring) {\n            me.updateEventStore(eventStore);\n            me.doRefresh();\n        }\n    }\n\n    refreshEventsMap() {\n        const me = this;\n\n        if (me.showEvents) {\n            me.eventsMap = me.eventStore.getEventCounts({\n                startDate : me.startDate,\n                endDate   : me.endDate,\n                dateMap   : me.eventsMap\n            });\n        }\n    }\n\n    updateEventStore(eventStore) {\n        // Add a listener to refresh on any event change unless the listener is already added.\n        if (eventStore.findListener('change', 'refresh', this) === -1) {\n            eventStore?.[this.showEvents ? 'on' : 'un']?.({\n                change  : 'refresh',\n                thisObj : this\n            });\n        }\n    }\n\n    cellRenderer({ cell, date }) {\n        const\n            { showEvents } = this,\n            count          = this.eventCounts?.get?.(DateHelper.makeKey(date)),\n            isCount        = showEvents === 'count';\n\n        delete cell.dataset.btip;\n        if (count) {\n            if (!isCount && this.eventCountTip) {\n                cell.dataset.btip = this.L('L{ResourceInfoColumn.eventCountText}', count);\n            }\n            DomHelper.createElement({\n                dataset : {\n                    count\n                },\n                class : {\n                    [isCount ? 'b-cell-events-badge' : 'b-icon b-icon-circle'] : 1,\n                    [SchedulerDatePicker.getEventCountClass(count)]            : 1\n                },\n                parent                  : cell,\n                [isCount ? 'text' : ''] : count\n            });\n        }\n    }\n\n    static getEventCountClass(count) {\n        if (count) {\n            if (count < 4) {\n                return 'b-datepicker-1-to-3-events';\n            }\n            if (count < 7) {\n                return 'b-datepicker-4-to-6-events';\n            }\n            return 'b-calendar-7-or-more-events';\n        }\n        return '';\n    }\n\n    static setupClass(meta) {\n        // We take over the type name 'datepicker' when we are in the app\n        meta.replaceType = true;\n\n        super.setupClass(meta);\n    }\n}\n\n// Register this widget type with its Factory\nSchedulerDatePicker.initClass();\n"],"names":["RecurrenceLegend","Localizable","$name","allDaysValueAsArray","allDaysValue","this","join","workingDaysValue","filter","day","index","DateHelper","nonWorkingDays","nonWorkingDaysValue","getLegend","recurrence","timeSpanStartDate","me","timeSpan","interval","days","monthDays","months","positions","startDate","tplData","fn","frequency","L","length","getDaysLegend","getDayName","getDay","sort","a","b","arrayToText","getDate","month","getMonthShortName","getMonthName","getMonth","position","DayRuleEncoder","decodeDay","getDayShortName","array","map","replace","_$name","DH","scheduleFields","makeDate","fields","value","date","time","DateField","reverse","dateValue","parse","setHours","getHours","getMinutes","getSeconds","getMilliseconds","clone","adjustEndDate","startTime","endDateField","endTimeField","newEndDate","add","copyTime","dateTo","dateFrom","d","Date","getTime","startDateField","startTimeField","eventRecord","durationMS","EditBase","InstancePlugin","configurable","saveAndCloseOnEnter","triggerEvent","dateFormat","timeFormat","editorConfig","items","weekStartDay","construct","client","config","eventEdit","super","ObjectHelper","assign","clientListenersDetacher","ion","dragCreateEnd","eventAutoCreated","thisObj","doDestroy","_this$_editor","_editor","destroy","onEventAutoCreated","changeEditorConfig","Objects","Config","merge","changeItems","cleanItemsConfig","ref","itemCfg","onDatesChange","params","_me$startTimeField","_me$startDateField2","field","source","_me$startDateField","_me$endDateField","min","isEqual","clearTime","save","Error","values","editor","startFields","endFields","forEach","f","eachWidget","widget","_editor$widgetMap$rec","name","hidden","up","w","recurrenceEditor","push","record","widgetMap","recurrenceCombo","allDay","endDate","duration","diff","durationUnit","onBeforeSave","onAfterSave","updateRecord","assignmentStore","resource","set","onBeforeEditorShow","editingContext","nameField","isCreating","assigningValues","_configuredPlaceholder","placeholder","resetEditingContext","eventStore","_me$editingContext$ev","isTimelineBase","eventElement","closest","classList","remove","element","targetEventElement","_record","onPopupKeyDown","event","readOnly","key","target","tagName","toLowerCase","preventDefault","onSaveClick","focus","saved","close","trigger","onDeleteClick","deleteEvent","autoClose","containsFocus","onCancelClick","EventEditor","Popup","type","draggable","handleSelector","axisLock","scrollable","overflowY","titleRenderer","updateLocalization","arguments","initialTitle","title","chainResourceStore","eventEditFeature","resourceStore","chain","isSpecialRow","storeClass","Store","excludeCollapsedRecords","processWidgetConfig","_widget$type","includes","fieldConfig","store","setConfig","multiSelect","usesSingleAssignment","format","Object","onBeforeShow","args","_super$onBeforeShow","deleteButton","callback","call","onInternalKeyDown","updateReadOnly","saveButton","cancelButton","initClass","RecurrenceCombo","RecurrenceFrequencyCombo","defaultConfig","customValue","splitCls","highlightExternalChange","buildItems","text","cls","isCustomRecurrence","Boolean","RecurrenceLegendButton","Button","localizableProperties","_recurrence","updateLegend","eventStartDate","_eventStartDate","onLocaleChange","RecurrenceEditor","closable","floating","width","recurrenceEditorPanel","bbar","defaults","localeClass","foo","weight","color","onClick","saveHandler","syncEventRecord","cancelHandler","Target","Base","recurringEventsItems","label","editRecurrenceButton","menuIcon","flex","ignoreParentReadOnly","showRecurringUI","_objectSpread","scheduler","beforeEventSave","_this$_recurrenceConf","_this$_recurrenceEdit","_recurrenceConfirmation","_recurrenceEditor","onEditorConstructed","_me$recurrenceCombo","hide","onRecurringEventEditorHide","menu","change","onRecurrenceComboChange","internalShowEditor","toggleRecurringFieldsVisibility","enableRecurringEvents","show","_this$editRecurrenceB","_this$editRecurrenceB2","_this$recurrenceCombo","_this$recurrenceCombo2","methodName","_this$recurrenceEdito","_this$recurrenceConfi","isVisible","recurrenceConfirmation","makeRecurrence","rule","eventCopy","copy","recurrenceModel","setStartDate","suspendTimeSpanNotifying","onRecurrableEventBeforeSave","context","isEditing","supportsRecurring","isRecurring","isOccurrence","confirm","actionType","changerFn","finalize","cancelFn","async","$$name","Widget","create","owner","autoShow","centered","modal","constrainTo","globalThis","anchor","rootElement","recurrenceEditorSaveHandler","onBeforeShowRecurrenceEditor","bind","_readOnly","loadRecurrenceData","updateRecurrenceFields","userAction","loadingRecord","internalLoadRecord","recurrenceRule","ResourceCombo","Combo","showEventColor","picker","itemIconTpl","i","eventColor","isStyleColor","DomHelper","isNamedColor","changeShowEventColor","updateShowEventColor","_picker","changePicker","oldPicker","_picker2","innerElements","class","reference","inputElement","syncInputFieldValue","_me$selected$eventCol","_me$selected","resourceIcon","lastResourceIconCls","selected","style","punctuation","EventEdit","mixin","RecurringEventEdit","Delayable","typeField","clearable","required","resourceField","editable","valueField","displayField","destroyStore","validateDateOnly","hideWhenEmpty","pluginConfig","projectChange","onClientReadOnlyToggle","_me$onEditorConstruct","_me$eventTypeField","_me$saveButton","_me$deleteButton","_me$cancelButton","editorListeners","beforehide","beforeshow","keydown","getEditorConfig","positioned","parentNode","beforShow","beforeToggleReveal","console","warn","relayEvents","id","eventTypeField","click","dateLength","timeLength","dateTimeLength","result","align","scrollAction","prototype","getRenderContext","collapsible","direction","tool","recollapseTool","collapsed","toggleReveal","onElementCreated","setProperty","resourceRecord","_align","_align$target","_align2","nodeType","Element","ELEMENT_NODE","getElementFromEventRecord","isPartOfStore","_super$internalShowEd","toggleEventType","get","loadRecord","setTimeout","showBy","updateCentered","timeResolution","timeAxisViewModel","unit","step","increment","detachListeners","onChangeWhileEditing","refresh","updateTargetEventElement","oldTargetEventElement","editEvent","simpleEventEdit","features","disabled","enabled","doEditEvent","revealed","isNewRecord","getById","resourceId","TimeSpan","normalize","scrollResourceEventIntoView","animate","edgeOffset","extendTimeAxis","then","_resourceField$store","masterStore","resources","getResourcesForEvent","storage","eventType","dataset","_widget$dataset","finalizeEventSave","resourceRecords","resolve","reject","suspendAutoCommit","suspendRefresh","beginBatch","endBatch","assignEventToResource","project","commitAsync","resumeAutoCommit","resumeRefresh","Promise","_me$resourceField","isValid","records","allowOverlap","fullDuration","some","isDateRangeAvailable","saveEvent","e","removeEvents","removeRecord","revertFocus","onChangeProject","onActivateEditor","onDragCreateEnd","proxyElement","onEventEnterKey","assignmentRecord","matches","eventSelector","eventInnerSelector","onEventTypeChange","populateEventMenu","icon","onItem","onBeforeEditorToggleReveal","reveal","GridFeatureManager","registerFeature","ResourceFilter","List","delayable","applyFilter","toggleAllIfCtrlPressed","itemTpl","StringHelper","encodeHtml","masterFilter","updateEventStore","_me$initialConfig$sto","_me$store","chainedStoreConfig","initialConfig","isStore","syncOrder","changeListeners","un","count","initFilter","changeMasterFilter","r","initialSelection","getRange","onStoreRefresh","action","resourceFilter","newDisabled","isFiltered","allSelected","onSelectionChange","added","removed","eventListeners","oldValue","concat","ArrayHelper","triggerFieldChange","addFilter","filterBy","SchedulerDatePicker","DatePicker","showEvents","events","VersionHelper","deprecate","doRefresh","refreshEventsMap","updateShowEvents","oldShowEvents","contentElement","requestAnimationFrame","_me$owner","toggle","eventStoreOwner","eventsMap","isConfiguring","getEventCounts","dateMap","_eventStore","findListener","cellRenderer","cell","_this$eventCounts","_this$eventCounts$get","eventCounts","makeKey","isCount","btip","eventCountTip","createElement","getEventCountClass","parent","setupClass","meta","replaceType"],"mappings":"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"}