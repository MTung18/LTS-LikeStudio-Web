{"version":3,"file":"ProjectModel.js","sources":["../../../../Engine/lib/Engine/vendor/later/later.js","../../../../chronograph/src/collection/Iterator.js","../../../../chronograph/src/class/Mixin.js","../../../../Engine/lib/Engine/scheduling/Types.js","../../../../Engine/lib/Engine/util/Constants.js","../../../../Engine/lib/Engine/util/Types.js","../../../../Engine/lib/Engine/calendar/CalendarCache.js","../../../../Engine/lib/Engine/util/StripDuplicates.js","../../../../Engine/lib/Engine/calendar/CalendarCacheInterval.js","../../../../Engine/lib/Engine/util/BinarySearch.js","../../../../Engine/lib/Engine/calendar/SortedMap.js","../../../../Engine/lib/Engine/calendar/IntervalCache.js","../../../../Engine/lib/Engine/calendar/CalendarCacheSingle.js","../../../../Engine/lib/Engine/quark/AbstractPartOfProjectGenericMixin.js","../../../../Engine/lib/Engine/quark/store/mixin/AbstractPartOfProjectStoreMixin.js","../../../../Engine/lib/Engine/quark/model/mixin/AbstractPartOfProjectModelMixin.js","../../../../Engine/lib/Engine/calendar/CalendarIntervalMixin.js","../../../../Engine/lib/Engine/calendar/CalendarIntervalStore.js","../../../../Engine/lib/Engine/calendar/UnspecifiedTimeIntervalModel.js","../../../../Engine/lib/Engine/quark/CorePartOfProjectGenericMixin.js","../../../../Engine/lib/Engine/quark/model/AbstractCalendarMixin.js","../../../../Engine/lib/Engine/quark/model/AbstractHasAssignmentsMixin.js","../../../../Engine/lib/Engine/quark/model/mixin/CorePartOfProjectModelMixin.js","../../../../Engine/lib/Engine/util/Functions.js","../../../../Engine/lib/Engine/quark/store/AbstractAssignmentStoreMixin.js","../../../../Engine/lib/Engine/quark/store/AbstractCalendarManagerStoreMixin.js","../../../../Engine/lib/Engine/quark/store/AbstractDependencyStoreMixin.js","../../../../Engine/lib/Engine/quark/store/AbstractEventStoreMixin.js","../../../../Engine/lib/Engine/quark/store/AbstractResourceStoreMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreEventMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreResourceMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreAssignmentMixin.js","../../../../Engine/lib/Engine/quark/store/mixin/CorePartOfProjectStoreMixin.js","../../../../Engine/lib/Engine/quark/store/CoreAssignmentStoreMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreCalendarMixin.js","../../../../Engine/lib/Engine/quark/store/CoreCalendarManagerStoreMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreDependencyMixin.js","../../../../Engine/lib/Engine/quark/store/CoreDependencyStoreMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreHasAssignmentsMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/CoreHasDependenciesMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreEvent.js","../../../../Engine/lib/Engine/quark/store/CoreEventStoreMixin.js","../../../../Engine/lib/Engine/quark/store/CoreResourceStoreMixin.js","../../../../Engine/lib/Engine/quark/model/AbstractProjectMixin.js","../../../../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js","../../../../Scheduler/lib/Scheduler/crud/mixin/AbstractCrudManagerValidation.js","../../../../Scheduler/lib/Scheduler/crud/AbstractCrudManagerMixin.js","../../../../Scheduler/lib/Scheduler/crud/transport/AjaxTransport.js","../../../../Scheduler/lib/Scheduler/crud/encoder/JsonEncoder.js","../../../../Scheduler/lib/Scheduler/crud/mixin/CrudManagerView.js","../../../../Scheduler/lib/Scheduler/data/mixin/PartOfProject.js","../../../../Scheduler/lib/Scheduler/model/mixin/AssignmentModelMixin.js","../../../../Scheduler/lib/Scheduler/model/AssignmentModel.js","../../../../Scheduler/lib/Scheduler/data/mixin/AssignmentStoreMixin.js","../../../../Scheduler/lib/Scheduler/data/AssignmentStore.js","../../../../Scheduler/lib/Scheduler/data/mixin/ResourceStoreMixin.js","../../../../Scheduler/lib/Scheduler/model/mixin/ResourceModelMixin.js","../../../../Scheduler/lib/Scheduler/model/ResourceModel.js","../../../../Scheduler/lib/Scheduler/data/ResourceStore.js","../../../../Scheduler/lib/Scheduler/data/mixin/EventStoreMixin.js","../../../../Scheduler/lib/Scheduler/data/mixin/GetEventsMixin.js","../../../../Scheduler/lib/Scheduler/data/util/EventDayIndex.js","../../../../Scheduler/lib/Scheduler/data/mixin/DayIndexMixin.js","../../../../Scheduler/lib/Scheduler/data/mixin/SharedEventStoreMixin.js","../../../../Scheduler/lib/Scheduler/data/mixin/RecurringTimeSpansMixin.js","../../../../Scheduler/lib/Scheduler/data/mixin/RecurringEventsMixin.js","../../../../Scheduler/lib/Scheduler/model/mixin/TimeZonedDatesMixin.js","../../../../Scheduler/lib/Scheduler/model/TimeSpan.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceDayRuleEncoder.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/AbstractRecurrenceIterator.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/DailyRecurrenceIterator.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/WeeklyRecurrenceIterator.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/MonthlyRecurrenceIterator.js","../../../../Scheduler/lib/Scheduler/data/util/recurrence/YearlyRecurrenceIterator.js","../../../../Scheduler/lib/Scheduler/model/RecurrenceModel.js","../../../../Scheduler/lib/Scheduler/model/mixin/RecurringTimeSpan.js","../../../../Scheduler/lib/Scheduler/model/mixin/EventModelMixin.js","../../../../Scheduler/lib/Scheduler/model/EventModel.js","../../../../Scheduler/lib/Scheduler/data/EventStore.js","../../../../Scheduler/lib/Scheduler/model/DependencyBaseModel.js","../../../../Scheduler/lib/Scheduler/model/DependencyModel.js","../../../../Scheduler/lib/Scheduler/data/mixin/DependencyStoreMixin.js","../../../../Scheduler/lib/Scheduler/data/DependencyStore.js","../../../../Scheduler/lib/Scheduler/data/mixin/ProjectCrudManager.js","../../../../Scheduler/lib/Scheduler/model/mixin/ProjectModelCommon.js","../../../../Scheduler/lib/Scheduler/model/ResourceTimeRangeModel.js","../../../../Scheduler/lib/Scheduler/data/ResourceTimeRangeStore.js","../../../../Scheduler/lib/Scheduler/model/mixin/ProjectModelTimeZoneMixin.js","../../../../Scheduler/lib/Scheduler/model/mixin/ProjectModelMixin.js","../../../../Scheduler/lib/Scheduler/model/mixin/ProjectCurrentConfig.js","../../../../Scheduler/lib/Scheduler/data/util/ModelPersistencyManager.js","../../../../Scheduler/lib/Scheduler/model/ProjectModel.js"],"sourcesContent":["// @ts-nocheck\n\nconst diffSecond = (date, diff) => {\n    return new Date(\n        date.getFullYear(),\n        date.getMonth(),\n        date.getDate(),\n        date.getHours(),\n        date.getMinutes(),\n        date.getSeconds() + diff,\n        date.getMilliseconds()\n    );\n};\n\n/**\n * The code just copy/pasted from pre-built later.js file and made exported\n *\n * @private\n */\nexport const later = (function () {\n    \"use strict\";\n    var later = {\n        version: \"1.2.0\"\n    };\n    if (!Array.prototype.indexOf) {\n        Array.prototype.indexOf = function (searchElement) {\n            \"use strict\";\n            if (this == null) {\n                throw new TypeError();\n            }\n            var t = Object(this);\n            var len = t.length >>> 0;\n            if (len === 0) {\n                return -1;\n            }\n            var n = 0;\n            if (arguments.length > 1) {\n                n = Number(arguments[1]);\n                if (n != n) {\n                    n = 0;\n                }\n                else if (n != 0 && n != Infinity && n != -Infinity) {\n                    n = (n > 0 || -1) * Math.floor(Math.abs(n));\n                }\n            }\n            if (n >= len) {\n                return -1;\n            }\n            var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);\n            for (; k < len; k++) {\n                if (k in t && t[k] === searchElement) {\n                    return k;\n                }\n            }\n            return -1;\n        };\n    }\n    if (!String.prototype.trim) {\n        String.prototype.trim = function () {\n            return this.replace(/^\\s+|\\s+$/g, \"\");\n        };\n    }\n    later.array = {};\n    later.array.sort = function (arr, zeroIsLast) {\n        arr.sort(function (a, b) {\n            return +a - +b;\n        });\n        if (zeroIsLast && arr[0] === 0) {\n            arr.push(arr.shift());\n        }\n    };\n    later.array.next = function (val, values, extent) {\n        var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;\n        for (var i = values.length - 1; i > -1; --i) {\n            cur = values[i];\n            if (cur === val) {\n                return cur;\n            }\n            if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {\n                nextIdx = i;\n                continue;\n            }\n            break;\n        }\n        return values[nextIdx];\n    };\n    later.array.nextInvalid = function (val, values, extent) {\n        var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n        while (next === (values[i] || zeroVal)) {\n            next++;\n            if (next > max) {\n                next = min;\n            }\n            i++;\n            if (i === len) {\n                i = 0;\n            }\n            if (next === start) {\n                return undefined;\n            }\n        }\n        return next;\n    };\n    later.array.prev = function (val, values, extent) {\n        var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;\n        for (var i = 0; i < len; i++) {\n            cur = values[i];\n            if (cur === val) {\n                return cur;\n            }\n            if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {\n                prevIdx = i;\n                continue;\n            }\n            break;\n        }\n        return values[prevIdx];\n    };\n    later.array.prevInvalid = function (val, values, extent) {\n        var min = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;\n        while (next === (values[i] || zeroVal)) {\n            next--;\n            if (next < min) {\n                next = max;\n            }\n            i--;\n            if (i === -1) {\n                i = len - 1;\n            }\n            if (next === start) {\n                return undefined;\n            }\n        }\n        return next;\n    };\n    later.day = later.D = {\n        name: \"day\",\n        range: 86400,\n        val: function (d) {\n            return d.D || (d.D = later.date.getDate.call(d));\n        },\n        isValid: function (d, val) {\n            return later.D.val(d) === (val || later.D.extent(d)[1]);\n        },\n        extent: function (d) {\n            if (d.DExtent)\n                return d.DExtent;\n            var month = later.M.val(d), max = later.DAYS_IN_MONTH[month - 1];\n            if (month === 2 && later.dy.extent(d)[1] === 366) {\n                max = max + 1;\n            }\n            return d.DExtent = [1, max];\n        },\n        start: function (d) {\n            return d.DStart || (d.DStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d)));\n        },\n        end: function (d) {\n            return d.DEnd || (d.DEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d)));\n        },\n        next: function (d, val) {\n            val = val > later.D.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n            val = val > DMax ? 1 : val || DMax;\n            return later.date.next(later.Y.val(month), later.M.val(month), val);\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.D, later.M), DMax = later.D.extent(month)[1];\n            return later.date.prev(later.Y.val(month), later.M.val(month), val > DMax ? DMax : val || DMax);\n        }\n    };\n    later.dayOfWeekCount = later.dc = {\n        name: \"day of week count\",\n        range: 604800,\n        val: function (d) {\n            return d.dc || (d.dc = Math.floor((later.D.val(d) - 1) / 7) + 1);\n        },\n        isValid: function (d, val) {\n            return later.dc.val(d) === val || val === 0 && later.D.val(d) > later.D.extent(d)[1] - 7;\n        },\n        extent: function (d) {\n            return d.dcExtent || (d.dcExtent = [1, Math.ceil(later.D.extent(d)[1] / 7)]);\n        },\n        start: function (d) {\n            return d.dcStart || (d.dcStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(1, (later.dc.val(d) - 1) * 7 + 1 || 1)));\n        },\n        end: function (d) {\n            return d.dcEnd || (d.dcEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.dc.val(d) * 7, later.D.extent(d)[1])));\n        },\n        next: function (d, val) {\n            val = val > later.dc.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n            val = val > dcMax ? 1 : val;\n            var next = later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n            if (next.getTime() <= d.getTime()) {\n                month = later.M.next(d, later.M.val(d) + 1);\n                return later.date.next(later.Y.val(month), later.M.val(month), val === 0 ? later.D.extent(month)[1] - 6 : 1 + 7 * (val - 1));\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.dc, later.M), dcMax = later.dc.extent(month)[1];\n            val = val > dcMax ? dcMax : val || dcMax;\n            return later.dc.end(later.date.prev(later.Y.val(month), later.M.val(month), 1 + 7 * (val - 1)));\n        }\n    };\n    later.dayOfWeek = later.dw = later.d = {\n        name: \"day of week\",\n        range: 86400,\n        val: function (d) {\n            return d.dw || (d.dw = later.date.getDay.call(d) + 1);\n        },\n        isValid: function (d, val) {\n            return later.dw.val(d) === (val || 7);\n        },\n        extent: function () {\n            return [1, 7];\n        },\n        start: function (d) {\n            return later.D.start(d);\n        },\n        end: function (d) {\n            return later.D.end(d);\n        },\n        next: function (d, val) {\n            val = val > 7 ? 1 : val || 7;\n            return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val <= later.dw.val(d) ? 7 : 0));\n        },\n        prev: function (d, val) {\n            val = val > 7 ? 7 : val || 7;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val - later.dw.val(d)) + (val >= later.dw.val(d) ? -7 : 0));\n        }\n    };\n    later.dayOfYear = later.dy = {\n        name: \"day of year\",\n        range: 86400,\n        val: function (d) {\n            return d.dy || (d.dy = Math.ceil(1 + (later.D.start(d).getTime() - later.Y.start(d).getTime()) / later.DAY));\n        },\n        isValid: function (d, val) {\n            return later.dy.val(d) === (val || later.dy.extent(d)[1]);\n        },\n        extent: function (d) {\n            var year = later.Y.val(d);\n            return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);\n        },\n        start: function (d) {\n            return later.D.start(d);\n        },\n        end: function (d) {\n            return later.D.end(d);\n        },\n        next: function (d, val) {\n            val = val > later.dy.extent(d)[1] ? 1 : val;\n            var year = later.date.nextRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n            val = val > dyMax ? 1 : val || dyMax;\n            return later.date.next(later.Y.val(year), later.M.val(year), val);\n        },\n        prev: function (d, val) {\n            var year = later.date.prevRollover(d, val, later.dy, later.Y), dyMax = later.dy.extent(year)[1];\n            val = val > dyMax ? dyMax : val || dyMax;\n            return later.date.prev(later.Y.val(year), later.M.val(year), val);\n        }\n    };\n    later.hour = later.h = {\n        name: \"hour\",\n        range: 3600,\n        val: function (d) {\n            return d.h || (d.h = later.date.getHour.call(d));\n        },\n        isValid: function (d, val) {\n            return later.h.val(d) === val;\n        },\n        extent: function () {\n            return [0, 23];\n        },\n        start: function (d) {\n            return d.hStart || (d.hStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n        },\n        end: function (d) {\n            return d.hEnd || (d.hEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d)));\n        },\n        next: function (d, val) {\n            val = val > 23 ? 0 : val;\n            var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.h.val(d) ? 1 : 0), val);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), val + 1);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 23 ? 23 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.h.val(d) ? -1 : 0), val);\n        }\n    };\n    later.minute = later.m = {\n        name: \"minute\",\n        range: 60,\n        val: function (d) {\n            return d.m || (d.m = later.date.getMin.call(d));\n        },\n        isValid: function (d, val) {\n            return later.m.val(d) === val;\n        },\n        extent: function (d) {\n            return [0, 59];\n        },\n        start: function (d) {\n            return d.mStart || (d.mStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n        },\n        end: function (d) {\n            return d.mEnd || (d.mEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d)));\n        },\n        next: function (d, val) {\n            var m = later.m.val(d), s = later.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later.MIN - s * later.SEC);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = new Date(d.getTime() + (inc + 120) * later.MIN - s * later.SEC);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 59 ? 59 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d) + (val >= later.m.val(d) ? -1 : 0), val);\n        }\n    };\n    later.month = later.M = {\n        name: \"month\",\n        range: 2629740,\n        val: function (d) {\n            return d.M || (d.M = later.date.getMonth.call(d) + 1);\n        },\n        isValid: function (d, val) {\n            return later.M.val(d) === (val || 12);\n        },\n        extent: function () {\n            return [1, 12];\n        },\n        start: function (d) {\n            return d.MStart || (d.MStart = later.date.next(later.Y.val(d), later.M.val(d)));\n        },\n        end: function (d) {\n            return d.MEnd || (d.MEnd = later.date.prev(later.Y.val(d), later.M.val(d)));\n        },\n        next: function (d, val) {\n            val = val > 12 ? 1 : val || 12;\n            return later.date.next(later.Y.val(d) + (val > later.M.val(d) ? 0 : 1), val);\n        },\n        prev: function (d, val) {\n            val = val > 12 ? 12 : val || 12;\n            return later.date.prev(later.Y.val(d) - (val >= later.M.val(d) ? 1 : 0), val);\n        }\n    };\n    later.second = later.s = {\n        name: \"second\",\n        range: 1,\n        val: function (d) {\n            return d.s || (d.s = later.date.getSec.call(d));\n        },\n        isValid: function (d, val) {\n            return later.s.val(d) === val;\n        },\n        extent: function () {\n            return [0, 59];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            var s = later.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later.SEC);\n            if (!later.date.isUTC && next.getTime() <= d.getTime()) {\n                next = new Date(d.getTime() + (inc + 7200) * later.SEC);\n            }\n            return next;\n        },\n        prev: function (d, val, cache) {\n            val = val > 59 ? 59 : val;\n            return later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d), later.h.val(d), later.m.val(d) + (val >= later.s.val(d) ? -1 : 0), val);\n        }\n    };\n    later.time = later.t = {\n        name: \"time\",\n        range: 1,\n        val: function (d) {\n            return d.t || (d.t = later.h.val(d) * 3600 + later.m.val(d) * 60 + later.s.val(d));\n        },\n        isValid: function (d, val) {\n            return later.t.val(d) === val;\n        },\n        extent: function () {\n            return [0, 86399];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            val = val > 86399 ? 0 : val;\n            var next = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val <= later.t.val(d) ? 1 : 0), 0, 0, val);\n            if (!later.date.isUTC && next.getTime() < d.getTime()) {\n                next = later.date.next(later.Y.val(next), later.M.val(next), later.D.val(next), later.h.val(next), later.m.val(next), val + 7200);\n            }\n            return next;\n        },\n        prev: function (d, val) {\n            val = val > 86399 ? 86399 : val;\n            return later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) + (val >= later.t.val(d) ? -1 : 0), 0, 0, val);\n        }\n    };\n    later.weekOfMonth = later.wm = {\n        name: \"week of month\",\n        range: 604800,\n        val: function (d) {\n            return d.wm || (d.wm = (later.D.val(d) + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(d))) / 7);\n        },\n        isValid: function (d, val) {\n            return later.wm.val(d) === (val || later.wm.extent(d)[1]);\n        },\n        extent: function (d) {\n            return d.wmExtent || (d.wmExtent = [1, (later.D.extent(d)[1] + (later.dw.val(later.M.start(d)) - 1) + (7 - later.dw.val(later.M.end(d)))) / 7]);\n        },\n        start: function (d) {\n            return d.wmStart || (d.wmStart = later.date.next(later.Y.val(d), later.M.val(d), Math.max(later.D.val(d) - later.dw.val(d) + 1, 1)));\n        },\n        end: function (d) {\n            return d.wmEnd || (d.wmEnd = later.date.prev(later.Y.val(d), later.M.val(d), Math.min(later.D.val(d) + (7 - later.dw.val(d)), later.D.extent(d)[1])));\n        },\n        next: function (d, val) {\n            val = val > later.wm.extent(d)[1] ? 1 : val;\n            var month = later.date.nextRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n            val = val > wmMax ? 1 : val || wmMax;\n            return later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2)));\n        },\n        prev: function (d, val) {\n            var month = later.date.prevRollover(d, val, later.wm, later.M), wmMax = later.wm.extent(month)[1];\n            val = val > wmMax ? wmMax : val || wmMax;\n            return later.wm.end(later.date.next(later.Y.val(month), later.M.val(month), Math.max(1, (val - 1) * 7 - (later.dw.val(month) - 2))));\n        }\n    };\n    later.weekOfYear = later.wy = {\n        name: \"week of year (ISO)\",\n        range: 604800,\n        val: function (d) {\n            if (d.wy)\n                return d.wy;\n            var wThur = later.dw.next(later.wy.start(d), 5), YThur = later.dw.next(later.Y.prev(wThur, later.Y.val(wThur) - 1), 5);\n            return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later.WEEK);\n        },\n        isValid: function (d, val) {\n            return later.wy.val(d) === (val || later.wy.extent(d)[1]);\n        },\n        extent: function (d) {\n            if (d.wyExtent)\n                return d.wyExtent;\n            var year = later.dw.next(later.wy.start(d), 5), dwFirst = later.dw.val(later.Y.start(year)), dwLast = later.dw.val(later.Y.end(year));\n            return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];\n        },\n        start: function (d) {\n            return d.wyStart || (d.wyStart = later.date.next(later.Y.val(d), later.M.val(d), later.D.val(d) - (later.dw.val(d) > 1 ? later.dw.val(d) - 2 : 6)));\n        },\n        end: function (d) {\n            return d.wyEnd || (d.wyEnd = later.date.prev(later.Y.val(d), later.M.val(d), later.D.val(d) + (later.dw.val(d) > 1 ? 8 - later.dw.val(d) : 0)));\n        },\n        next: function (d, val) {\n            val = val > later.wy.extent(d)[1] ? 1 : val;\n            var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.nextRollover(wyThur, val, later.wy, later.Y);\n            if (later.wy.val(year) !== 1) {\n                year = later.dw.next(year, 2);\n            }\n            var wyMax = later.wy.extent(year)[1], wyStart = later.wy.start(year);\n            val = val > wyMax ? 1 : val || wyMax;\n            return later.date.next(later.Y.val(wyStart), later.M.val(wyStart), later.D.val(wyStart) + 7 * (val - 1));\n        },\n        prev: function (d, val) {\n            var wyThur = later.dw.next(later.wy.start(d), 5), year = later.date.prevRollover(wyThur, val, later.wy, later.Y);\n            if (later.wy.val(year) !== 1) {\n                year = later.dw.next(year, 2);\n            }\n            var wyMax = later.wy.extent(year)[1], wyEnd = later.wy.end(year);\n            val = val > wyMax ? wyMax : val || wyMax;\n            return later.wy.end(later.date.next(later.Y.val(wyEnd), later.M.val(wyEnd), later.D.val(wyEnd) + 7 * (val - 1)));\n        }\n    };\n    later.year = later.Y = {\n        name: \"year\",\n        range: 31556900,\n        val: function (d) {\n            return d.Y || (d.Y = later.date.getYear.call(d));\n        },\n        isValid: function (d, val) {\n            return later.Y.val(d) === val;\n        },\n        extent: function () {\n            return [1970, 2099];\n        },\n        start: function (d) {\n            return d.YStart || (d.YStart = later.date.next(later.Y.val(d)));\n        },\n        end: function (d) {\n            return d.YEnd || (d.YEnd = later.date.prev(later.Y.val(d)));\n        },\n        next: function (d, val) {\n            return val > later.Y.val(d) && val <= later.Y.extent()[1] ? later.date.next(val) : later.NEVER;\n        },\n        prev: function (d, val) {\n            return val < later.Y.val(d) && val >= later.Y.extent()[0] ? later.date.prev(val) : later.NEVER;\n        }\n    };\n    later.fullDate = later.fd = {\n        name: \"full date\",\n        range: 1,\n        val: function (d) {\n            return d.fd || (d.fd = d.getTime());\n        },\n        isValid: function (d, val) {\n            return later.fd.val(d) === val;\n        },\n        extent: function () {\n            return [0, 3250368e7];\n        },\n        start: function (d) {\n            return d;\n        },\n        end: function (d) {\n            return d;\n        },\n        next: function (d, val) {\n            return later.fd.val(d) < val ? new Date(val) : later.NEVER;\n        },\n        prev: function (d, val) {\n            return later.fd.val(d) > val ? new Date(val) : later.NEVER;\n        }\n    };\n    later.modifier = {};\n    later.modifier.after = later.modifier.a = function (constraint, values) {\n        var value = values[0];\n        return {\n            name: \"after \" + constraint.name,\n            range: (constraint.extent(new Date())[1] - value) * constraint.range,\n            val: constraint.val,\n            isValid: function (d, val) {\n                return this.val(d) >= value;\n            },\n            extent: constraint.extent,\n            start: constraint.start,\n            end: constraint.end,\n            next: function (startDate, val) {\n                if (val != value)\n                    val = constraint.extent(startDate)[0];\n                return constraint.next(startDate, val);\n            },\n            prev: function (startDate, val) {\n                val = val === value ? constraint.extent(startDate)[1] : value - 1;\n                return constraint.prev(startDate, val);\n            }\n        };\n    };\n    later.modifier.before = later.modifier.b = function (constraint, values) {\n        var value = values[values.length - 1];\n        return {\n            name: \"before \" + constraint.name,\n            range: constraint.range * (value - 1),\n            val: constraint.val,\n            isValid: function (d, val) {\n                return this.val(d) < value;\n            },\n            extent: constraint.extent,\n            start: constraint.start,\n            end: constraint.end,\n            next: function (startDate, val) {\n                val = val === value ? constraint.extent(startDate)[0] : value;\n                return constraint.next(startDate, val);\n            },\n            prev: function (startDate, val) {\n                val = val === value ? value - 1 : constraint.extent(startDate)[1];\n                return constraint.prev(startDate, val);\n            }\n        };\n    };\n    later.compile = function (schedDef) {\n        var constraints = [], constraintsLen = 0, tickConstraint;\n        for (var key in schedDef) {\n            var nameParts = key.split(\"_\"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later.modifier[mod](later[name], vals) : later[name];\n            constraints.push({\n                constraint: constraint,\n                vals: vals\n            });\n            constraintsLen++;\n        }\n        constraints.sort(function (a, b) {\n            var ra = a.constraint.range, rb = b.constraint.range;\n            return rb < ra ? -1 : rb > ra ? 1 : 0;\n        });\n        tickConstraint = constraints[constraintsLen - 1].constraint;\n        function compareFn(dir) {\n            return dir === \"next\" ? function (a, b) {\n                return a.getTime() > b.getTime();\n            } : function (a, b) {\n                return b.getTime() > a.getTime();\n            };\n        }\n        return {\n            start: function (dir, startDate) {\n                var next = startDate, nextVal = later.array[dir], maxAttempts = 1e3, done;\n                while (maxAttempts-- && !done && next) {\n                    done = true;\n                    for (var i = 0; i < constraintsLen; i++) {\n                        var constraint = constraints[i].constraint, curVal = constraint.val(next), extent = constraint.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);\n                        if (!constraint.isValid(next, newVal)) {\n                            next = constraint[dir](next, newVal);\n                            done = false;\n                            break;\n                        }\n                    }\n                }\n                if (next !== later.NEVER) {\n                    next = dir === \"next\" ? tickConstraint.start(next) : tickConstraint.end(next);\n                }\n                return next;\n            },\n            end: function (dir, startDate) {\n                var result, nextVal = later.array[dir + \"Invalid\"], compare = compareFn(dir);\n                for (var i = constraintsLen - 1; i >= 0; i--) {\n                    var constraint = constraints[i].constraint, curVal = constraint.val(startDate), extent = constraint.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;\n                    if (newVal !== undefined) {\n                        next = constraint[dir](startDate, newVal);\n                        if (next && (!result || compare(result, next))) {\n                            result = next;\n                        }\n                    }\n                }\n                return result;\n            },\n            tick: function (dir, date) {\n                return new Date(dir === \"next\" ? tickConstraint.end(date).getTime() + later.SEC : tickConstraint.start(date).getTime() - later.SEC);\n            },\n            // PATCH\n            tickSafe: function (dir, date) {\n                return dir === \"next\"\n                    ? diffSecond(tickConstraint.end(date), 1)\n                    : diffSecond(tickConstraint.start(date), -1)\n                ;\n            },\n            // EOF PATCH\n            tickStart: function (date) {\n                return tickConstraint.start(date);\n            }\n        };\n    };\n    later.schedule = function (sched) {\n        if (!sched)\n            throw new Error(\"Missing schedule definition.\");\n        if (!sched.schedules)\n            throw new Error(\"Definition must include at least one schedule.\");\n        var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;\n        for (var i = 0; i < schedulesLen; i++) {\n            schedules.push(later.compile(sched.schedules[i]));\n        }\n        for (var j = 0; j < exceptionsLen; j++) {\n            exceptions.push(later.compile(sched.exceptions[j]));\n        }\n        function getInstances(dir, count, startDate, endDate, isRange) {\n            var compare = compareFn(dir), loopCount = count, maxAttempts = 1e6, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === \"next\", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;\n            startDate = startDate ? new Date(startDate) : new Date();\n            if (!startDate || !startDate.getTime())\n                throw new Error(\"Invalid start date.\");\n            setNextStarts(dir, schedules, schedStarts, startDate);\n            setRangeStarts(dir, exceptions, exceptStarts, startDate);\n            while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {\n                if (endDate && compare(next, endDate)) {\n                    break;\n                }\n                if (exceptionsLen) {\n                    updateRangeStarts(dir, exceptions, exceptStarts, next);\n                    if (end = calcRangeOverlap(dir, exceptStarts, next)) {\n                        updateNextStarts(dir, schedules, schedStarts, end);\n                        continue;\n                    }\n                }\n                if (isRange) {\n                    var maxEndDate = calcMaxEndDate(exceptStarts, compare);\n                    end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);\n                    var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : undefined] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later.SEC) : end.getTime() + later.SEC) : undefined, new Date(Math.min(startDate, next.getTime() + later.SEC))];\n                    if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {\n                        lastResult[rEnd] = r[rEnd];\n                        loopCount++;\n                    }\n                    else {\n                        lastResult = r;\n                        results.push(lastResult);\n                    }\n                    if (!end)\n                        break;\n                    updateNextStarts(dir, schedules, schedStarts, end);\n                }\n                else {\n                    results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));\n                    tickStarts(dir, schedules, schedStarts, next);\n                }\n                loopCount--;\n            }\n            for (var i = 0, len = results.length; i < len; i++) {\n                var result = results[i];\n                results[i] = Object.prototype.toString.call(result) === \"[object Array]\" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);\n            }\n            return results.length === 0 ? later.NEVER : count === 1 ? results[0] : results;\n        }\n        function cleanDate(d) {\n            if (d instanceof Date && !isNaN(d.valueOf())) {\n                return new Date(d);\n            }\n            return undefined;\n        }\n        function setNextStarts(dir, schedArr, startsArr, startDate) {\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                startsArr[i] = schedArr[i].start(dir, startDate);\n            }\n        }\n        function updateNextStarts(dir, schedArr, startsArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (startsArr[i] && !compare(startsArr[i], startDate)) {\n                    startsArr[i] = schedArr[i].start(dir, startDate);\n                }\n            }\n        }\n        function setRangeStarts(dir, schedArr, rangesArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                var nextStart = schedArr[i].start(dir, startDate);\n                if (!nextStart) {\n                    rangesArr[i] = later.NEVER;\n                }\n                else {\n                    rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n                }\n            }\n        }\n        function updateRangeStarts(dir, schedArr, rangesArr, startDate) {\n            var compare = compareFn(dir);\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (rangesArr[i] && !compare(rangesArr[i][0], startDate)) {\n                    var nextStart = schedArr[i].start(dir, startDate);\n                    if (!nextStart) {\n                        rangesArr[i] = later.NEVER;\n                    }\n                    else {\n                        rangesArr[i] = [nextStart, schedArr[i].end(dir, nextStart)];\n                    }\n                }\n            }\n        }\n        function tickStarts(dir, schedArr, startsArr, startDate) {\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n                    // PATCH\n                    const newStart = schedArr[i].start(dir, schedArr[i].tick(dir, startDate));\n\n                    // if the calculated `newStart` is the same as previous, this is probably\n                    // an endless loop caused by the DST shift (the browser won't halt because later.js\n                    // has a limit of 100000 iterations, but the calculated schedules will be all wrong)\n                    if (newStart !== later.NEVER && newStart.getTime() === startsArr[i].getTime()) {\n                        // in such case we use our own \"safe\" implementation of the \"tick\" method\n                        // which performs symbolic date manipulation\n                        // (instead of advancing on milliseconds since epoch timeaxis)\n                        // the former seems to be slower, that's why we only switch to it\n                        // in the case of infinite loop\n                        startsArr[i] = schedArr[i].start(dir, schedArr[i].tickSafe(dir, startDate));\n                    } else {\n                        startsArr[i] = newStart\n                    }\n                    // EOF PATCH\n                }\n            }\n        }\n        function getStart(schedArr, startsArr, startDate, minEndDate) {\n            var result;\n            for (var i = 0, len = startsArr.length; i < len; i++) {\n                if (startsArr[i] && startsArr[i].getTime() === startDate.getTime()) {\n                    var start = schedArr[i].tickStart(startDate);\n                    if (minEndDate && start < minEndDate) {\n                        return minEndDate;\n                    }\n                    if (!result || start > result) {\n                        result = start;\n                    }\n                }\n            }\n            return result;\n        }\n        function calcRangeOverlap(dir, rangesArr, startDate) {\n            var compare = compareFn(dir), result;\n            for (var i = 0, len = rangesArr.length; i < len; i++) {\n                var range = rangesArr[i];\n                if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {\n                    if (!result || compare(range[1], result)) {\n                        result = range[1];\n                    }\n                }\n            }\n            return result;\n        }\n        function calcMaxEndDate(exceptsArr, compare) {\n            var result;\n            for (var i = 0, len = exceptsArr.length; i < len; i++) {\n                if (exceptsArr[i] && (!result || compare(result, exceptsArr[i][0]))) {\n                    result = exceptsArr[i][0];\n                }\n            }\n            return result;\n        }\n        function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {\n            var compare = compareFn(dir), result;\n            for (var i = 0, len = schedArr.length; i < len; i++) {\n                var start = startsArr[i];\n                if (start && start.getTime() === startDate.getTime()) {\n                    var end = schedArr[i].end(dir, start);\n                    if (maxEndDate && (!end || compare(end, maxEndDate))) {\n                        return maxEndDate;\n                    }\n                    if (!result || compare(end, result)) {\n                        result = end;\n                    }\n                }\n            }\n            return result;\n        }\n        function compareFn(dir) {\n            return dir === \"next\" ? function (a, b) {\n                return !b || a.getTime() > b.getTime();\n            } : function (a, b) {\n                return !a || b.getTime() > a.getTime();\n            };\n        }\n        function findNext(arr, compare) {\n            var next = arr[0];\n            for (var i = 1, len = arr.length; i < len; i++) {\n                if (arr[i] && compare(next, arr[i])) {\n                    next = arr[i];\n                }\n            }\n            return next;\n        }\n        return {\n            isValid: function (d) {\n                return getInstances(\"next\", 1, d, d) !== later.NEVER;\n            },\n            next: function (count, startDate, endDate) {\n                return getInstances(\"next\", count || 1, startDate, endDate);\n            },\n            prev: function (count, startDate, endDate) {\n                return getInstances(\"prev\", count || 1, startDate, endDate);\n            },\n            nextRange: function (count, startDate, endDate) {\n                return getInstances(\"next\", count || 1, startDate, endDate, true);\n            },\n            prevRange: function (count, startDate, endDate) {\n                return getInstances(\"prev\", count || 1, startDate, endDate, true);\n            }\n        };\n    };\n    later.setTimeout = function (fn, sched) {\n        var s = later.schedule(sched), t;\n        if (fn) {\n            scheduleTimeout();\n        }\n        function scheduleTimeout() {\n            var now = Date.now(), next = s.next(2, now);\n            if (!next[0]) {\n                t = undefined;\n                return;\n            }\n            var diff = next[0].getTime() - now;\n            if (diff < 1e3) {\n                diff = next[1] ? next[1].getTime() - now : 1e3;\n            }\n            if (diff < 2147483647) {\n                t = setTimeout(fn, diff);\n            }\n            else {\n                t = setTimeout(scheduleTimeout, 2147483647);\n            }\n        }\n        return {\n            isDone: function () {\n                return !t;\n            },\n            clear: function () {\n                clearTimeout(t);\n            }\n        };\n    };\n    later.setInterval = function (fn, sched) {\n        if (!fn) {\n            return;\n        }\n        var t = later.setTimeout(scheduleTimeout, sched), done = t.isDone();\n        function scheduleTimeout() {\n            if (!done) {\n                fn();\n                t = later.setTimeout(scheduleTimeout, sched);\n            }\n        }\n        return {\n            isDone: function () {\n                return t.isDone();\n            },\n            clear: function () {\n                done = true;\n                t.clear();\n            }\n        };\n    };\n    later.date = {};\n    later.date.timezone = function (useLocalTime) {\n        later.date.build = useLocalTime ? function (Y, M, D, h, m, s) {\n            return new Date(Y, M, D, h, m, s);\n        } : function (Y, M, D, h, m, s) {\n            return new Date(Date.UTC(Y, M, D, h, m, s));\n        };\n        var get = useLocalTime ? \"get\" : \"getUTC\", d = Date.prototype;\n        later.date.getYear = d[get + \"FullYear\"];\n        later.date.getMonth = d[get + \"Month\"];\n        later.date.getDate = d[get + \"Date\"];\n        later.date.getDay = d[get + \"Day\"];\n        later.date.getHour = d[get + \"Hours\"];\n        later.date.getMin = d[get + \"Minutes\"];\n        later.date.getSec = d[get + \"Seconds\"];\n        later.date.isUTC = !useLocalTime;\n    };\n    later.date.UTC = function () {\n        later.date.timezone(false);\n    };\n    later.date.localTime = function () {\n        later.date.timezone(true);\n    };\n    later.date.UTC();\n    later.SEC = 1e3;\n    later.MIN = later.SEC * 60;\n    later.HOUR = later.MIN * 60;\n    later.DAY = later.HOUR * 24;\n    later.WEEK = later.DAY * 7;\n    later.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n    later.NEVER = 0;\n    later.date.next = function (Y, M, D, h, m, s) {\n        return later.date.build(Y, M !== undefined ? M - 1 : 0, D !== undefined ? D : 1, h || 0, m || 0, s || 0);\n    };\n    later.date.nextRollover = function (d, val, constraint, period) {\n        var cur = constraint.val(d), max = constraint.extent(d)[1];\n        return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later.SEC) : period.start(d);\n    };\n    later.date.prev = function (Y, M, D, h, m, s) {\n        var len = arguments.length;\n        M = len < 2 ? 11 : M - 1;\n        D = len < 3 ? later.D.extent(later.date.next(Y, M + 1))[1] : D;\n        h = len < 4 ? 23 : h;\n        m = len < 5 ? 59 : m;\n        s = len < 6 ? 59 : s;\n        return later.date.build(Y, M, D, h, m, s);\n    };\n    later.date.prevRollover = function (d, val, constraint, period) {\n        var cur = constraint.val(d);\n        return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);\n    };\n    later.parse = {};\n    later.parse.cron = function (expr, hasSeconds) {\n        var NAMES = {\n            JAN: 1,\n            FEB: 2,\n            MAR: 3,\n            APR: 4,\n            MAY: 5,\n            JUN: 6,\n            JUL: 7,\n            AUG: 8,\n            SEP: 9,\n            OCT: 10,\n            NOV: 11,\n            DEC: 12,\n            SUN: 1,\n            MON: 2,\n            TUE: 3,\n            WED: 4,\n            THU: 5,\n            FRI: 6,\n            SAT: 7\n        };\n        var REPLACEMENTS = {\n            \"* * * * * *\": \"0/1 * * * * *\",\n            \"@YEARLY\": \"0 0 1 1 *\",\n            \"@ANNUALLY\": \"0 0 1 1 *\",\n            \"@MONTHLY\": \"0 0 1 * *\",\n            \"@WEEKLY\": \"0 0 * * 0\",\n            \"@DAILY\": \"0 0 * * *\",\n            \"@HOURLY\": \"0 * * * *\"\n        };\n        var FIELDS = {\n            s: [0, 0, 59],\n            m: [1, 0, 59],\n            h: [2, 0, 23],\n            D: [3, 1, 31],\n            M: [4, 1, 12],\n            Y: [6, 1970, 2099],\n            d: [5, 1, 7, 1]\n        };\n        function getValue(value, offset, max) {\n            return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);\n        }\n        function cloneSchedule(sched) {\n            var clone = {}, field;\n            for (field in sched) {\n                if (field !== \"dc\" && field !== \"d\") {\n                    clone[field] = sched[field].slice(0);\n                }\n            }\n            return clone;\n        }\n        function add(sched, name, min, max, inc) {\n            var i = min;\n            if (!sched[name]) {\n                sched[name] = [];\n            }\n            while (i <= max) {\n                if (sched[name].indexOf(i) < 0) {\n                    sched[name].push(i);\n                }\n                i += inc || 1;\n            }\n            sched[name].sort(function (a, b) {\n                return a - b;\n            });\n        }\n        function addHash(schedules, curSched, value, hash) {\n            if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {\n                schedules.push(cloneSchedule(curSched));\n                curSched = schedules[schedules.length - 1];\n            }\n            add(curSched, \"d\", value, value);\n            add(curSched, \"dc\", hash, hash);\n        }\n        function addWeekday(s, curSched, value) {\n            var except1 = {}, except2 = {};\n            if (value === 1) {\n                add(curSched, \"D\", 1, 3);\n                add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n                add(except1, \"D\", 2, 2);\n                add(except1, \"d\", NAMES.TUE, NAMES.FRI);\n                add(except2, \"D\", 3, 3);\n                add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n            }\n            else {\n                add(curSched, \"D\", value - 1, value + 1);\n                add(curSched, \"d\", NAMES.MON, NAMES.FRI);\n                add(except1, \"D\", value - 1, value - 1);\n                add(except1, \"d\", NAMES.MON, NAMES.THU);\n                add(except2, \"D\", value + 1, value + 1);\n                add(except2, \"d\", NAMES.TUE, NAMES.FRI);\n            }\n            s.exceptions.push(except1);\n            s.exceptions.push(except2);\n        }\n        function addRange(item, curSched, name, min, max, offset) {\n            var incSplit = item.split(\"/\"), inc = +incSplit[1], range = incSplit[0];\n            if (range !== \"*\" && range !== \"0\") {\n                var rangeSplit = range.split(\"-\");\n                min = getValue(rangeSplit[0], offset, max);\n                max = getValue(rangeSplit[1], offset, max) || max;\n            }\n            add(curSched, name, min, max, inc);\n        }\n        function parse(item, s, name, min, max, offset) {\n            var value, split, schedules = s.schedules, curSched = schedules[schedules.length - 1];\n            if (item === \"L\") {\n                item = min - 1;\n            }\n            if ((value = getValue(item, offset, max)) !== null) {\n                add(curSched, name, value, value);\n            }\n            else if ((value = getValue(item.replace(\"W\", \"\"), offset, max)) !== null) {\n                addWeekday(s, curSched, value);\n            }\n            else if ((value = getValue(item.replace(\"L\", \"\"), offset, max)) !== null) {\n                addHash(schedules, curSched, value, min - 1);\n            }\n            else if ((split = item.split(\"#\")).length === 2) {\n                value = getValue(split[0], offset, max);\n                addHash(schedules, curSched, value, getValue(split[1]));\n            }\n            else {\n                addRange(item, curSched, name, min, max, offset);\n            }\n        }\n        function isHash(item) {\n            return item.indexOf(\"#\") > -1 || item.indexOf(\"L\") > 0;\n        }\n        function itemSorter(a, b) {\n            return isHash(a) && !isHash(b) ? 1 : a - b;\n        }\n        function parseExpr(expr) {\n            var schedule = {\n                schedules: [{}],\n                exceptions: []\n            }, components = expr.replace(/(\\s)+/g, \" \").split(\" \"), field, f, component, items;\n            for (field in FIELDS) {\n                f = FIELDS[field];\n                component = components[f[0]];\n                if (component && component !== \"*\" && component !== \"?\") {\n                    items = component.split(\",\").sort(itemSorter);\n                    var i, length = items.length;\n                    for (i = 0; i < length; i++) {\n                        parse(items[i], schedule, field, f[1], f[2], f[3]);\n                    }\n                }\n            }\n            return schedule;\n        }\n        function prepareExpr(expr) {\n            var prepared = expr.toUpperCase();\n            return REPLACEMENTS[prepared] || prepared;\n        }\n        var e = prepareExpr(expr);\n        return parseExpr(hasSeconds ? e : \"0 \" + e);\n    };\n    later.parse.recur = function () {\n        var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every, modifier, applyMin, applyMax, i, last;\n        function add(name, min, max) {\n            name = modifier ? name + \"_\" + modifier : name;\n            if (!cur) {\n                curArr.push({});\n                cur = curArr[0];\n            }\n            if (!cur[name]) {\n                cur[name] = [];\n            }\n            curName = cur[name];\n            if (every) {\n                values = [];\n                for (i = min; i <= max; i += every) {\n                    values.push(i);\n                }\n                last = {\n                    n: name,\n                    x: every,\n                    c: curName.length,\n                    m: max\n                };\n            }\n            values = applyMin ? [min] : applyMax ? [max] : values;\n            var length = values.length;\n            for (i = 0; i < length; i += 1) {\n                var val = values[i];\n                if (curName.indexOf(val) < 0) {\n                    curName.push(val);\n                }\n            }\n            values = every = modifier = applyMin = applyMax = 0;\n        }\n        return {\n            schedules: schedules,\n            exceptions: exceptions,\n            on: function () {\n                values = arguments[0] instanceof Array ? arguments[0] : arguments;\n                return this;\n            },\n            every: function (x) {\n                every = x || 1;\n                return this;\n            },\n            after: function (x) {\n                modifier = \"a\";\n                values = [x];\n                return this;\n            },\n            before: function (x) {\n                modifier = \"b\";\n                values = [x];\n                return this;\n            },\n            first: function () {\n                applyMin = 1;\n                return this;\n            },\n            last: function () {\n                applyMax = 1;\n                return this;\n            },\n            time: function () {\n                for (var i = 0, len = values.length; i < len; i++) {\n                    var split = values[i].split(\":\");\n                    if (split.length < 3)\n                        split.push(0);\n                    values[i] = +split[0] * 3600 + +split[1] * 60 + +split[2];\n                }\n                add(\"t\");\n                return this;\n            },\n            second: function () {\n                add(\"s\", 0, 59);\n                return this;\n            },\n            minute: function () {\n                add(\"m\", 0, 59);\n                return this;\n            },\n            hour: function () {\n                add(\"h\", 0, 23);\n                return this;\n            },\n            dayOfMonth: function () {\n                add(\"D\", 1, applyMax ? 0 : 31);\n                return this;\n            },\n            dayOfWeek: function () {\n                add(\"d\", 1, 7);\n                return this;\n            },\n            onWeekend: function () {\n                values = [1, 7];\n                return this.dayOfWeek();\n            },\n            onWeekday: function () {\n                values = [2, 3, 4, 5, 6];\n                return this.dayOfWeek();\n            },\n            dayOfWeekCount: function () {\n                add(\"dc\", 1, applyMax ? 0 : 5);\n                return this;\n            },\n            dayOfYear: function () {\n                add(\"dy\", 1, applyMax ? 0 : 366);\n                return this;\n            },\n            weekOfMonth: function () {\n                add(\"wm\", 1, applyMax ? 0 : 5);\n                return this;\n            },\n            weekOfYear: function () {\n                add(\"wy\", 1, applyMax ? 0 : 53);\n                return this;\n            },\n            month: function () {\n                add(\"M\", 1, 12);\n                return this;\n            },\n            year: function () {\n                add(\"Y\", 1970, 2450);\n                return this;\n            },\n            fullDate: function () {\n                for (var i = 0, len = values.length; i < len; i++) {\n                    values[i] = values[i].getTime();\n                }\n                add(\"fd\");\n                return this;\n            },\n            customModifier: function (id, vals) {\n                var custom = later.modifier[id];\n                if (!custom)\n                    throw new Error(\"Custom modifier \" + id + \" not recognized!\");\n                modifier = id;\n                values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];\n                return this;\n            },\n            customPeriod: function (id) {\n                var custom = later[id];\n                if (!custom)\n                    throw new Error(\"Custom time period \" + id + \" not recognized!\");\n                add(id, custom.extent(new Date())[0], custom.extent(new Date())[1]);\n                return this;\n            },\n            startingOn: function (start) {\n                return this.between(start, last.m);\n            },\n            between: function (start, end) {\n                cur[last.n] = cur[last.n].splice(0, last.c);\n                every = last.x;\n                add(last.n, start, end);\n                return this;\n            },\n            and: function () {\n                cur = curArr[curArr.push({}) - 1];\n                return this;\n            },\n            except: function () {\n                curArr = exceptions;\n                cur = null;\n                return this;\n            }\n        };\n    };\n    later.parse.text = function (str) {\n        var recur = later.parse.recur, pos = 0, input = \"\", error;\n        var TOKENTYPES = {\n            eof: /^$/,\n            fullDate: /^(\\d\\d\\d\\d-\\d\\d-\\d\\dt\\d\\d:\\d\\d:\\d\\d)\\b/,\n            rank: /^((\\d\\d\\d\\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\\b/,\n            time: /^((([0]?[1-9]|1[0-2]):[0-5]\\d(\\s)?(am|pm))|(([0]?\\d|1\\d|2[0-3]):[0-5]\\d))\\b/,\n            dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\\b/,\n            monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\\b/,\n            yearIndex: /^(\\d\\d\\d\\d)\\b/,\n            every: /^every\\b/,\n            after: /^after\\b/,\n            before: /^before\\b/,\n            second: /^(s|sec(ond)?(s)?)\\b/,\n            minute: /^(m|min(ute)?(s)?)\\b/,\n            hour: /^(h|hour(s)?)\\b/,\n            day: /^(day(s)?( of the month)?)\\b/,\n            dayInstance: /^day instance\\b/,\n            dayOfWeek: /^day(s)? of the week\\b/,\n            dayOfYear: /^day(s)? of the year\\b/,\n            weekOfYear: /^week(s)?( of the year)?\\b/,\n            weekOfMonth: /^week(s)? of the month\\b/,\n            weekday: /^weekday\\b/,\n            weekend: /^weekend\\b/,\n            month: /^month(s)?\\b/,\n            year: /^year(s)?\\b/,\n            between: /^between (the)?\\b/,\n            start: /^(start(ing)? (at|on( the)?)?)\\b/,\n            at: /^(at|@)\\b/,\n            and: /^(,|and\\b)/,\n            except: /^(except\\b)/,\n            also: /(also)\\b/,\n            first: /^(first)\\b/,\n            last: /^last\\b/,\n            \"in\": /^in\\b/,\n            of: /^of\\b/,\n            onthe: /^on the\\b/,\n            on: /^on\\b/,\n            through: /(-|^(to|through)\\b)/\n        };\n        var NAMES = {\n            jan: 1,\n            feb: 2,\n            mar: 3,\n            apr: 4,\n            may: 5,\n            jun: 6,\n            jul: 7,\n            aug: 8,\n            sep: 9,\n            oct: 10,\n            nov: 11,\n            dec: 12,\n            sun: 1,\n            mon: 2,\n            tue: 3,\n            wed: 4,\n            thu: 5,\n            fri: 6,\n            sat: 7,\n            \"1st\": 1,\n            fir: 1,\n            \"2nd\": 2,\n            sec: 2,\n            \"3rd\": 3,\n            thi: 3,\n            \"4th\": 4,\n            \"for\": 4\n        };\n        function t(start, end, text, type) {\n            return {\n                startPos: start,\n                endPos: end,\n                text: text,\n                type: type\n            };\n        }\n        function peek(expected) {\n            var scanTokens = expected instanceof Array ? expected : [expected], whiteSpace = /\\s+/, token, curInput, m, scanToken, start, len;\n            scanTokens.push(whiteSpace);\n            start = pos;\n            while (!token || token.type === whiteSpace) {\n                len = -1;\n                curInput = input.substring(start);\n                token = t(start, start, input.split(whiteSpace)[0]);\n                var i, length = scanTokens.length;\n                for (i = 0; i < length; i++) {\n                    scanToken = scanTokens[i];\n                    m = scanToken.exec(curInput);\n                    if (m && m.index === 0 && m[0].length > len) {\n                        len = m[0].length;\n                        token = t(start, start + len, curInput.substring(0, len), scanToken);\n                    }\n                }\n                if (token.type === whiteSpace) {\n                    start = token.endPos;\n                }\n            }\n            return token;\n        }\n        function scan(expectedToken) {\n            var token = peek(expectedToken);\n            pos = token.endPos;\n            return token;\n        }\n        function parseThroughExpr(tokenType) {\n            var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];\n            for (var i = start; i <= end; i++) {\n                nums.push(i);\n            }\n            return nums;\n        }\n        function parseRanges(tokenType) {\n            var nums = parseThroughExpr(tokenType);\n            while (checkAndParse(TOKENTYPES.and)) {\n                nums = nums.concat(parseThroughExpr(tokenType));\n            }\n            return nums;\n        }\n        function parseEvery(r) {\n            var num, period, start, end;\n            if (checkAndParse(TOKENTYPES.weekend)) {\n                r.on(NAMES.sun, NAMES.sat).dayOfWeek();\n            }\n            else if (checkAndParse(TOKENTYPES.weekday)) {\n                r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();\n            }\n            else {\n                num = parseTokenValue(TOKENTYPES.rank);\n                r.every(num);\n                period = parseTimePeriod(r);\n                if (checkAndParse(TOKENTYPES.start)) {\n                    num = parseTokenValue(TOKENTYPES.rank);\n                    r.startingOn(num);\n                    parseToken(period.type);\n                }\n                else if (checkAndParse(TOKENTYPES.between)) {\n                    start = parseTokenValue(TOKENTYPES.rank);\n                    if (checkAndParse(TOKENTYPES.and)) {\n                        end = parseTokenValue(TOKENTYPES.rank);\n                        r.between(start, end);\n                    }\n                }\n            }\n        }\n        function parseOnThe(r) {\n            if (checkAndParse(TOKENTYPES.first)) {\n                r.first();\n            }\n            else if (checkAndParse(TOKENTYPES.last)) {\n                r.last();\n            }\n            else {\n                r.on(parseRanges(TOKENTYPES.rank));\n            }\n            parseTimePeriod(r);\n        }\n        function parseScheduleExpr(str) {\n            pos = 0;\n            input = str;\n            error = -1;\n            var r = recur();\n            while (pos < input.length && error < 0) {\n                var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES[\"in\"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);\n                switch (token.type) {\n                    case TOKENTYPES.every:\n                        parseEvery(r);\n                        break;\n                    case TOKENTYPES.after:\n                        if (peek(TOKENTYPES.time).type !== undefined) {\n                            r.after(parseTokenValue(TOKENTYPES.time));\n                            r.time();\n                        }\n                        else if (peek(TOKENTYPES.fullDate).type !== undefined) {\n                            r.after(parseTokenValue(TOKENTYPES.fullDate));\n                            r.fullDate();\n                        }\n                        else {\n                            r.after(parseTokenValue(TOKENTYPES.rank));\n                            parseTimePeriod(r);\n                        }\n                        break;\n                    case TOKENTYPES.before:\n                        if (peek(TOKENTYPES.time).type !== undefined) {\n                            r.before(parseTokenValue(TOKENTYPES.time));\n                            r.time();\n                        }\n                        else if (peek(TOKENTYPES.fullDate).type !== undefined) {\n                            r.before(parseTokenValue(TOKENTYPES.fullDate));\n                            r.fullDate();\n                        }\n                        else {\n                            r.before(parseTokenValue(TOKENTYPES.rank));\n                            parseTimePeriod(r);\n                        }\n                        break;\n                    case TOKENTYPES.onthe:\n                        parseOnThe(r);\n                        break;\n                    case TOKENTYPES.on:\n                        r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();\n                        break;\n                    case TOKENTYPES.of:\n                        r.on(parseRanges(TOKENTYPES.monthName)).month();\n                        break;\n                    case TOKENTYPES[\"in\"]:\n                        r.on(parseRanges(TOKENTYPES.yearIndex)).year();\n                        break;\n                    case TOKENTYPES.at:\n                        r.on(parseTokenValue(TOKENTYPES.time)).time();\n                        while (checkAndParse(TOKENTYPES.and)) {\n                            r.on(parseTokenValue(TOKENTYPES.time)).time();\n                        }\n                        break;\n                    case TOKENTYPES.and:\n                        break;\n                    case TOKENTYPES.also:\n                        r.and();\n                        break;\n                    case TOKENTYPES.except:\n                        r.except();\n                        break;\n                    default:\n                        error = pos;\n                }\n            }\n            return {\n                schedules: r.schedules,\n                exceptions: r.exceptions,\n                error: error\n            };\n        }\n        function parseTimePeriod(r) {\n            var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);\n            switch (timePeriod.type) {\n                case TOKENTYPES.second:\n                    r.second();\n                    break;\n                case TOKENTYPES.minute:\n                    r.minute();\n                    break;\n                case TOKENTYPES.hour:\n                    r.hour();\n                    break;\n                case TOKENTYPES.dayOfYear:\n                    r.dayOfYear();\n                    break;\n                case TOKENTYPES.dayOfWeek:\n                    r.dayOfWeek();\n                    break;\n                case TOKENTYPES.dayInstance:\n                    r.dayOfWeekCount();\n                    break;\n                case TOKENTYPES.day:\n                    r.dayOfMonth();\n                    break;\n                case TOKENTYPES.weekOfMonth:\n                    r.weekOfMonth();\n                    break;\n                case TOKENTYPES.weekOfYear:\n                    r.weekOfYear();\n                    break;\n                case TOKENTYPES.month:\n                    r.month();\n                    break;\n                case TOKENTYPES.year:\n                    r.year();\n                    break;\n                default:\n                    error = pos;\n            }\n            return timePeriod;\n        }\n        function checkAndParse(tokenType) {\n            var found = peek(tokenType).type === tokenType;\n            if (found) {\n                scan(tokenType);\n            }\n            return found;\n        }\n        function parseToken(tokenType) {\n            var t = scan(tokenType);\n            if (t.type) {\n                t.text = convertString(t.text, tokenType);\n            }\n            else {\n                error = pos;\n            }\n            return t;\n        }\n        function parseTokenValue(tokenType) {\n            return parseToken(tokenType).text;\n        }\n        function convertString(str, tokenType) {\n            var output = str;\n            switch (tokenType) {\n                case TOKENTYPES.time:\n                    var parts = str.split(/(:|am|pm)/), hour = parts[3] === \"pm\" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min = parts[2].trim();\n                    output = (hour.length === 1 ? \"0\" : \"\") + hour + \":\" + min;\n                    break;\n                case TOKENTYPES.rank:\n                    output = parseInt(/^\\d+/.exec(str)[0], 10);\n                    break;\n                case TOKENTYPES.monthName:\n                case TOKENTYPES.dayName:\n                    output = NAMES[str.substring(0, 3)];\n                    break;\n                case TOKENTYPES.fullDate:\n                    output = new Date(str.toUpperCase());\n                    break;\n                }\n            return output;\n        }\n        return parseScheduleExpr(str.toLowerCase());\n    };\n    return later;\n})();\n// Set the local time mode for \"later\" library\nlater.date.localTime();\nexport default later;\n","//---------------------------------------------------------------------------------------------------------------------\n/**\n * Given a single `Iterable`, returns an array of 2 iterables, mirroring the original one (which should not be used anymore).\n *\n * For example:\n *\n *     const gen = function* () { yield 1; yield 2; yield 3 }\n *\n *     const [ iterable1, iterable2 ] = split(gen())\n *     const [ iter1, iter2 ] = [\n *         iterable1[ Symbol.iterator ](),\n *         iterable2[ Symbol.iterator ]()\n *     ]\n *\n *     iter1.next() // 1\n *     iter2.next() // 1\n *     iter2.next() // 2\n *     iter2.next() // 3\n *     iter1.next() // 2\n *     iter1.next() // 3\n *     iter1.next() // done\n *     iter2.next() // done\n *\n * @param iterable\n */\nexport function split(iterable) {\n    const gen1Pending = [];\n    const gen2Pending = [];\n    let iterator;\n    const gen1 = function* () {\n        if (!iterator)\n            iterator = iterable[Symbol.iterator]();\n        while (true) {\n            if (gen1Pending.length) {\n                yield* gen1Pending;\n                gen1Pending.length = 0;\n            }\n            if (!iterator)\n                break;\n            const { value, done } = iterator.next();\n            if (done) {\n                iterator = null;\n                iterable = null;\n                break;\n            }\n            gen2Pending.push(value);\n            yield value;\n        }\n    };\n    const gen2 = function* () {\n        if (!iterator)\n            iterator = iterable[Symbol.iterator]();\n        while (true) {\n            if (gen2Pending.length) {\n                yield* gen2Pending;\n                gen2Pending.length = 0;\n            }\n            if (!iterator)\n                break;\n            const { value, done } = iterator.next();\n            if (done) {\n                iterator = null;\n                iterable = null;\n                break;\n            }\n            gen1Pending.push(value);\n            yield value;\n        }\n    };\n    return [gen1(), gen2()];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* inBatchesBySize(iterator, batchSize) {\n    if (batchSize < 0)\n        throw new Error(\"Batch size needs to a natural number\");\n    batchSize = batchSize | 0;\n    const runningBatch = [];\n    for (const el of iterator) {\n        if (runningBatch.length === batchSize) {\n            yield runningBatch;\n            runningBatch.length = 0;\n        }\n        runningBatch.push(el);\n    }\n    if (runningBatch.length > 0)\n        yield runningBatch;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* filter(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* drop(iterator, howMany) {\n    let i = 0;\n    for (const el of iterator) {\n        if (++i > howMany)\n            yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function every(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (!func(el, i++))\n            return false;\n    }\n    return true;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function some(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            return true;\n    }\n    return false;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* map(iterator, func) {\n    let i = 0;\n    for (const el of iterator)\n        yield func(el, i++);\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function reduce(iterator, func, initialAcc) {\n    let i = 0;\n    let acc = initialAcc;\n    for (const el of iterator) {\n        acc = func(acc, el, i++);\n    }\n    return acc;\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* uniqueOnly(iterator) {\n    const seen = new Set();\n    for (const el of iterator) {\n        if (!seen.has(el)) {\n            seen.add(el);\n            yield el;\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* uniqueOnlyBy(iterator, func) {\n    const seen = new Set();\n    for (const el of iterator) {\n        const uniqueBy = func(el);\n        if (!seen.has(uniqueBy)) {\n            seen.add(uniqueBy);\n            yield el;\n        }\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* reverse(iterator) {\n    const all = Array.from(iterator);\n    for (let i = all.length - 1; i >= 0; i--)\n        yield all[i];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeWhile(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            yield el;\n        else\n            return;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeUntilIncluding(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        yield el;\n        if (func(el, i++))\n            return;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* takeUntilExcluding(iterator, func) {\n    let i = 0;\n    for (const el of iterator) {\n        if (func(el, i++))\n            return;\n        yield el;\n    }\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* concat(...iterators) {\n    for (let i = 0; i < iterators.length; i++)\n        yield* iterators[i];\n}\n//---------------------------------------------------------------------------------------------------------------------\nexport function* concatIterable(iteratorsProducer) {\n    for (const iterator of iteratorsProducer)\n        yield* iterator;\n}\n//---------------------------------------------------------------------------------------------------------------------\n// just a chained syntax sugar class\n// note, that we either use a combination of `this.derive()` + this.iterable (which will clear the `this.iterable`)\n// or, use just `this` as iterable, which will also clear the iterator\n//\nexport class ChainedIteratorClass {\n    constructor(iterable) {\n        this.iterable = undefined;\n        if (!iterable)\n            throw new Error(\"Require an iterable instance for chaining\");\n        this.iterable = iterable;\n    }\n    derive(iterable) {\n        this.iterable = undefined;\n        return new ChainedIteratorClass(iterable);\n    }\n    copy() {\n        const [iter1, iter2] = split(this.iterable);\n        this.iterable = iter2;\n        return new ChainedIteratorClass(iter1);\n    }\n    split() {\n        const [iter1, iter2] = split(this.iterable);\n        return [new ChainedIteratorClass(iter1), this.derive(iter2)];\n    }\n    inBatchesBySize(batchSize) {\n        return this.derive(inBatchesBySize(this.iterable, batchSize));\n    }\n    filter(func) {\n        return this.derive(filter(this.iterable, func));\n    }\n    drop(howMany) {\n        return this.derive(drop(this.iterable, howMany));\n    }\n    map(func) {\n        return this.derive(map(this.iterable, func));\n    }\n    reduce(func, initialAcc) {\n        return reduce(this, func, initialAcc);\n    }\n    concat() {\n        //@ts-ignore\n        return this.derive(concatIterable(this.iterable));\n    }\n    uniqueOnly() {\n        return this.derive(uniqueOnly(this.iterable));\n    }\n    uniqueOnlyBy(func) {\n        return this.derive(uniqueOnlyBy(this.iterable, func));\n    }\n    every(func) {\n        return every(this, func);\n    }\n    some(func) {\n        return some(this, func);\n    }\n    takeWhile(func) {\n        return this.derive(takeWhile(this.iterable, func));\n    }\n    *[Symbol.iterator]() {\n        let iterable = this.iterable;\n        if (!iterable)\n            throw new Error(\"Chained iterator already exhausted or used to derive the new one\");\n        // practice shows, that cleaning up the iterable after yourself helps garbage collector a lot\n        this.iterable = undefined;\n        yield* iterable;\n        // yes, we really want to avoid memory leaks\n        iterable = undefined;\n    }\n    toArray() {\n        return Array.from(this);\n    }\n    sort(order) {\n        return Array.from(this).sort(order);\n    }\n    toSet() {\n        return new Set(this);\n    }\n    toMap() {\n        //@ts-ignore\n        return new Map(this);\n    }\n    // toMap<K, V> () : T extends [ K, V ] ? Map<K, V> : never  {\n    //     return new Map<K, V>(this.iterable as (T extends [ K, V ] ? Iterable<T> : never)) as (T extends [ K, V ] ? Map<K, V> : never)\n    // }\n    flush() {\n        for (const element of this) { }\n    }\n    memoize() {\n        return new MemoizedIteratorClass(this);\n    }\n}\nexport const ChainedIterator = (iterator) => new ChainedIteratorClass(iterator);\nexport const CI = ChainedIterator;\n//---------------------------------------------------------------------------------------------------------------------\nexport class MemoizedIteratorClass extends ChainedIteratorClass {\n    constructor() {\n        super(...arguments);\n        this.elements = [];\n        this.$iterator = undefined;\n    }\n    set iterable(iterable) {\n        this.$iterable = iterable;\n    }\n    get iterable() {\n        return this;\n    }\n    derive(iterable) {\n        return new ChainedIteratorClass(iterable);\n    }\n    *[Symbol.iterator]() {\n        const elements = this.elements;\n        if (this.$iterable) {\n            if (!this.$iterator)\n                this.$iterator = this.$iterable[Symbol.iterator]();\n            let iterator = this.$iterator;\n            let alreadyConsumed = elements.length;\n            // yield the 1st batch \"efficiently\"\n            if (alreadyConsumed > 0)\n                yield* elements;\n            while (true) {\n                if (elements.length > alreadyConsumed) {\n                    // wonder if `yield* elements.slice(alreadyConsumed)` is more performant or not\n                    for (let i = alreadyConsumed; i < elements.length; i++)\n                        yield elements[i];\n                    alreadyConsumed = elements.length;\n                }\n                if (!iterator)\n                    break;\n                const { value, done } = iterator.next();\n                if (done) {\n                    iterator = this.$iterator = null;\n                    this.$iterable = null;\n                }\n                else {\n                    elements.push(value);\n                    alreadyConsumed++;\n                    yield value;\n                }\n            }\n        }\n        else {\n            yield* elements;\n        }\n    }\n}\nexport const MemoizedIterator = (iterator) => new MemoizedIteratorClass(iterator);\nexport const MI = MemoizedIterator;\n","import { CI, MI } from \"../collection/Iterator.js\";\n//---------------------------------------------------------------------------------------------------------------------\nconst MixinInstanceOfProperty = Symbol('MixinIdentity');\nconst MixinStateProperty = Symbol('MixinStateProperty');\n//---------------------------------------------------------------------------------------------------------------------\nclass MixinWalkDepthState {\n    constructor() {\n        this.baseEl = undefined;\n        this.sourceEl = undefined;\n        this.$elementsByTopoLevel = undefined;\n        this.$topoLevels = undefined;\n        this.linearizedByTopoLevelsSource = MI(this.linearizedByTopoLevels());\n    }\n    static new(props) {\n        const me = new this();\n        props && Object.assign(me, props);\n        return me;\n    }\n    get topoLevels() {\n        if (this.$topoLevels !== undefined)\n            return this.$topoLevels;\n        return this.$topoLevels = this.buildTopoLevels();\n    }\n    buildTopoLevels() {\n        return Array.from(this.elementsByTopoLevel.keys()).sort((level1, level2) => level1 - level2);\n    }\n    get elementsByTopoLevel() {\n        if (this.$elementsByTopoLevel !== undefined)\n            return this.$elementsByTopoLevel;\n        return this.$elementsByTopoLevel = this.buildElementsByTopoLevel();\n    }\n    getOrCreateLevel(map, topoLevel) {\n        let elementsAtLevel = map.get(topoLevel);\n        if (!elementsAtLevel) {\n            elementsAtLevel = [];\n            map.set(topoLevel, elementsAtLevel);\n        }\n        return elementsAtLevel;\n    }\n    buildElementsByTopoLevel() {\n        let maxTopoLevel = 0;\n        const baseElements = this.baseEl ? CI(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : new Set();\n        const map = CI(this.sourceEl.requirements)\n            .map(mixin => mixin.walkDepthState.elementsByTopoLevel)\n            .concat()\n            .reduce((elementsByTopoLevel, [topoLevel, mixins]) => {\n            if (topoLevel > maxTopoLevel)\n                maxTopoLevel = topoLevel;\n            this.getOrCreateLevel(elementsByTopoLevel, topoLevel).push(mixins);\n            return elementsByTopoLevel;\n        }, new Map());\n        this.getOrCreateLevel(map, maxTopoLevel + 1).push([this.sourceEl]);\n        return CI(map).map(([level, elements]) => {\n            return [level, CI(elements).concat().uniqueOnly().filter(mixin => !baseElements.has(mixin)).sort((mixin1, mixin2) => mixin1.id - mixin2.id)];\n        }).toMap();\n    }\n    *linearizedByTopoLevels() {\n        yield* CI(this.topoLevels).map(level => this.elementsByTopoLevel.get(level)).concat();\n    }\n}\n// Note: 65535 mixins only, because of the hashing function implementation (String.fromCharCode)\nlet MIXIN_ID = 1;\n//---------------------------------------------------------------------------------------------------------------------\nexport const identity = a => class extends a {\n};\n// export type IdentityMixin<Base extends object>         = < T extends AnyConstructor<Base>>(base : T) => T\n//\n// export const IdentityMixin             = <Base extends object>() : IdentityMixin<Base> => identity\n//---------------------------------------------------------------------------------------------------------------------\nexport class ZeroBaseClass {\n}\n//---------------------------------------------------------------------------------------------------------------------\nclass MixinState {\n    constructor() {\n        this.id = MIXIN_ID++;\n        this.requirements = [];\n        this.baseClass = ZeroBaseClass;\n        this.identitySymbol = undefined;\n        this.mixinLambda = identity;\n        this.walkDepthState = undefined;\n        // private $hash               : MixinHash             = ''\n        this.$minimalClass = undefined;\n        this.name = '';\n    }\n    static new(props) {\n        const me = new this();\n        props && Object.assign(me, props);\n        me.walkDepthState = MixinWalkDepthState.new({ sourceEl: me, baseEl: getMixinState(me.baseClass) });\n        //------------------\n        const mixinLambda = me.mixinLambda;\n        const symbol = me.identitySymbol = Symbol(mixinLambda.name);\n        const mixinLambdaWrapper = Object.assign(function (base) {\n            const extendedClass = mixinLambda(base);\n            extendedClass.prototype[symbol] = true;\n            return extendedClass;\n        }, {\n            [MixinInstanceOfProperty]: symbol,\n            [MixinStateProperty]: me\n        });\n        Object.defineProperty(mixinLambdaWrapper, Symbol.hasInstance, { value: isInstanceOfStatic });\n        me.mixinLambda = mixinLambdaWrapper;\n        return me;\n    }\n    get minimalClass() {\n        if (this.$minimalClass !== undefined)\n            return this.$minimalClass;\n        return this.$minimalClass = this.buildMinimalClass();\n    }\n    // get hash () : MixinHash {\n    //     if (this.$hash !== '') return this.$hash\n    //\n    //     return this.$hash = this.buildHash()\n    // }\n    // buildHash () : MixinHash {\n    //     return String.fromCharCode(...this.walkDepthState.linearizedByTopoLevelsSource.map(mixin => mixin.id))\n    // }\n    getBaseClassMixinId(baseClass) {\n        const constructor = this.constructor;\n        const mixinId = constructor.baseClassesIds.get(baseClass);\n        if (mixinId !== undefined)\n            return mixinId;\n        const newId = MIXIN_ID++;\n        constructor.baseClassesIds.set(baseClass, newId);\n        return newId;\n    }\n    buildMinimalClass() {\n        const self = this.constructor;\n        let baseCls = this.baseClass;\n        const minimalClassConstructor = this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin) => {\n            const { cls, hash } = acc;\n            const nextHash = hash + String.fromCharCode(mixin.id);\n            let wrapperCls = self.minimalClassesByLinearHash.get(nextHash);\n            if (!wrapperCls) {\n                wrapperCls = mixin.mixinLambda(cls);\n                mixin.name = wrapperCls.name;\n                self.minimalClassesByLinearHash.set(nextHash, wrapperCls);\n            }\n            acc.cls = wrapperCls;\n            acc.hash = nextHash;\n            return acc;\n        }, { cls: baseCls, hash: String.fromCharCode(this.getBaseClassMixinId(baseCls)) }).cls;\n        const minimalClass = Object.assign(minimalClassConstructor, {\n            [MixinInstanceOfProperty]: this.identitySymbol,\n            [MixinStateProperty]: this,\n            mix: this.mixinLambda,\n            derive: (base) => Mixin([minimalClass, base], base => class extends base {\n            }),\n            $: this,\n            toString: this.toString.bind(this)\n        });\n        Object.defineProperty(minimalClass, Symbol.hasInstance, { value: isInstanceOfStatic });\n        return minimalClass;\n    }\n    toString() {\n        return this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin) => `${mixin.name}(${acc})`, this.baseClass.name);\n    }\n}\nMixinState.minimalClassesByLinearHash = new Map();\nMixinState.baseClassesIds = new Map();\n//endregion type helpers\n//---------------------------------------------------------------------------------------------------------------------\nconst isMixinClass = (func) => {\n    return Object.getPrototypeOf(func.prototype).constructor.hasOwnProperty(MixinStateProperty);\n};\nconst getMixinState = (func) => {\n    return Object.getPrototypeOf(func.prototype).constructor[MixinStateProperty];\n};\n//---------------------------------------------------------------------------------------------------------------------\nconst mixin = (required, mixinLambda) => {\n    let baseClass;\n    if (required.length > 0) {\n        const lastRequirement = required[required.length - 1];\n        // absence of `[ MixinStateProperty ]` indicates its a regular class and not a mixin class\n        // avoid assigning ZeroBaseClass - it will be applied as default at the end\n        if (!isMixinClass(lastRequirement) && lastRequirement !== ZeroBaseClass)\n            baseClass = lastRequirement;\n    }\n    const requirements = [];\n    required.forEach((requirement, index) => {\n        const mixinState = requirement[MixinStateProperty];\n        if (mixinState !== undefined) {\n            const currentBaseClass = mixinState.baseClass;\n            // ignore ZeroBaseClass - since those are compatible with any other base class\n            if (currentBaseClass !== ZeroBaseClass) {\n                if (baseClass) {\n                    // already found a base class from requirements earlier\n                    if (baseClass !== currentBaseClass) {\n                        const currentIsSub = currentBaseClass.prototype.isPrototypeOf(baseClass.prototype);\n                        const currentIsSuper = baseClass.prototype.isPrototypeOf(currentBaseClass.prototype);\n                        if (!currentIsSub && !currentIsSuper)\n                            throw new Error(\"Base class mismatch\");\n                        baseClass = currentIsSuper ? currentBaseClass : baseClass;\n                    }\n                }\n                else\n                    // first base class from requirements\n                    baseClass = currentBaseClass;\n            }\n            requirements.push(mixinState);\n        }\n        else {\n            if (index !== required.length - 1)\n                throw new Error(\"Base class should be provided as the last element of the requirements array\");\n        }\n    });\n    //------------------\n    const mixinState = MixinState.new({\n        requirements,\n        mixinLambda: mixinLambda,\n        baseClass: baseClass || ZeroBaseClass\n    });\n    return mixinState.minimalClass;\n};\n//---------------------------------------------------------------------------------------------------------------------\n// this function works both with default mixin class and mixin application function\n// it supplied internally as [Symbol.hasInstance] for the default mixin class and mixin application function\nconst isInstanceOfStatic = function (instance) {\n    return Boolean(instance && instance[this[MixinInstanceOfProperty]]);\n};\n//---------------------------------------------------------------------------------------------------------------------\n/**\n * This is the `instanceof` analog for the classes created with [[Mixin]] helper. It also provides [typeguard](https://www.typescriptlang.org/docs/handbook/advanced-types.html#user-defined-type-guards).\n *\n * There's no strict need to use it, as the native `instanceof` is also supported for the mixins created with the [[Mixin]] helper and also provides\n * typeguarding.\n *\n * @param instance Any value, normally an instance of the mixin class\n * @param func The constructor function of the class, created with [[Mixin]]\n */\nexport const isInstanceOf = (instance, func) => {\n    return Boolean(instance && instance[func[MixinInstanceOfProperty]]);\n};\n//---------------------------------------------------------------------------------------\n/**\n * This function allows you to create mixin classes. Mixin classes solves the well-known problem with \"classical\" single-class inheritance,\n * in which class hierarchy must form a tree. When using mixins, class hierarchy becomes an arbitrary acyclic graph.\n *\n * Another view on mixins is that, if \"classical\" class is a point (a vertice of the graph), mixin class is an arrow between the points\n * (an edge in the graph, or rather, a description of the edge).\n *\n * Some background information about the mixin pattern can be found [here](https://mariusschulz.com/blog/typescript-2-2-mixin-classes)\n * and [here](https://www.bryntum.com/blog/the-mixin-pattern-in-typescript-all-you-need-to-know/).\n *\n * The pattern, being described here, is the evolution of the previous work, and main advantage is that it solves the compilation error\n * for circular references.\n *\n * Mixin definition. Requirements\n * ------------------------------\n *\n * The pattern looks like:\n *\n *     class Mixin1 extends Mixin(\n *         [],\n *         (base : AnyConstructor) =>\n *\n *         class Mixin1 extends base {\n *             prop1        : string\n *             method1 () : string {\n *                 return this.prop1\n *             }\n *             static static1 : number\n *         }\n *     ){}\n *\n * The core of the definition above is the mixin lambda - a function which receives a base class as its argument and returns a class,\n * extending the base class with additional properties.\n *\n * The example above creates a mixin `Mixin1` which has no requirements. Requirements are the other mixins,\n * which needs to be included in the base class of this mixin.\n *\n * There's also a special type of the requirement,\n * called \"base class requirement\". It is optional and can only appear as the last argument of the requirements\n * array. It does not have to be a mixin, created with the `Mixin` function, but can be any JS class. This requirement\n * specifies, that the base class of this mixin should be a subclass of the given class (or that class itself).\n *\n * The requirements of the mixin needs to be listed 3 times:\n * - as an array of constructor functions, in the 1st argument of the `Mixin` function\n * - as an instance type intersection, in the 1st type argument for the [[AnyConstructor]] type\n * - as an static type intersection, in the 2nd type argument for the [[AnyConstructor]] type\n *\n * For example, `Mixin2` requires `Mixin1`:\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) =>\n *\n *         class Mixin2 extends base {\n *         }\n *     ){}\n *\n * And `Mixin3` requires both `Mixin1` and `Mixin2` (even that its redundant, since `Mixin2` already requires `Mixin1`,\n * but suppose we don't know the implementation details of the `Mixin2`):\n *\n *     class Mixin3 extends Mixin(\n *         [ Mixin1, Mixin2 ],\n *         (base : AnyConstructor<Mixin1 & Mixin2, typeof Mixin1 & typeof Mixin2>) =>\n *\n *         class Mixin3 extends base {\n *         }\n *     ){}\n *\n * Now, `Mixin4` requires `Mixin3`, plus, it requires the base class to be `SomeBaseClass`:\n *\n *     class SomeBaseClass {}\n *\n *     class Mixin4 extends Mixin(\n *         [ Mixin3, SomeBaseClass ],\n *         (base : AnyConstructor<\n *             Mixin3 & SomeBaseClass, typeof Mixin3 & typeof SomeBaseClass\n *         >) =>\n *\n *         class Mixin4 extends base {\n *         }\n *     ){}\n *\n * As already briefly mentioned, the requirements are \"scanned\" deep and included only once. Also all minimal classes are cached -\n * for example the creation of the Mixin3 will reuse the minimal class of the Mixin2 instead of creating a new intermediate class.\n * This means that all edges of the mixin dependencies graph are created only once (up to the base class).\n *\n * Requirements can not form cycles - that will generate both compilation error and run-time stack overflow.\n *\n * The typing for the `Mixin` function will provide a compilation error, if the requirements don't match, e.g. some requirement is\n * listed in the array, but missed in the types. This protects you from trivial mistakes. However, the typing is done up to 10 requirements only.\n * If you need more than 10 requirements for the mixin, use the [[MixinAny]] function, which is an exact analog of `Mixin`, but without\n * this type-level protection for requirements mismatch.\n *\n * It is possible to simplify the type of the `base` argument a bit, by using the [[ClassUnion]] helper. However, it seems in certain edge cases\n * it may lead to compilation errors. If your scenarios are not so complex you should give it a try. Using the [[ClassUnion]] helper, the\n * `Mixin3` can be defined as:\n *\n *     class Mixin3 extends Mixin(\n *         [ Mixin1, Mixin2 ],\n *         (base : ClassUnion<typeof Mixin1, typeof Mixin2>) =>\n *\n *         class Mixin3 extends base {\n *         }\n *     ){}\n *\n * Note, that due to this [issue](https://github.com/Microsoft/TypeScript/issues/7342), if you use decorators in your mixin class,\n * the declaration needs to be slightly more verbose (can not use compact notation for the arrow functions):\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) => {\n *             class Mixin2 extends base {\n *                 @decorator\n *                 prop2 : string\n *             }\n *             return Mixin2\n *         }\n *     ){}\n *\n * As you noticed, the repeating listing of the requirements is somewhat verbose. Suggestions how the pattern can be improved\n * are [very welcomed](mailto:nickolay8@gmail.com).\n *\n * Mixin instantiation. Mixin constructor. `instanceof`\n * --------------------------------\n *\n * You can instantiate any mixin class just by using its constructor:\n *\n *     const instance1 = new Mixin1()\n *     const instance2 = new Mixin2()\n *\n * As explained in details [here](https://mariusschulz.com/blog/typescript-2-2-mixin-classes), mixin constructor should accept variable number of arguments\n * with the `any` type. This is simply because the mixin is supposed to be applicable to any other base class, which may have its own type\n * of the constructor arguments.\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) => {\n *             class Mixin2 extends base {\n *                 prop2 : string\n *\n *                 constructor (...args: any[]) {\n *                     super(...args)\n *                     this.prop2 = ''\n *                 }\n *             }\n *             return Mixin2\n *         }\n *     ){}\n *\n * In other words, its not possible to provide any type-safety for mixin instantiation using regular class constructor.\n *\n * However, if we change the way we create class instances a little, we can get the type-safety back. For that,\n * we need to use a \"uniform\" class constructor - a constructor which has the same form for all classes. The [[Base]] class\n * provides such constructor as its static [[Base.new|new]] method. The usage of `Base` class is not required - you can use\n * any other base class.\n *\n * The `instanceof` operator works as expected for instances of the mixin classes. It also takes into account all the requirements.\n * For example:\n *\n *     const instance2 = new Mixin2()\n *\n *     const isMixin2 = instance2 instanceof Mixin2 // true\n *     const isMixin1 = instance2 instanceof Mixin1 // true, since Mixin2 requires Mixin1\n *\n * See also [[isInstanceOf]].\n *\n * \"Manual\" class derivation\n * --------------------------------\n *\n * You have defined a mixin using the `Mixin` function. Now you want to apply it to some base class to get the \"specific\" class to be able\n * to instantiate it. As described above - you don't have to, you can instantiate it directly.\n *\n * Sometimes however, you still want to derive the class \"manually\". For that, you can use static methods `mix` and `derive`, available\n * on all mixins.\n *\n * The `mix` method provides a direct access to the mixin lambda. It does not take requirements into account - that's the implementor's responsibility.\n * The `derive` method is something like \"accumulated\" mixin lambda - mixin lambda with all requirements.\n *\n * Both `mix` and `derive` provide the reasonably typed outcome.\n *\n *     class Mixin1 extends Mixin(\n *         [],\n *         (base : AnyConstructor) =>\n *\n *         class Mixin1 extends base {\n *             prop1        : string\n *         }\n *     ){}\n *\n *     class Mixin2 extends Mixin(\n *         [ Mixin1 ],\n *         (base : AnyConstructor<Mixin1, typeof Mixin1>) =>\n *\n *         class Mixin2 extends base {\n *             prop2        : string\n *         }\n *     ){}\n *\n *     const ManualMixin1 = Mixin1.mix(Object)\n *     const ManualMixin2 = Mixin2.mix(Mixin1.mix(Object))\n *\n *     const AnotherManualMixin1 = Mixin1.derive(Object)\n *     const AnotherManualMixin2 = Mixin2.derive(Object)\n *\n * Generics\n * --------\n *\n * Using generics with mixins is tricky because TypeScript does not have higher-kinded types and type inference for generics. Still some form\n * of generic arguments is possible, using the interface merging trick.\n *\n * Here's the pattern:\n *\n * ```ts\n * class Duplicator<Element> extends Mixin(\n *     [],\n *     (base : AnyConstructor) =>\n *\n *     class Duplicator extends base {\n *         Element                 : any\n *\n *         duplicate (value : this[ 'Element' ]) : this[ 'Element' ][] {\n *             return [ value, value ]\n *         }\n *     }\n * ){}\n *\n * interface Duplicator<Element> {\n *     Element : Element\n * }\n *\n * const dup = new Duplicator<boolean>()\n *\n * dup.duplicate('foo') // TS2345: Argument of type '\"foo\"' is not assignable to parameter of type 'boolean'.\n * ```\n *\n * In the example above, we've defined a generic argument `Element` for the outer mixin class, but in fact, that argument is not used anywhere in the\n * nested class definition in the mixin lambda. Instead, in the nested class, we define a property `Element`, which plays the role of the\n * generic argument.\n *\n * Mixin class methods then can refer to the generic type as `this[ 'Element' ]`.\n *\n * The generic arguments of the outer and nested classes are tied together in the additional interface declaration, which, by TypeScript rules\n * is merged together with the class definition. In this declaration, we specify that property `Element` has type of the `Element` generic argument.\n *\n * Limitations\n * ---------\n *\n * The most important limitation we found (which affect the old pattern as well) is the compilation error, which will be issued for\n * the private/protected methods, when compiling with declarations emitting (*.d.ts files generation).\n *\n * This is a [well-known problem](https://github.com/microsoft/TypeScript/issues/35822) in the TypeScript world – the *.d.ts files do not represent\n * the internal data structures of the TypeScript compiler well. Instead they use some simplified syntax, optimized for human editing.\n * This is why the compiler may generate false positives in the incremental compilation mode – it uses *.d.ts files internally.\n *\n * This can be a show-stopper for the people that use declaration files (usually for publishing). Keep in mind though, that you can always\n * publish actual TypeScript sources along with the generated JavaScript files, instead of publishing JavaScript + declarations files.\n *\n */\nexport const Mixin = mixin;\n/**\n * This is an exact analog of the [[Mixin]] function, but without type-level protection for requirements mismatch.\n * It supports unlimited number of requirements.\n */\nexport const MixinAny = mixin;\n","/**\n * The enumeration for the time units\n */\nexport var TimeUnit;\n(function (TimeUnit) {\n    TimeUnit[\"Millisecond\"] = \"millisecond\";\n    TimeUnit[\"Second\"] = \"second\";\n    TimeUnit[\"Minute\"] = \"minute\";\n    TimeUnit[\"Hour\"] = \"hour\";\n    TimeUnit[\"Day\"] = \"day\";\n    TimeUnit[\"Week\"] = \"week\";\n    TimeUnit[\"Month\"] = \"month\";\n    TimeUnit[\"Quarter\"] = \"quarter\";\n    TimeUnit[\"Year\"] = \"year\";\n})(TimeUnit || (TimeUnit = {}));\n/**\n * The enumeration for the supported constraint types\n */\nexport var ConstraintType;\n(function (ConstraintType) {\n    /**\n     * \"Must start on\" constraint.\n     * Restricts an event to start on a [[HasDateConstraintMixin.constraintDate|specified date]].\n     * The constraint cannot be used for a summary event.\n     */\n    ConstraintType[\"MustStartOn\"] = \"muststarton\";\n    /**\n     * \"Must finish on\" constraint.\n     * Restricts an event to finish on a [[HasDateConstraintMixin.constraintDate|specified date]].\n     * The constraint cannot be used for a summary event.\n     */\n    ConstraintType[\"MustFinishOn\"] = \"mustfinishon\";\n    /**\n     * \"Start no earlier than\" constraint.\n     * Restricting an event to start on or after a [[HasDateConstraintMixin.constraintDate|specified date]].\n     */\n    ConstraintType[\"StartNoEarlierThan\"] = \"startnoearlierthan\";\n    /**\n     * \"Start no later than\" constraint.\n     * Restricting an event to start on or before a [[HasDateConstraintMixin.constraintDate|specified date]].\n     *\n     * The constraint cannot be used for a summary task.\n     */\n    ConstraintType[\"StartNoLaterThan\"] = \"startnolaterthan\";\n    /**\n     * \"Finish no earlier than\" constraint.\n     * Restricting an event to finish on or after a [[HasDateConstraintMixin.constraintDate|specified date]].\n     *\n     * The constraint cannot be used for a summary task.\n     */\n    ConstraintType[\"FinishNoEarlierThan\"] = \"finishnoearlierthan\";\n    /**\n     * \"Finish no later than\" constraint.\n     * Restricting an event to finish on or before a [[HasDateConstraintMixin.constraintDate|specified date]].\n     */\n    ConstraintType[\"FinishNoLaterThan\"] = \"finishnolaterthan\";\n})(ConstraintType || (ConstraintType = {}));\n/**\n * The enumeration for the supported scheduling modes\n */\nexport var SchedulingMode;\n(function (SchedulingMode) {\n    SchedulingMode[\"Normal\"] = \"Normal\";\n    SchedulingMode[\"FixedDuration\"] = \"FixedDuration\";\n    SchedulingMode[\"FixedEffort\"] = \"FixedEffort\";\n    SchedulingMode[\"FixedUnits\"] = \"FixedUnits\";\n})(SchedulingMode || (SchedulingMode = {}));\n/**\n * The enumeration for the dependency validation result\n */\nexport var DependencyValidationResult;\n(function (DependencyValidationResult) {\n    /**\n     * Dependency has no errors\n     */\n    DependencyValidationResult[DependencyValidationResult[\"NoError\"] = 0] = \"NoError\";\n    /**\n     * Indicates that the validated dependency builds a cycle\n     */\n    DependencyValidationResult[DependencyValidationResult[\"CyclicDependency\"] = 1] = \"CyclicDependency\";\n    /**\n     * Indicates that a dependency with the same predecessor and successor as validated one's already exists\n     */\n    DependencyValidationResult[DependencyValidationResult[\"DuplicatingDependency\"] = 2] = \"DuplicatingDependency\";\n})(DependencyValidationResult || (DependencyValidationResult = {}));\n/**\n * The enumeration for the supported dependency types\n */\nexport var DependencyType;\n(function (DependencyType) {\n    /**\n     * Start-to-Start (_SS_)\n     *\n     * With this dependency type, the succeeding event is delayed to start not earlier than the preceding event starts.\n     */\n    DependencyType[DependencyType[\"StartToStart\"] = 0] = \"StartToStart\";\n    /**\n     * Start-to-Finish (_SF_)\n     *\n     * The finish of the succeeding event is constrained by the start of the preceding event.\n     * So the successor cannot finish before the predecessor starts.\n     */\n    DependencyType[DependencyType[\"StartToEnd\"] = 1] = \"StartToEnd\";\n    /**\n     * Finish-to-Start (_FS_)\n     *\n     * This type of dependency, restricts the dependent event to not start earlier than the preceding event finishes.\n     */\n    DependencyType[DependencyType[\"EndToStart\"] = 2] = \"EndToStart\";\n    /**\n     * Finish-to-Finish (_FF_)\n     *\n     * The succeeding event cannot finish before the completion of the preceding event.\n     */\n    DependencyType[DependencyType[\"EndToEnd\"] = 3] = \"EndToEnd\";\n})(DependencyType || (DependencyType = {}));\n/**\n * The enumeration for the supported sources of the calendar for the dependency.\n */\nexport var DependenciesCalendar;\n(function (DependenciesCalendar) {\n    DependenciesCalendar[\"Project\"] = \"Project\";\n    DependenciesCalendar[\"FromEvent\"] = \"FromEvent\";\n    DependenciesCalendar[\"ToEvent\"] = \"ToEvent\";\n})(DependenciesCalendar || (DependenciesCalendar = {}));\n/**\n * Engine provides with different project types, the enumeration describes the types currently available\n */\nexport var ProjectType;\n(function (ProjectType) {\n    ProjectType[ProjectType[\"SchedulerBasic\"] = 1] = \"SchedulerBasic\";\n    ProjectType[ProjectType[\"SchedulerPro\"] = 2] = \"SchedulerPro\";\n    ProjectType[ProjectType[\"Gantt\"] = 3] = \"Gantt\";\n})(ProjectType || (ProjectType = {}));\n/**\n * The enumeration for the scheduling direction\n */\nexport var Direction;\n(function (Direction) {\n    /**\n     * Forward (or As Soon As Possible (ASAP)) scheduling.\n     */\n    Direction[\"Forward\"] = \"Forward\";\n    /**\n     * Backward (or As Late As Possible (ALAP)) scheduling.\n     */\n    Direction[\"Backward\"] = \"Backward\";\n    Direction[\"None\"] = \"None\";\n})(Direction || (Direction = {}));\nexport var ConstraintIntervalSide;\n(function (ConstraintIntervalSide) {\n    ConstraintIntervalSide[\"Start\"] = \"Start\";\n    ConstraintIntervalSide[\"End\"] = \"End\";\n})(ConstraintIntervalSide || (ConstraintIntervalSide = {}));\n","// http://ecma-international.org/ecma-262/5.1/#sec-15.9.1.1\n/**\n * Minimal date representable with native Date class\n */\nexport const MIN_DATE = new Date(-8640000000000000);\n/**\n * Maximal date representable with native Date class\n */\nexport const MAX_DATE = new Date(8640000000000000);\nexport const isDateFinite = (date) => {\n    if (!date)\n        return false;\n    const time = date.getTime();\n    return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();\n};\n","/**\n * The date intervals in the scheduling engine are always inclusive on one end and opened on another.\n * The \"opened\" end is not considered to be a part of the interval.\n *\n * Depending from the scheduling direction (forward/backward) this property may need to be inverted.\n *\n * This enum specifies what edge of the interval is inclusive.\n */\nexport var EdgeInclusion;\n(function (EdgeInclusion) {\n    EdgeInclusion[EdgeInclusion[\"Left\"] = 0] = \"Left\";\n    EdgeInclusion[EdgeInclusion[\"Right\"] = 1] = \"Right\";\n})(EdgeInclusion || (EdgeInclusion = {}));\n","import DateHelper from \"../../Core/helper/DateHelper.js\";\nimport { TimeUnit } from \"../scheduling/Types.js\";\nimport { MAX_DATE, MIN_DATE } from \"../util/Constants.js\";\nimport { EdgeInclusion } from \"../util/Types.js\";\n/**\n * The enum type for result of [[forEachAvailabilityInterval]].\n */\nexport var CalendarIteratorResult;\n(function (CalendarIteratorResult) {\n    /**\n     * Indicates the iteration has completed by iterating the whole given timespan or has reached the MAX_DATE or MIN_DATE.\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"FullRangeIterated\"] = 0] = \"FullRangeIterated\";\n    /**\n     * Indicates the iteration has been stopped by returning `false` from the iterator.\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"StoppedByIterator\"] = 1] = \"StoppedByIterator\";\n    /**\n     * Indicates the iteration has exceeded the `maxRange` option\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"MaxCacheExtendCyclesReached\"] = 2] = \"MaxCacheExtendCyclesReached\";\n    /**\n     * Indicates the iteration has exceeded the `maxRange` option\n     */\n    CalendarIteratorResult[CalendarIteratorResult[\"MaxRangeReached\"] = 3] = \"MaxRangeReached\";\n})(CalendarIteratorResult || (CalendarIteratorResult = {}));\n/**\n * Calendar cache.\n */\nexport class CalendarCache {\n    constructor(config) {\n        this.cacheFilledStartDate = MAX_DATE;\n        this.cacheFilledEndDate = MIN_DATE;\n        this.intervalsCachingChunkDuration = 30;\n        this.intervalsCachingChunkUnit = TimeUnit.Day;\n        this.maxCacheExtendCycles = 1000;\n        // max range for the iteration - 5 years\n        this.maxRange = 5 * 365 * 24 * 60 * 60 * 1000;\n        config && Object.assign(this, config);\n    }\n    includeWrappingRangeFrom(cache, startDate, endDate) {\n        cache.ensureCacheFilledForInterval(startDate, endDate);\n        this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);\n    }\n    // after this method, we guarantee, that for every point between `startDate` and `endDate` (_inclusive_)\n    // we'll have a final representation of the cache, that is, we'll be able to get an interval to which this point belongs\n    // _both_ for forward and backward directions\n    ensureCacheFilledForInterval(startDate, endDate) {\n        const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();\n        const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();\n        if (cacheFilledStartDateN !== MAX_DATE.getTime()) {\n            const startDateN = startDate.getTime();\n            const endDateN = endDate.getTime();\n            if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN)\n                return;\n            // asked to cache an interval which is to the left from the cached area - extend to the right\n            if (endDateN <= cacheFilledStartDateN) {\n                endDate = new Date(cacheFilledStartDateN - 1);\n            }\n            else if (startDateN >= cacheFilledEndDateN) {\n                startDate = new Date(cacheFilledEndDateN + 1);\n            }\n            else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {\n                startDate = new Date(cacheFilledEndDateN + 1);\n            }\n            else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {\n                endDate = new Date(cacheFilledStartDateN - 1);\n            }\n            else {\n                this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));\n                this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);\n                return;\n            }\n        }\n        if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {\n            this.cacheFilledStartDate = startDate;\n        }\n        if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {\n            this.cacheFilledEndDate = endDate;\n        }\n        this.fillCache(startDate, endDate);\n    }\n    fillCache(_1 /* startDate */, _2 /* endDate */) {\n        throw new Error(\"Abstract method\");\n    }\n    clear() {\n        this.cacheFilledStartDate = MAX_DATE;\n        this.cacheFilledEndDate = MIN_DATE;\n        this.intervalCache.clear();\n    }\n    /**\n     * The core iterator method of the calendar cache.\n     *\n     * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties\n     * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided\n     * iterator function should return `false` at some point, to avoid infinite loops.\n     *\n     * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.\n     *\n     * Another recognized option is `maxRange`, which indicates the maximum timespan for this iterator (in milliseconds). When iterator\n     * exceeds this timespan, the iteration is stopped and [[CalendarIteratorResult.MaxRangeReached]] value is returned.\n     * Default value is 5 years.\n     *\n     * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found\n     * in the given timespan. All the intervals, which are \"active\" for current interval are collected in the 3rd argument\n     * for this function. If iterator returns `false` (checked with `===`) the iteration stops.\n     *\n     * @param scope The scope (`this` value) to execute the iterator in.\n     */\n    forEachAvailabilityInterval(options, func, scope) {\n        scope = scope || this;\n        const startDate = options.startDate;\n        const endDate = options.endDate;\n        const startDateN = startDate && startDate.getTime();\n        const endDateN = endDate && endDate.getTime();\n        const maxRange = options.maxRange ?? this.maxRange;\n        // `isForward = true` by default\n        const isForward = options.isForward !== false;\n        if (isForward ? !startDate : !endDate) {\n            throw new Error(\"At least `startDate` or `endDate` is required, depending from the `isForward` option\");\n        }\n        const intervalCache = this.intervalCache;\n        let cacheCursorDate = isForward ? startDate : endDate;\n        let cursorDate = isForward ? startDate : endDate;\n        const rangeStart = cursorDate.getTime();\n        // this is generally an endless loop, but we artificially limit it to `maxCacheExtendCycles` iterations\n        // to avoid freezing in unforeseen edge cases\n        for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {\n            if (isForward) {\n                this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));\n            }\n            else {\n                this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);\n            }\n            let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);\n            while (interval) {\n                const intervalStartDate = interval.startDate;\n                const intervalEndDate = interval.endDate;\n                // out of requested range - all done\n                if ((isForward && endDateN && intervalStartDate.getTime() >= endDateN)\n                    ||\n                        (!isForward && startDateN && intervalEndDate.getTime() <= startDateN)) {\n                    return CalendarIteratorResult.FullRangeIterated;\n                }\n                if ((isForward && intervalStartDate.getTime() - rangeStart >= maxRange)\n                    ||\n                        (!isForward && rangeStart - intervalEndDate.getTime() >= maxRange)) {\n                    return CalendarIteratorResult.MaxRangeReached;\n                }\n                // we are out of cached area, need to extend the cache\n                if ((isForward && intervalStartDate.getTime() > this.cacheFilledEndDate.getTime())\n                    ||\n                        (!isForward && intervalEndDate.getTime() < this.cacheFilledStartDate.getTime())) {\n                    break;\n                }\n                // save the last processed point, from which we should start after cache will be extended\n                cursorDate = isForward ? intervalEndDate : intervalStartDate;\n                // adjust to start / end date limits in iterator\n                const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;\n                const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;\n                if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {\n                    // indicates premature exit if iterator returns `false`\n                    return CalendarIteratorResult.StoppedByIterator;\n                }\n                interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);\n            }\n            if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {\n                return CalendarIteratorResult.FullRangeIterated;\n            }\n            cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;\n        }\n        return CalendarIteratorResult.MaxCacheExtendCyclesReached;\n    }\n}\n","export const stripDuplicates = (array) => Array.from(new Set(array));\n","import { stripDuplicates } from \"../util/StripDuplicates.js\";\n/**\n * A class, that represent a cached set of availability intervals. One can use the [[getIsWorking]] method\n * to determine if this set intervals represents working time or non-working.\n */\nexport class CalendarCacheInterval {\n    constructor(config) {\n        this.intervals = [];\n        config && Object.assign(this, config);\n        if (!this.calendar)\n            throw new Error(\"Required attribute `calendar` is missing\");\n    }\n    includeInterval(interval) {\n        if (this.intervals.indexOf(interval) == -1) {\n            const copy = this.intervals.slice();\n            copy.push(interval);\n            return new CalendarCacheInterval({ intervals: copy, calendar: this.calendar });\n        }\n        else\n            return this;\n    }\n    combineWith(interval) {\n        return new CalendarCacheInterval({ intervals: this.intervals.concat(interval.intervals), calendar: this.calendar });\n    }\n    /**\n     * Returns the working status of this intervals set. It is determined as a working status\n     * of the most prioritized interval (intervals are prioritized from child to parent)\n     */\n    getIsWorking() {\n        if (this.isWorking != null)\n            return this.isWorking;\n        const intervals = this.intervals = this.normalizeIntervals(this.intervals);\n        // return the value of the interval with the highest priority\n        return this.isWorking = intervals[0].isWorking;\n    }\n    normalizeIntervals(intervals) {\n        const filtered = stripDuplicates(intervals);\n        // sort in decreasing order\n        filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());\n        return filtered;\n    }\n}\n","// Generic binary search\nexport const binarySearch = (value, array, comparator = (a, b) => a - b) => {\n    let left = 0;\n    let right = array.length;\n    while (left < right) {\n        // | 0 to make it integer, faster according to: https://jsperf.com/or-vs-floor/2\n        const mid = (left + right) / 2 | 0;\n        const compare = comparator(value, array[mid]);\n        if (compare === 0)\n            return { found: true, index: mid };\n        else if (compare < 0)\n            right = mid;\n        else\n            left = mid + 1;\n    }\n    return { found: false, index: right };\n};\n","import { binarySearch } from \"../util/BinarySearch.js\";\nexport var IndexPosition;\n(function (IndexPosition) {\n    IndexPosition[IndexPosition[\"Exact\"] = 0] = \"Exact\";\n    IndexPosition[IndexPosition[\"Next\"] = 1] = \"Next\";\n})(IndexPosition || (IndexPosition = {}));\n// TODO store keys and values in a single array of \"entries\"? less memory movement during insert/delete in theory\nexport class SortedMap {\n    constructor(comparator) {\n        this.keys = [];\n        this.values = [];\n        this.comparator = comparator || ((a, b) => a - b);\n    }\n    set(key, value) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        if (search.found) {\n            this.values[search.index] = value;\n        }\n        else {\n            this.keys.splice(search.index, 0, key);\n            this.values.splice(search.index, 0, value);\n        }\n        return search.index;\n    }\n    // you need to know what you are doing when using this method\n    insertAt(index, key, value) {\n        this.keys.splice(index, 0, key);\n        this.values.splice(index, 0, value);\n    }\n    setValueAt(index, value) {\n        this.values[index] = value;\n    }\n    get(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        return search.found ? this.values[search.index] : undefined;\n    }\n    getEntryAt(index) {\n        return index < this.keys.length ? { key: this.keys[index], value: this.values[index] } : undefined;\n    }\n    getKeyAt(index) {\n        return this.keys[index];\n    }\n    getValueAt(index) {\n        return this.values[index];\n    }\n    delete(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        if (search.found)\n            this.deleteAt(search.index);\n    }\n    size() {\n        return this.keys.length;\n    }\n    deleteAt(index) {\n        this.keys.splice(index, 1);\n        this.values.splice(index, 1);\n    }\n    indexOfKey(key) {\n        const search = binarySearch(key, this.keys, this.comparator);\n        return {\n            found: search.found ? IndexPosition.Exact : IndexPosition.Next,\n            index: search.index\n        };\n    }\n    map(func) {\n        const keys = this.keys;\n        const values = this.values;\n        const result = [];\n        for (let i = 0; i < keys.length; i++)\n            result.push(func(values[i], keys[i], i));\n        return result;\n    }\n    getAllEntries() {\n        return this.map((value, key) => { return { value, key }; });\n    }\n    clear() {\n        this.keys.length = 0;\n        this.values.length = 0;\n    }\n}\n","import { MAX_DATE, MIN_DATE } from \"../util/Constants.js\";\nimport { EdgeInclusion } from \"../util/Types.js\";\nimport { IndexPosition, SortedMap } from \"./SortedMap.js\";\nexport class IntervalCache {\n    constructor(config) {\n        this.points = new SortedMap((a, b) => a.getTime() - b.getTime());\n        this.leftInfinityKey = MIN_DATE;\n        this.rightInfinityKey = MAX_DATE;\n        Object.assign(this, config);\n        if (this.emptyInterval === undefined || !this.combineIntervalsFn)\n            throw new Error(\"All of `emptyPoint`, `combineIntervalsFn` are required\");\n        this.points.set(this.leftInfinityKey, this.emptyInterval);\n    }\n    size() {\n        return this.points.size();\n    }\n    indexOf(date) {\n        return this.points.indexOfKey(date);\n    }\n    getDateAt(index) {\n        return this.points.getKeyAt(index);\n    }\n    getPointAt(index) {\n        return this.points.getValueAt(index);\n    }\n    getIntervalOf(date, edgeInclusion = EdgeInclusion.Left) {\n        // the `index` here is guaranteed to be > 0, because at index 0 there's a `emptyPoint`\n        let { found, index } = this.indexOf(date);\n        let startDateIndex;\n        if (edgeInclusion === EdgeInclusion.Left) {\n            startDateIndex = found === IndexPosition.Exact ? index : index - 1;\n        }\n        else {\n            startDateIndex = index - 1;\n        }\n        return this.getIntervalWithStartDateIndex(startDateIndex);\n    }\n    getPrevInterval(interval) {\n        if (interval.startDateIndex === 0)\n            return null;\n        return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);\n    }\n    getNextInterval(interval) {\n        if (interval.startDateIndex >= this.size() - 1)\n            return null;\n        return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);\n    }\n    getIntervalWithStartDateIndex(startDateIndex) {\n        return {\n            startDateIndex: startDateIndex,\n            startDate: this.getDateAt(startDateIndex),\n            endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,\n            cacheInterval: this.getPointAt(startDateIndex)\n        };\n    }\n    addInterval(startDate, endDate, extendInterval) {\n        const points = this.points;\n        // there is always \"leftInfinityKey\" empty point, so `index >= 0`\n        const { found, index } = points.indexOfKey(startDate);\n        let curIndex;\n        let lastUpdatedPoint;\n        if (found == IndexPosition.Exact) {\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));\n            points.setValueAt(index, inclusion);\n            curIndex = index + 1;\n        }\n        else {\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));\n            points.insertAt(index, startDate, inclusion);\n            curIndex = index + 1;\n        }\n        while (curIndex < points.size()) {\n            const curDate = points.getKeyAt(curIndex);\n            if (curDate.getTime() >= endDate.getTime())\n                break;\n            const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));\n            points.setValueAt(curIndex, inclusion);\n            curIndex++;\n        }\n        if (curIndex === points.size()) {\n            points.insertAt(points.size(), endDate, this.emptyInterval);\n        }\n        else {\n            const curDate = points.getKeyAt(curIndex);\n            if (curDate.getTime() === endDate.getTime()) {\n                // we advanced till some point, which matches `endDate` config\n                // this point will setup a new label, no need to add an explicit end date point,\n                // we are done, do nothing\n            }\n            else {\n                points.insertAt(curIndex, endDate, lastUpdatedPoint);\n            }\n        }\n    }\n    includeWrappingRange(intervalCache, startDate, endDate) {\n        let interval = intervalCache.getIntervalOf(startDate);\n        while (interval) {\n            this.addInterval(interval.startDate, interval.endDate, existingInterval => this.combineIntervalsFn(existingInterval, interval.cacheInterval));\n            if (interval.endDate.getTime() > endDate.getTime())\n                break;\n            interval = intervalCache.getNextInterval(interval);\n        }\n    }\n    getSummary() {\n        return this.points.map((label, date) => { return { label, date }; });\n    }\n    clear() {\n        this.points.clear();\n        this.points.set(this.leftInfinityKey, this.emptyInterval);\n    }\n}\n","import later from \"../vendor/later/later.js\";\nimport { CalendarCache } from \"./CalendarCache.js\";\nimport { CalendarCacheInterval } from \"./CalendarCacheInterval.js\";\nimport { IntervalCache } from \"./IntervalCache.js\";\nimport DateHelper from \"../../Core/helper/DateHelper.js\";\nimport TimeZoneHelper from \"../../Core/helper/TimeZoneHelper.js\";\nexport class CalendarCacheSingle extends CalendarCache {\n    constructor(config) {\n        super(config);\n        this.staticIntervalsCached = false;\n        if (!this.unspecifiedTimeInterval)\n            throw new Error(\"Required attribute `unspecifiedTimeInterval` is missing\");\n        this.intervalCache = new IntervalCache({\n            emptyInterval: new CalendarCacheInterval({\n                intervals: [this.unspecifiedTimeInterval],\n                calendar: this.calendar\n            }),\n            combineIntervalsFn: (interval1, interval2) => {\n                return interval1.combineWith(interval2);\n            }\n        });\n    }\n    fillCache(startDate, endDate) {\n        if (!this.staticIntervalsCached) {\n            this.cacheStaticIntervals();\n            this.staticIntervalsCached = true;\n        }\n        if (this.parentCache)\n            this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);\n        const startDateN = startDate.getTime();\n        const endDateN = endDate.getTime();\n        const timeZone = this.calendar.project?.timeZone;\n        if (startDateN > endDateN)\n            throw new Error(\"Invalid cache fill interval\");\n        this.forEachRecurrentInterval(interval => {\n            const startSchedule = interval.getStartDateSchedule();\n            const endSchedule = interval.getEndDateSchedule();\n            let wrappingStartDate = startSchedule.prev(1, startDate);\n            let wrappingEndDate;\n            if (endSchedule === 'EOD') {\n                const nextEndDate = startSchedule.next(1, endDate);\n                if (nextEndDate !== later.NEVER) {\n                    wrappingEndDate = DateHelper.getStartOfNextDay(nextEndDate, true);\n                }\n                else {\n                    wrappingEndDate = later.NEVER;\n                }\n            }\n            else {\n                wrappingEndDate = endSchedule.next(1, endDate);\n            }\n            // if the `startDate` is an occurrence in the interval's schedule, we need to advance one point prior\n            // this is to provide the backward-scheduling information for the `startDate` point\n            if (wrappingStartDate !== later.NEVER && wrappingStartDate.getTime() === startDateN) {\n                const wrappingStartDates = startSchedule.prev(2, startDate);\n                if (wrappingStartDates !== later.NEVER && wrappingStartDates.length === 2)\n                    wrappingStartDate = wrappingStartDates[1];\n            }\n            if (wrappingEndDate !== later.NEVER && wrappingEndDate.getTime() === endDateN) {\n                const wrappingEndDates = endSchedule.next(2, endDate);\n                if (wrappingEndDates !== later.NEVER && wrappingEndDates.length === 2)\n                    wrappingEndDate = wrappingEndDates[1];\n            }\n            const startDates = startSchedule.next(Infinity, wrappingStartDate !== later.NEVER ? wrappingStartDate : startDate, wrappingEndDate !== later.NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);\n            // schedule is empty for the interval of interest, do nothing\n            if (startDates === later.NEVER)\n                return;\n            // at this point `startDates` is a non-empty array\n            const endDates = endSchedule === 'EOD' ? startDates.map(date => DateHelper.getStartOfNextDay(date, true)) : endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== later.NEVER ? wrappingEndDate : endDate);\n            if (endDates === later.NEVER)\n                return;\n            if (endDates.length > startDates.length) {\n                // safe to ignore \"extra\" end dates\n                endDates.length = startDates.length;\n            }\n            else if (endDates.length < startDates.length) {\n                // monkey patch\n                startDates.length = endDates.length;\n                // throw new Error(\"Recurrent interval inconsistency: \" + interval + \", caching startDate: \" + startDate + \", caching endDate: \" + endDate)\n            }\n            startDates.forEach((startDate, index) => {\n                let recStartDate = startDate;\n                let recEndDate = endDates[index];\n                // Adjust calendar intervals when changing time zone\n                if (timeZone != null) {\n                    recStartDate = TimeZoneHelper.toTimeZone(recStartDate, timeZone);\n                    recEndDate = TimeZoneHelper.toTimeZone(recEndDate, timeZone);\n                }\n                // if (recStartDate.getTime() > recEndDate.getTime())\n                //     throw new Error(\"Recurrent interval inconsistency: \" + interval + \", startDate: \" + startDate + \", endDate: \" + endDates[ index ])\n                this.intervalCache.addInterval(recStartDate, recEndDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));\n            });\n        });\n    }\n    clear() {\n        this.staticIntervalsCached = false;\n        super.clear();\n    }\n    cacheStaticIntervals() {\n        this.forEachStaticInterval(interval => {\n            const timeZone = this.calendar.project?.timeZone;\n            let { startDate, endDate } = interval;\n            // Adjust calendar intervals when changing time zone\n            if (timeZone != null) {\n                startDate = TimeZoneHelper.toTimeZone(startDate, timeZone);\n                endDate = TimeZoneHelper.toTimeZone(endDate, timeZone);\n            }\n            this.intervalCache.addInterval(startDate, endDate, existingCacheInterval => existingCacheInterval.includeInterval(interval));\n        });\n    }\n    forEachStaticInterval(func) {\n        this.intervalStore.forEach((interval) => {\n            if (interval.isStatic())\n                func(interval);\n        });\n    }\n    forEachRecurrentInterval(func) {\n        this.intervalStore.forEach((interval) => {\n            if (interval.isRecurrent())\n                func(interval);\n        });\n    }\n}\n","import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class AbstractPartOfProjectGenericMixin extends Mixin([], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectGenericMixin extends base {\n        async commitAsync() {\n            return this.project.commitAsync();\n        }\n        set project(project) {\n            this.$project = project;\n        }\n        get project() {\n            return this.$project;\n        }\n        calculateProject() {\n            throw new Error(\"Implement me\");\n        }\n        /**\n         * The method to set the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        setProject(project) {\n            return this.project = project;\n        }\n        /**\n         * The method to get the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getProject() {\n            if (this.project)\n                return this.project;\n            return this.setProject(this.calculateProject());\n        }\n        /**\n         * Convenience method to get the instance of the assignment store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getAssignmentStore() {\n            const project = this.getProject();\n            return project?.assignmentStore;\n        }\n        /**\n         * Convenience method to get the instance of the dependency store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getDependencyStore() {\n            const project = this.getProject();\n            return project?.dependencyStore;\n        }\n        /**\n         * Convenience method to get the instance of the event store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getEventStore() {\n            const project = this.getProject();\n            return project?.eventStore;\n        }\n        /**\n         * Convenience method to get the instance of the resource store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getResourceStore() {\n            const project = this.getProject();\n            return project?.resourceStore;\n        }\n        /**\n         * Convenience method to get the instance of the calendar manager store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.\n         */\n        getCalendarManagerStore() {\n            const project = this.getProject();\n            return project?.calendarManagerStore;\n        }\n    }\n    return AbstractPartOfProjectGenericMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"../../AbstractPartOfProjectGenericMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\n/**\n * This an abstract mixin for every Store, that belongs to a project.\n *\n * The store with this mixin, supposes, that it will be \"joining\" the project, a reference to which is saved\n * and made available for all models.\n */\nexport class AbstractPartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectGenericMixin,\n    Store\n], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.isLoadingData = false;\n            this.disableHasLoadedDataToCommitFlag = false;\n        }\n        //region Async event triggering\n        // NOTE: Tested in Scheduler (EventStore.t.js)\n        construct(config = {}) {\n            config.asyncEvents = {\n                add: true,\n                remove: true,\n                removeAll: true,\n                change: true,\n                refresh: true,\n                replace: true,\n                move: true,\n                update: true\n            };\n            return superProto.construct.call(this, config);\n        }\n        // Override for event triggering, to allow triggering events before and after some async operation.\n        // The \"before\" events are prefix, the \"after\" are not.\n        trigger(eventName, param) {\n            const me = this, { asyncEvents, project } = me, asyncEvent = asyncEvents?.[eventName], asyncAction = asyncEvent && (asyncEvent === true || asyncEvent[param.action]);\n            if (!asyncAction) {\n                // Trigger as usual\n                return superProto.trigger.call(me, eventName, param);\n            }\n            // Trigger prefixed before event\n            superProto.trigger.call(me, `${eventName}PreCommit`, { ...param });\n            // Event that did not invalidate engine, for example \"update\"\n            if (!project || project.isEngineReady() && !project.isWritingData) {\n                // Trigger \"original\" event\n                superProto.trigger.call(me, eventName, param);\n            }\n            else if (!me.eventsSuspended && project) {\n                // Instead of making n auto-destroying listeners (which takes enormous amount of time), we make a single\n                // one and queue all the events. When dataReady event is triggered we trigger those events\n                // https://github.com/bryntum/support/issues/3154\n                if (!project.dataReadyDetacher) {\n                    project.queuedDataReadyEvents = [];\n                    // Wait for commit without triggering one, otherwise we would affect commit scheduling\n                    project.dataReadyDetacher = project.ion({\n                        dataReady() {\n                            // Trigger \"original\" event\n                            this.queuedDataReadyEvents.forEach(([superProto, scope, eventName, param]) => {\n                                superProto.trigger.call(scope, eventName, param);\n                            });\n                            project.queuedDataReadyEvents = null;\n                            project.dataReadyDetacher();\n                            project.dataReadyDetacher = null;\n                        },\n                        once: true\n                    });\n                }\n                project.queuedDataReadyEvents.push([superProto, me, eventName, param]);\n            }\n            // No way of handling other return values in this scenario, wont work for preventable events\n            return true;\n        }\n        //endregion\n        calculateProject() {\n            // project is supposed to be provided for stores from outside\n            return this.project;\n        }\n        setStoreData(data) {\n            // Loading data sets hasLoadedDataToCommit flag.\n            // So we treat the 1st commit after data loading as the initial one\n            if (this.project && !(this.syncDataOnLoad || this.disableHasLoadedDataToCommitFlag)) {\n                this.project.hasLoadedDataToCommit = true;\n            }\n            this.isLoadingData = true;\n            superProto.setStoreData.call(this, data);\n            this.isLoadingData = false;\n            this.project?.trigger('storeRefresh', { store: this });\n        }\n        // Override to postpone auto commits to after project commit, makes sure records are unmodified after commit\n        async doAutoCommit() {\n            if (this.suspendCount <= 0 && this.project && !this.project.isEngineReady()) {\n                // TODO: Ask nick about this, I could not get mixin order correct for this to work\n                // @ts-ignore\n                await this.project.commitAsync();\n            }\n            superProto.doAutoCommit.call(this);\n        }\n        async addAsync(records, silent) {\n            const result = this.add(records, silent);\n            await this.project.commitAsync();\n            return result;\n        }\n        async insertAsync(index, records, silent) {\n            const result = this.insert(index, records, silent);\n            await this.project.commitAsync();\n            return result;\n        }\n        async loadDataAsync(data) {\n            this.data = data;\n            await this.project.commitAsync();\n        }\n    }\n    return AbstractPartOfProjectStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"../../store/mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"../../AbstractPartOfProjectGenericMixin.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/BetterMixin.js';\n/**\n * This an abstract mixin for every Model that belongs to a project.\n *\n * The model with this mixin, supposes that it will be \"joining\" a store that is already part of a project,\n * so that such model can take a reference to the project from it.\n *\n * It provides 2 template methods [[joinProject]] and [[leaveProject]], which can be overridden in other mixins.\n */\nexport class AbstractPartOfProjectModelMixin extends Mixin([AbstractPartOfProjectGenericMixin, Model], (base) => {\n    const superProto = base.prototype;\n    class AbstractPartOfProjectModelMixin extends base {\n        joinStore(store) {\n            let joinedProject = null;\n            // Joining a store that is not part of project (for example a chained store) should not affect engine\n            if (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) {\n                const project = store.getProject();\n                if (project && !this.getProject()) {\n                    this.setProject(project);\n                    joinedProject = project;\n                }\n            }\n            superProto.joinStore.call(this, store);\n            // Join directly only if not repopulating the store, in which case we will be joined later after\n            // graph has been recreated\n            if (joinedProject && !joinedProject.isRepopulatingStores)\n                this.joinProject();\n        }\n        unjoinStore(store, isReplacing = false) {\n            superProto.unjoinStore.call(this, store, isReplacing);\n            const project = this.getProject();\n            const isLeavingProjectStore = (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) && project === store.getProject();\n            // Leave project when unjoining from store, but do not bother if the project is being destroyed or if\n            // the dataset is being replaced\n            if (project && !project.isDestroying && !project.isRepopulatingStores && isLeavingProjectStore) {\n                this.leaveProject(isReplacing);\n                this.setProject(null);\n            }\n            // @ts-ignore\n            if (isLeavingProjectStore)\n                this.graph = null;\n        }\n        /**\n         * Template method, which is called when model is joining the project (through joining some store that\n         * has already joined the project)\n         */\n        joinProject() { }\n        /**\n         * Template method, which is called when model is leaving the project (through leaving some store usually)\n         */\n        leaveProject(isReplacing = false) { }\n        calculateProject() {\n            const store = this.stores.find(s => (isInstanceOf(s, AbstractPartOfProjectStoreMixin)) && !!s.getProject());\n            return store?.getProject();\n        }\n        async setAsync(fieldName, value, silent) {\n            const result = this.set(fieldName, value, silent);\n            await this.project?.commitAsync();\n            return result;\n        }\n        async getAsync(fieldName) {\n            await this.project?.commitAsync();\n            return this.get(fieldName);\n        }\n        get isStmRestoring() {\n            const project = this.getProject();\n            return project?.isRestoringData || project?.stm.isRestoring || false;\n        }\n    }\n    return AbstractPartOfProjectModelMixin;\n}) {\n}\n","import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport later from \"../vendor/later/later.js\";\nimport { AbstractPartOfProjectModelMixin } from \"../quark/model/mixin/AbstractPartOfProjectModelMixin.js\";\n/**\n * This is a calendar interval mixin.\n *\n * Can be either a static time interval (if [[startDate]]/[[endDate]] are specified) or recurrent time interval\n * ([[recurrentStartDate]]/[[recurrentEndDate]]).\n *\n * By default it defines a non-working period ([[isWorking]] field has default value `false`),\n * but can also define an explicit working time, for example to override some previous period.\n *\n * You probably don't need to create instances of this mixin directly, instead you pass its configuration object to the [[AbstractCalendarMixin.addInterval]]\n */\nexport class CalendarIntervalMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarIntervalMixin extends base {\n        static get fields() {\n            return [\n                'name',\n                { name: 'startDate', type: 'date' },\n                { name: 'endDate', type: 'date' },\n                'recurrentStartDate',\n                'recurrentEndDate',\n                'cls',\n                'iconCls',\n                { name: 'isWorking', type: 'boolean', defaultValue: false },\n                { name: 'priority', type: 'number' }\n            ];\n        }\n        getCalendar() {\n            return this.stores[0].calendar;\n        }\n        resetPriority() {\n            this.priorityField = null;\n            this.getCalendar().getDepth();\n        }\n        // not just `getPriority` to avoid clash with auto-generated getter in the subclasses\n        getPriorityField() {\n            if (this.priorityField != null)\n                return this.priorityField;\n            // 0 - 10000 interval is reserved for \"unspecified time\" intervals\n            // then 10000 - 10100, 10100-10200, ... etc intervals are for the calendars at depth 0, 1, ... etc\n            let base = 10000 + this.getCalendar().getDepth() * 100;\n            let priority = this.priority;\n            if (priority == null) {\n                // recurrent intervals are considered \"base\" and have lower priority\n                // static intervals are considered special case overrides and have higher priority\n                priority = this.isRecurrent() ? 20 : 30;\n            }\n            // intervals from parent calendars will have lower priority\n            return this.priorityField = base + priority;\n        }\n        /**\n         * Whether this interval is recurrent (both [[recurrentStartDate]] and [[recurrentEndDate]] are present and parsed correctly\n         * by the `later` library)\n         */\n        isRecurrent() {\n            return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());\n        }\n        /**\n         * Whether this interval is static - both [[startDate]] and [[endDate]] are present.\n         */\n        isStatic() {\n            return Boolean(this.startDate && this.endDate);\n        }\n        /**\n         * Helper method to parse [[recurrentStartDate]] and [[recurrentEndDate]] field values.\n         * @param {Object|String} schedule Recurrence schedule\n         * @returns {Object} Processed schedule ready to be used by later.schedule() method.\n         * @private\n         */\n        parseDateSchedule(value) {\n            let schedule = value;\n            if (value && value !== Object(value)) {\n                schedule = later.parse.text(value);\n                if (schedule !== Object(schedule) || schedule.error >= 0) {\n                    // can be provided as JSON text\n                    try {\n                        schedule = JSON.parse(value);\n                    }\n                    catch (e) {\n                        return null;\n                    }\n                }\n            }\n            return schedule;\n        }\n        getStartDateSchedule() {\n            if (this.startDateSchedule)\n                return this.startDateSchedule;\n            const schedule = this.parseDateSchedule(this.recurrentStartDate);\n            return this.startDateSchedule = later.schedule(schedule);\n        }\n        getEndDateSchedule() {\n            if (this.endDateSchedule)\n                return this.endDateSchedule;\n            if (this.recurrentEndDate === 'EOD')\n                return 'EOD';\n            const schedule = this.parseDateSchedule(this.recurrentEndDate);\n            return this.endDateSchedule = later.schedule(schedule);\n        }\n    }\n    return CalendarIntervalMixin;\n}) {\n}\n","import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalMixin } from \"./CalendarIntervalMixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"../quark/store/mixin/AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a collection of {@link #CalendarIntervalMixin} items. Its a dumb collection though, the \"real\" calendar\n * is a [[AbstractCalendarMixin]] model, which is part of the [[AbstractCalendarManagerStoreMixin]].\n */\nexport class CalendarIntervalStore extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarIntervalStore extends base {\n        constructor() {\n            super(...arguments);\n            this.disableHasLoadedDataToCommitFlag = true;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CalendarIntervalMixin\n            };\n        }\n    }\n    return CalendarIntervalStore;\n}) {\n}\n","import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalMixin } from \"./CalendarIntervalMixin.js\";\n// TODO if we would be doing just:\n//      export class UnspecifiedTimeIntervalModel extends CalendarIntervalMixin ...\n// then an instance of the `CalendarIntervalMixin` `c` would : `c instanceof UnspecifiedTimeIntervalModel`,\n// because it inherit the `hasInstance` symbol\n// need to figure out how it can be handled\n// Calendar interval model denoting unspecified interval\nexport class UnspecifiedTimeIntervalModel extends Mixin([CalendarIntervalMixin], (base) => {\n    const superProto = base.prototype;\n    class UnspecifiedTimeIntervalModel extends base {\n        // TODO: why it overrides the method, is it configured with calendar instance directly?\n        getCalendar() {\n            return this.calendar;\n        }\n        // NOTE: See parent class implementation for further comments\n        getPriorityField() {\n            if (this.priorityField != null)\n                return this.priorityField;\n            return this.priorityField = this.getCalendar().getDepth();\n        }\n    }\n    return UnspecifiedTimeIntervalModel;\n}) {\n}\n","import { Mixin } from \"../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractPartOfProjectGenericMixin } from \"./AbstractPartOfProjectGenericMixin.js\";\n/**\n * This a base generic mixin for every class, that belongs to a scheduler_core project.\n *\n * It just provides getter/setter for the `project` property, along with some convenience methods\n * to access the project's stores.\n */\nexport class CorePartOfProjectGenericMixin extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectGenericMixin extends base {\n        //region Store getters\n        get eventStore() {\n            return this.project?.eventStore;\n        }\n        get resourceStore() {\n            return this.project?.resourceStore;\n        }\n        get assignmentStore() {\n            return this.project?.assignmentStore;\n        }\n        get dependencyStore() {\n            return this.project?.dependencyStore;\n        }\n        get calendarManagerStore() {\n            return this.project?.calendarManagerStore;\n        }\n        //endregion\n        //region Entity getters\n        /**\n         * Convenience method to get the instance of event by its id.\n         */\n        getEventById(id) {\n            return this.eventStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of dependency by its id.\n         */\n        getDependencyById(id) {\n            return this.dependencyStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of resource by its id.\n         */\n        getResourceById(id) {\n            return this.resourceStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of assignment by its id.\n         */\n        getAssignmentById(id) {\n            return this.assignmentStore?.getById(id);\n        }\n        /**\n         * Convenience method to get the instance of calendar by its id.\n         */\n        getCalendarById(id) {\n            return this.calendarManagerStore?.getById(id);\n        }\n    }\n    return CorePartOfProjectGenericMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CalendarIntervalStore } from \"../../calendar/CalendarIntervalStore.js\";\nimport { CalendarIteratorResult } from \"../../calendar/CalendarCache.js\";\nimport { TimeUnit } from \"../../scheduling/Types.js\";\nimport { CalendarCacheSingle } from \"../../calendar/CalendarCacheSingle.js\";\nimport { UnspecifiedTimeIntervalModel } from \"../../calendar/UnspecifiedTimeIntervalModel.js\";\nimport DateHelper from \"../../../Core/helper/DateHelper.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./mixin/AbstractPartOfProjectModelMixin.js\";\n/**\n * Calendar for project scheduling, mixed by CoreCalendarMixin and BaseCalendarMixin. It is used to mark certain time\n * intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class AbstractCalendarMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CalendarMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.version = 1;\n        }\n        // intervalStore            : CalendarIntervalStore\n        static get fields() {\n            return [\n                { name: 'version', type: 'number' },\n                'name',\n                { name: 'unspecifiedTimeIsWorking', type: 'boolean', defaultValue: true },\n                { name: 'intervals', type: 'store', subStore: true },\n                'cls',\n                'iconCls'\n            ];\n        }\n        get intervalStoreClass() {\n            return CalendarIntervalStore;\n        }\n        get intervalStore() {\n            // @ts-ignore\n            return this.meta.intervalsStore;\n        }\n        // Not a typo, name is generated from the fields name = intervals\n        initIntervalsStore(config) {\n            config.storeClass = this.intervalStoreClass;\n            // @ts-ignore\n            config.modelClass = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;\n            config.calendar = this;\n        }\n        // this method is called when the new value for the `intervals` field of this model is assigned\n        // the type of the `intervals` field is \"store\" that's why this magic\n        processIntervalsStoreData(intervals) {\n            this.bumpVersion();\n        }\n        isDefault() {\n            const project = this.getProject();\n            if (project) {\n                return this === project.defaultCalendar;\n            }\n            return false;\n        }\n        // TODO: move to Model?\n        getDepth() {\n            return this.childLevel + 1;\n        }\n        /**\n         * The core iterator method of the calendar.\n         *\n         * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties\n         * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided\n         * iterator function should return `false` at some point, to avoid infinite loops.\n         *\n         * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.\n         *\n         * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found\n         * in the given timespan. All the intervals, which are \"active\" for current interval are collected in the 3rd argument\n         * for this function - [[CalendarCacheInterval|calendarCacheInterval]]. If iterator returns `false` (checked with `===`)\n         * the iteration stops.\n         *\n         * @param scope The scope (`this` value) to execute the iterator in.\n         */\n        forEachAvailabilityInterval(options, func, scope) {\n            const maxRange = this.getProject().maxCalendarRange;\n            if (maxRange) {\n                options = Object.assign({ maxRange }, options);\n            }\n            return this.calendarCache.forEachAvailabilityInterval(options, func, scope);\n        }\n        /**\n         * This method starts at the given `date` and moves forward or backward in time, depending on `isForward`.\n         * It stops moving as soon as it accumulates the `durationMs` milliseconds of working time and returns the date\n         * at which it has stopped and remaining duration - the [[AccumulateWorkingTimeResult]] object.\n         *\n         * Normally, the remaining duration will be 0, indicating the full `durationMs` has been accumulated.\n         * However, sometimes, calendar might not be able to accumulate enough working time due to various reasons,\n         * like if it does not contain enough working time - this case will be indicated with remaining duration bigger than 0.\n         *\n         * @param date\n         * @param durationMs\n         * @param isForward\n         */\n        accumulateWorkingTime(date, durationMs, isForward) {\n            // if duration is 0 - return the same date\n            if (durationMs === 0)\n                return { finalDate: new Date(date), remainingDurationInMs: 0 };\n            if (isNaN(durationMs))\n                throw new Error(\"Invalid duration\");\n            let finalDate = date;\n            const adjustDurationToDST = this.getProject().adjustDurationToDST;\n            this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                let result = true;\n                if (calendarCacheInterval.getIsWorking()) {\n                    let diff = intervalEndDate.getTime() - intervalStartDate.getTime();\n                    if (durationMs <= diff) {\n                        if (adjustDurationToDST) {\n                            const dstDiff = isForward\n                                ? intervalStartDate.getTimezoneOffset() - (new Date(intervalStartDate.getTime() + durationMs)).getTimezoneOffset()\n                                : (new Date(intervalEndDate.getTime() - durationMs)).getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            durationMs -= dstDiff * 60 * 1000;\n                        }\n                        finalDate = isForward\n                            ? new Date(intervalStartDate.getTime() + durationMs)\n                            : new Date(intervalEndDate.getTime() - durationMs);\n                        durationMs = 0;\n                        result = false;\n                    }\n                    else {\n                        if (adjustDurationToDST) {\n                            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                            diff += dstDiff * 60 * 1000;\n                        }\n                        finalDate = isForward ? intervalEndDate : intervalStartDate;\n                        durationMs -= diff;\n                    }\n                }\n                return result;\n            });\n            return { finalDate: new Date(finalDate), remainingDurationInMs: durationMs };\n        }\n        /**\n         * Calculate the working time duration between the 2 dates, in milliseconds.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         * @param {Boolean} [allowNegative] Method ignores negative values by default, returning 0. Set to true to get\n         * negative duration.\n         */\n        calculateDurationMs(startDate, endDate, allowNegative = false) {\n            let duration = 0;\n            const multiplier = startDate.getTime() <= endDate.getTime() || !allowNegative ? 1 : -1;\n            if (multiplier < 0) {\n                [startDate, endDate] = [endDate, startDate];\n            }\n            const adjustDurationToDST = this.getProject().adjustDurationToDST;\n            this.forEachAvailabilityInterval({ startDate: startDate, endDate: endDate }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    duration += intervalEndDate.getTime() - intervalStartDate.getTime();\n                    if (adjustDurationToDST) {\n                        const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();\n                        duration += dstDiff * 60 * 1000;\n                    }\n                }\n            });\n            return duration * multiplier;\n        }\n        /**\n         * Calculate the end date of the time interval which starts at `startDate` and has `durationMs` working time duration\n         * (in milliseconds).\n         *\n         * @param startDate\n         * @param durationMs\n         */\n        calculateEndDate(startDate, durationMs) {\n            // the method goes forward by default ..unless a negative duration provided\n            const isForward = durationMs >= 0;\n            const res = this.accumulateWorkingTime(startDate, Math.abs(durationMs), isForward);\n            return res.remainingDurationInMs === 0 ? res.finalDate : null;\n        }\n        /**\n         * Calculate the start date of the time interval which ends at `endDate` and has `durationMs` working time duration\n         * (in milliseconds).\n         *\n         * @param endDate\n         * @param durationMs\n         */\n        calculateStartDate(endDate, durationMs) {\n            // the method goes backwards by default ..unless a negative duration provided\n            const isForward = durationMs <= 0;\n            const res = this.accumulateWorkingTime(endDate, Math.abs(durationMs), isForward);\n            return res.remainingDurationInMs === 0 ? res.finalDate : null;\n        }\n        /**\n         * Returns the earliest point at which a working period of time starts, following the given date.\n         * Can be the date itself, if it comes on the working time.\n         *\n         * @param date The date after which to skip the non-working time.\n         * @param isForward Whether the \"following\" means forward in time or backward.\n         */\n        skipNonWorkingTime(date, isForward = true) {\n            let workingDate;\n            const res = this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    workingDate = isForward ? intervalStartDate : intervalEndDate;\n                    return false;\n                }\n            });\n            if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)\n                return 'empty_calendar';\n            return workingDate ? new Date(workingDate) : new Date(date);\n        }\n        /**\n         * This method adds a single [[CalendarIntervalMixin]] to the internal collection of the calendar\n         */\n        addInterval(interval) {\n            return this.addIntervals([interval]);\n        }\n        /**\n         * This method adds an array of [[CalendarIntervalMixin]] to the internal collection of the calendar\n         */\n        addIntervals(intervals) {\n            this.bumpVersion();\n            return this.intervalStore.add(intervals);\n        }\n        /**\n         * This method removes a single [[CalendarIntervalMixin]] from the internal collection of the calendar\n         */\n        removeInterval(interval) {\n            return this.removeIntervals([interval]);\n        }\n        /**\n         * This method removes an array of [[CalendarIntervalMixin]] from the internal collection of the calendar\n         */\n        removeIntervals(intervals) {\n            this.bumpVersion();\n            return this.intervalStore.remove(intervals);\n        }\n        /**\n         * This method removes all intervals from the internal collection of the calendar\n         */\n        clearIntervals(silent) {\n            if (!silent) {\n                this.bumpVersion();\n            }\n            return this.intervalStore.removeAll(silent);\n        }\n        bumpVersion() {\n            this.clearCache();\n            this.version++;\n        }\n        get calendarCache() {\n            if (this.$calendarCache !== undefined)\n                return this.$calendarCache;\n            const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({\n                isWorking: this.unspecifiedTimeIsWorking\n            });\n            unspecifiedTimeInterval.calendar = this;\n            return this.$calendarCache = new CalendarCacheSingle({\n                calendar: this,\n                unspecifiedTimeInterval: unspecifiedTimeInterval,\n                intervalStore: this.intervalStore,\n                parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null\n            });\n        }\n        clearCache() {\n            // not strictly needed, we just help garbage collector\n            this.$calendarCache && this.$calendarCache.clear();\n            this.$calendarCache = undefined;\n        }\n        resetPriorityOfAllIntervals() {\n            this.traverse((calendar) => {\n                calendar.intervalStore.forEach((interval) => interval.resetPriority());\n            });\n        }\n        insertChild(child, before, silent) {\n            let res = superProto.insertChild.call(this, ...arguments);\n            if (!Array.isArray(res)) {\n                res = [res];\n            }\n            // invalidate cache of the child record, since now it should take parent into account\n            res.forEach((r) => {\n                r.bumpVersion();\n                r.resetPriorityOfAllIntervals();\n            });\n            return res;\n        }\n        joinProject() {\n            superProto.joinProject.call(this);\n            this.intervalStore.setProject(this.getProject());\n        }\n        leaveProject() {\n            superProto.leaveProject.call(this);\n            this.intervalStore.setProject(null);\n            this.clearCache();\n        }\n        doDestroy() {\n            this.leaveProject();\n            this.intervalStore.destroy();\n            super.doDestroy();\n        }\n        isDayHoliday(day) {\n            const startDate = DateHelper.clearTime(day), endDate = DateHelper.getNext(day, TimeUnit.Day);\n            let hasWorkingTime = false;\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {\n                hasWorkingTime = calendarCacheInterval.getIsWorking();\n                return !hasWorkingTime;\n            });\n            return !hasWorkingTime;\n        }\n        // TODO: tests\n        getDailyHolidaysRanges(startDate, endDate) {\n            const result = [];\n            startDate = DateHelper.clearTime(startDate);\n            while (startDate < endDate) {\n                if (this.isDayHoliday(startDate)) {\n                    result.push({\n                        startDate,\n                        endDate: DateHelper.getStartOfNextDay(startDate, true, true)\n                    });\n                }\n                startDate = DateHelper.getNext(startDate, TimeUnit.Day);\n            }\n            return result;\n        }\n        /**\n         * Returns working time ranges between the provided dates.\n         * @param startDate Start of the period to get ranges from.\n         * @param endDate End of the period to get ranges from.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         */\n        getWorkingTimeRanges(startDate, endDate) {\n            const result = [];\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (calendarCacheInterval.getIsWorking()) {\n                    const entry = calendarCacheInterval.intervals[0];\n                    result.push({\n                        name: entry.name,\n                        startDate: intervalStartDate,\n                        endDate: intervalEndDate\n                    });\n                }\n            });\n            return result;\n        }\n        /**\n         * Returns non-working time ranges between the provided dates.\n         * @param startDate Start of the period to get ranges from.\n         * @param endDate End of the period to get ranges from.\n         *\n         * @param {Date} startDate\n         * @param {Date} endDate\n         */\n        getNonWorkingTimeRanges(startDate, endDate) {\n            const result = [];\n            this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                if (!calendarCacheInterval.getIsWorking()) {\n                    const entry = calendarCacheInterval.intervals[0];\n                    result.push({\n                        name: entry.name,\n                        iconCls: entry.iconCls,\n                        cls: entry.cls,\n                        startDate: intervalStartDate,\n                        endDate: intervalEndDate\n                    });\n                }\n            });\n            return result;\n        }\n        /**\n         * Checks if there is a working time interval in the provided time range (or when just startDate is provided,\n         * checks if the date is contained inside a working time interval in this calendar)\n         * @param startDate\n         * @param [endDate]\n         * @param [fullyContained] Pass true to check if the range is fully covered by a single continuous working time block\n         */\n        isWorkingTime(startDate, endDate, fullyContained) {\n            if (fullyContained) {\n                let found;\n                const res = this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    if (calendarCacheInterval.getIsWorking() && intervalStartDate <= startDate && intervalEndDate >= endDate) {\n                        found = true;\n                        return false;\n                    }\n                });\n                if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)\n                    return false;\n                return found;\n            }\n            else {\n                // Can be Date | null | 'empty_calendar'\n                const workingTimeStart = this.skipNonWorkingTime(startDate);\n                return workingTimeStart && workingTimeStart !== 'empty_calendar' ? (endDate ? workingTimeStart < endDate : workingTimeStart.getTime() === startDate.getTime()) : false;\n            }\n        }\n    }\n    return CalendarMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectModelMixin } from './mixin/AbstractPartOfProjectModelMixin.js';\n/**\n * This is a mixin enabling events to handle assignments. It is mixed by CoreHasAssignmentsMixin and\n * BaseHasAssignmentsMixin. It provides a collection of all assignments, which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class AbstractHasAssignmentsMixin extends Mixin([AbstractPartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class HasAssignmentsMixin extends base {\n        /**\n         * If a given resource is assigned to this task, returns a [[BaseAssignmentMixin]] instance for it.\n         * Otherwise returns `null`\n         */\n        getAssignmentFor(resource) {\n            // Bucket `assigned` might not be set up yet when using delayed calculations\n            for (const assignment of this.assigned ?? []) {\n                if (assignment.resource === resource)\n                    return assignment;\n            }\n            return null;\n        }\n        isAssignedTo(resource) {\n            return Boolean(this.getAssignmentFor(resource));\n        }\n        /**\n         * A method which assigns a resource to the current event\n         */\n        async assign(resource) {\n            //<debug>\n            // Preconditions:\n            if (this.getAssignmentFor(resource))\n                throw new Error('Resource can\\'t be assigned twice to the same task');\n            //</debug>\n            const assignmentCls = this.project.assignmentStore.modelClass;\n            this.addAssignment(new assignmentCls({\n                event: this,\n                resource: resource\n            }));\n            return this.commitAsync();\n        }\n        /**\n         * A method which unassigns a resource from the current event\n         */\n        async unassign(resource) {\n            const assignment = this.getAssignmentFor(resource);\n            //<debug>\n            if (!assignment)\n                throw new Error(`Can't unassign resource \\`${resource}\\` from task \\`${this}\\` - resource is not assigned to the task!`);\n            //</debug>\n            this.removeAssignment(assignment);\n            return this.commitAsync();\n        }\n        leaveProject() {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // @ts-ignore\n            if (this.isInActiveTransaction && this.assigned) {\n                const eventStore = this.getEventStore();\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => eventStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this, ...arguments);\n        }\n        remove() {\n            if (this.parent) {\n                // need to get the event store in advance, because after removal the project reference will be cleared (all that is what provide\n                // references to all stores\n                const eventStore = this.getEventStore();\n                superProto.remove.call(this);\n                eventStore && eventStore.afterEventRemoval();\n            }\n            else {\n                return superProto.remove.call(this);\n            }\n        }\n        // template methods, overridden in scheduling modes mixins\n        // should probably be named something like \"onEventAssignmentAdded\"\n        // should be a listener for the `add` event of the assignment store instead\n        addAssignment(assignment) {\n            this.getProject().assignmentStore.add(assignment);\n            return assignment;\n        }\n        // should be a listener for the `remove` event of the assignment store instead\n        removeAssignment(assignment) {\n            this.getProject().assignmentStore.remove(assignment);\n            return assignment;\n        }\n    }\n    return HasAssignmentsMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport { AbstractPartOfProjectModelMixin } from \"./AbstractPartOfProjectModelMixin.js\";\n/**\n * This a mixin for every Model that belongs to a scheduler_core project.\n *\n * It adds functions needed to calculate invalidated fields on project commit.\n */\nexport class CorePartOfProjectModelMixin extends Mixin([\n    AbstractPartOfProjectModelMixin,\n    CorePartOfProjectGenericMixin,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectModelMixin extends base {\n        constructor() {\n            super(...arguments);\n            // Flag set during calculation\n            this.$isCalculating = false;\n            // Proposed changes\n            this.$changed = {};\n            // Value before proposed change, for buckets that need to update data early\n            this.$beforeChange = {};\n        }\n        get isInActiveTransaction() {\n            return true;\n        }\n        // Invalidate record upon joining project, leads to a buffered commit\n        joinProject() {\n            this.invalidate();\n        }\n        // Trigger a buffered commit when leaving the project\n        leaveProject(isReplacing = false) {\n            superProto.leaveProject.call(this, isReplacing);\n            this.project?.bufferedCommitAsync();\n        }\n        /**\n         * Invalidates this record, queueing it for calculation on project commit.\n         */\n        invalidate() {\n            this.project?.invalidate(this);\n        }\n        /**\n         * Used to retrieve the proposed (before 'dataReady') or current (after 'dataReady') value for a field.\n         * If there is no proposed change, it is functionally equal to a normal `record.get()` call.\n         */\n        getCurrentOrProposed(fieldName) {\n            if (fieldName in this.$changed && this.$changed[fieldName] !== true) {\n                return this.$changed[fieldName];\n            }\n            return this.get(fieldName) ?? null;\n        }\n        /**\n         * Determines if the specified field has a value or not, value can be either current or proposed.\n         */\n        hasCurrentOrProposed(fieldName) {\n            return ((fieldName in this.$changed) && this.$changed[fieldName] != true) || this.get(fieldName) != null;\n        }\n        /**\n         * Propose changes, to be considered during calculation. Also invalidates the record.\n         */\n        propose(changes) {\n            // @ts-ignore\n            if (this.project || this.recurringTimeSpan?.project) {\n                const keys = Object.keys(changes);\n                for (let i = 0; i < keys.length; i++) {\n                    const key = keys[i];\n                    this.$changed[key] = changes[key];\n                }\n                this.invalidate();\n            }\n            else {\n                // If no project, behave as a normal model would\n                this.set(changes);\n            }\n        }\n        /**\n         * Similar to propose, but with more options. Mostly used by buckets, since they need data to update early.\n         */\n        setChanged(field, value, invalidate = true, setData = false) {\n            const me = this;\n            me.$changed[field] = value;\n            // Buckets need to keep data up to date immediately\n            if (setData) {\n                if (!(field in me.$beforeChange)) {\n                    me.$beforeChange[field] = me.get(field);\n                }\n                me.setData(field, value);\n            }\n            invalidate && me.invalidate();\n        }\n        /**\n         * Hook called before project refresh, override and calculate required changes in subclasses\n         */\n        calculateInvalidated() { }\n        /**\n         * Called after project refresh, before dataReady. Announce updated data\n         */\n        finalizeInvalidated(silent = false) {\n            const me = this;\n            me.$isCalculating = true;\n            if (!silent) {\n                // First silently revert any data change (used by buckets), otherwise it wont be detected by `set()`\n                me.setData(me.$beforeChange);\n                // Then do a proper set\n                me.set(me.$changed);\n            }\n            else {\n                me.setData(me.$changed);\n            }\n            me.$changed = {};\n            me.$beforeChange = {};\n            me.$isCalculating = false;\n        }\n    }\n    return CorePartOfProjectModelMixin;\n}) {\n}\n","import { CI } from \"../../ChronoGraph/collection/Iterator.js\";\nexport const isNotNumber = (value) => Number(value) !== value;\nexport const CIFromSetOrArrayOrValue = (value) => {\n    if (value instanceof Set || value instanceof Array)\n        return CI(value);\n    return CI([value]);\n};\nexport const delay = (value) => new Promise(resolve => setTimeout(resolve, value));\nexport const format = (format, ...values) => {\n    return format.replace(/{(\\d+)}/g, (match, number) => typeof values[number] !== 'undefined' ? values[number] : match);\n};\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { CIFromSetOrArrayOrValue } from \"../../util/Functions.js\";\n// Shared functionality for CoreAssignmentStore & ChronoAssignmentStore\nexport class AbstractAssignmentStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n            this.allAssignmentsForRemoval = false;\n        }\n        remove(records, silent) {\n            this.assignmentsForRemoval = CIFromSetOrArrayOrValue(records).toSet();\n            const res = superProto.remove.call(this, records, silent);\n            this.assignmentsForRemoval.clear();\n            return res;\n        }\n        removeAll(silent) {\n            this.allAssignmentsForRemoval = true;\n            const res = superProto.removeAll.call(this, silent);\n            this.allAssignmentsForRemoval = false;\n            return res;\n        }\n    }\n    return AbstractAssignmentStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\n// Shared functionality for CoreCalendarManagerStoreMixin & ChronoCalendarManagerStoreMixin\nexport class AbstractCalendarManagerStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractCalendarManagerStoreMixin extends base {\n        // special handling to destroy calendar models as part of destroying this store\n        doDestroy() {\n            const records = [];\n            // When chained, traverse can be called on destroyed nodes.\n            if (!this.rootNode?.isDestroyed) {\n                this.traverse(record => records.push(record));\n            }\n            super.doDestroy();\n            records.forEach(record => record.destroy());\n        }\n    }\n    return AbstractCalendarManagerStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nimport { CIFromSetOrArrayOrValue } from '../../util/Functions.js';\n// Shared functionality for CoreDependencyStore & ChronoDependencyStore\nexport class AbstractDependencyStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.dependenciesForRemoval = new Set();\n            this.allDependenciesForRemoval = false;\n        }\n        remove(records, silent) {\n            this.dependenciesForRemoval = CIFromSetOrArrayOrValue(records).toSet();\n            const res = superProto.remove.call(this, records, silent);\n            this.dependenciesForRemoval.clear();\n            return res;\n        }\n        removeAll(silent) {\n            this.allDependenciesForRemoval = true;\n            const res = superProto.removeAll.call(this, silent);\n            this.allDependenciesForRemoval = false;\n            return res;\n        }\n    }\n    return AbstractDependencyStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nconst dataAddRemoveActions = {\n    splice: 1,\n    clear: 1\n};\n// Shared functionality for CoreEventStore & ChronoEventStore\nexport class AbstractEventStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractEventStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n            // TODO it seems this property is no longer used\n            // need to remove and probably do the same for `assignmentsForRemoval`\n            this.dependenciesForRemoval = new Set();\n        }\n        // we need `onDataChange` for `syncDataOnLoad` option to work\n        onDataChange(event) {\n            // remove from a filter action must be ignored.\n            const isAddRemove = dataAddRemoveActions[event.action];\n            super.onDataChange(event);\n            if (isAddRemove && event.removed?.length)\n                this.afterEventRemoval();\n        }\n        // it seems `onDataChange` is not triggered for `remove` with `silent` flag\n        remove(records, silent) {\n            const res = superProto.remove.call(this, records, silent);\n            this.afterEventRemoval();\n            return res;\n        }\n        // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`\n        removeAll(silent) {\n            const res = superProto.removeAll.call(this, silent);\n            this.afterEventRemoval();\n            return res;\n        }\n        onNodeRemoveChild(parent, children, index, flags) {\n            // @ts-ignore\n            const removed = superProto.onNodeRemoveChild.call(this, ...arguments);\n            this.afterEventRemoval();\n            return removed;\n        }\n        afterEventRemoval() {\n            const { assignmentsForRemoval, dependenciesForRemoval } = this;\n            // Can be called from `set data` during construction\n            if (!assignmentsForRemoval)\n                return;\n            // ORDER IS IMPORTANT!\n            // First remove assignments\n            const assignmentStore = this.getAssignmentStore();\n            if (assignmentStore && !assignmentStore.allAssignmentsForRemoval && assignmentsForRemoval.size) {\n                const toRemove = [...assignmentsForRemoval].filter(assignment => !assignmentStore.assignmentsForRemoval.has(assignment));\n                toRemove.length > 0 && assignmentStore.remove(toRemove);\n            }\n            assignmentsForRemoval.clear();\n            // Then remove dependencies\n            const dependencyStore = this.getDependencyStore();\n            if (dependencyStore && !dependencyStore.allDependenciesForRemoval && dependenciesForRemoval.size) {\n                const toRemove = [...dependenciesForRemoval].filter(dependency => !dependencyStore.dependenciesForRemoval.has(dependency));\n                toRemove.length > 0 && dependencyStore.remove(toRemove);\n            }\n            dependenciesForRemoval.clear();\n        }\n        processRecord(eventRecord, isDataset = false) {\n            if (!this.project?.isRepopulatingStores) {\n                const existingRecord = this.getById(eventRecord.id);\n                const isReplacing = existingRecord && existingRecord !== eventRecord;\n                //@ts-ignore\n                if (isReplacing && existingRecord.assigned) {\n                    // TODO: Type\n                    //@ts-ignore\n                    for (const assignment of existingRecord.assigned) {\n                        assignment.event = eventRecord;\n                    }\n                }\n            }\n            return eventRecord;\n        }\n    }\n    return AbstractEventStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/Mixin.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./mixin/AbstractPartOfProjectStoreMixin.js\";\nconst dataAddRemoveActions = {\n    splice: 1,\n    clear: 1\n};\n// Shared functionality for CoreResourceStore & ChronoResourceStore\nexport class AbstractResourceStoreMixin extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class AbstractResourceStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.assignmentsForRemoval = new Set();\n        }\n        // we need `onDataChange` for `syncDataOnLoad` option to work\n        onDataChange(event) {\n            // remove from a filter action must be ignored.\n            const isAddRemove = dataAddRemoveActions[event.action];\n            super.onDataChange(event);\n            if (isAddRemove && event.removed?.length)\n                this.afterResourceRemoval();\n        }\n        // it seems `onDataChange` is not triggered for `remove` with `silent` flag\n        remove(records, silent) {\n            const res = superProto.remove.call(this, records, silent);\n            this.afterResourceRemoval();\n            return res;\n        }\n        // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`\n        removeAll(silent) {\n            const res = superProto.removeAll.call(this, silent);\n            this.afterResourceRemoval();\n            return res;\n        }\n        afterResourceRemoval() {\n            // TODO: Ask nick, have tried making it get correct type by changing AbstractProjectMixin. But no luck\n            const assignmentStore = this.getAssignmentStore();\n            if (assignmentStore && !assignmentStore.allAssignmentsForRemoval) {\n                const assignmentsForRemoval = [...this.assignmentsForRemoval].filter(assignment => !assignmentStore.assignmentsForRemoval.has(assignment));\n                assignmentsForRemoval.length > 0 && assignmentStore.remove(assignmentsForRemoval);\n            }\n            this.assignmentsForRemoval.clear();\n        }\n        processRecord(resourceRecord, isDataset = false) {\n            const existingRecord = this.getById(resourceRecord.id);\n            const isReplacing = existingRecord && existingRecord !== resourceRecord;\n            if (isReplacing) {\n                // TODO: There is no ResourceMixin at the lowest level, cannot type correctly without it\n                //@ts-ignore\n                for (const assignment of existingRecord.assigned || []) {\n                    assignment.resource = resourceRecord;\n                }\n            }\n            return resourceRecord;\n        }\n    }\n    return AbstractResourceStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport DateHelper from \"../../../../Core/helper/DateHelper.js\";\n/**\n * Core event entity mixin type.\n *\n * At this level event is only aware about its dates\n * The functionality, related to the assignments etc is provided in other mixins.\n */\nexport class CoreEventMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreEventMixin extends base {\n        constructor() {\n            super(...arguments);\n            this._startDate = null;\n            this._endDate = null;\n            this._duration = null;\n        }\n        // Proper engine defines these fields since they enter graph, thus we need them\n        static get fields() {\n            return [\n                { name: 'startDate', type: 'date' },\n                { name: 'endDate', type: 'date' },\n                { name: 'duration', type: 'number' },\n                { name: 'durationUnit', type: 'durationunit', defaultValue: 'day' }\n            ];\n        }\n        // Getters return current or proposed value\n        get startDate() { return this._startDate ?? this.get('startDate') ?? null; }\n        get endDate() { return this._endDate ?? this.get('endDate') ?? null; }\n        get duration() { return this._duration ?? this.get('duration') ?? null; }\n        // Route all setting through applyXX (setStartDate, startDate = , set('startDate'), batching)\n        set startDate(value) { this.proposeStartDate(value); }\n        set endDate(value) { this.proposeEndDate(value); }\n        set duration(value) { this.proposeDuration(value); }\n        //region Edge case normalization\n        inSet(field, value, silent, fromRelationUpdate, skipAccessors) {\n            const me = this;\n            // Catch \"normal\" set calls\n            if (me.project && !me.project.isWritingData && typeof field !== 'string' && !skipAccessors) {\n                // Flag fields as changed even if we are given a no-change value, to let calculations take decision on\n                // whether to keep duration or not\n                if ('startDate' in field && !('startDate' in me.$changed)) {\n                    me.$changed.startDate = true;\n                    me.invalidate();\n                }\n                if ('endDate' in field && !('endDate' in me.$changed)) {\n                    me.$changed.endDate = true;\n                    me.invalidate();\n                }\n            }\n            // @ts-ignore\n            return superProto.inSet.call(me, field, value, silent, fromRelationUpdate, skipAccessors);\n        }\n        //endregion\n        //region StartDate\n        getStartDate() {\n            return this.startDate;\n        }\n        proposeStartDate(startDate, keepDuration = !('endDate' in this.$changed)) {\n            if (this.inSetting || startDate?.getTime() !== this.startDate?.getTime()) {\n                this._startDate = startDate;\n                this.propose({ startDate, keepDuration });\n            }\n        }\n        async setStartDate(startDate, keepDuration = true) {\n            this.proposeStartDate(startDate, keepDuration);\n            return this.project?.commitAsync();\n        }\n        //endregion\n        //region EndDate\n        getEndDate() {\n            return this.endDate;\n        }\n        proposeEndDate(endDate, keepDuration = false) {\n            if (this.inSetting || endDate?.getTime() !== this.endDate?.getTime()) {\n                this._endDate = endDate;\n                this.propose({ endDate, keepDuration });\n            }\n        }\n        async setEndDate(endDate, keepDuration = false) {\n            this.proposeEndDate(endDate, keepDuration);\n            return this.project?.commitAsync();\n        }\n        //endregion\n        //region Duration\n        getDuration() {\n            return this.duration;\n        }\n        proposeDuration(duration, unit, keepStart = true) {\n            this._duration = duration;\n            this.propose({ duration, keepStart });\n            if (unit)\n                this.propose({ durationUnit: unit });\n        }\n        async setDuration(duration, unit, keepStart = true) {\n            this.proposeDuration(duration, unit, keepStart);\n            return this.project?.commitAsync();\n        }\n        getDurationUnit() {\n            return this.durationUnit;\n        }\n        //endregion\n        // When joining as part of inline data, store is available. If joining through load, it is passed\n        joinProject() {\n            const me = this;\n            const changed = me.$changed;\n            const startDate = me.getCurrentOrProposed('startDate');\n            const endDate = me.getCurrentOrProposed('endDate');\n            const duration = me.getCurrentOrProposed('duration');\n            // Initial values should be considered changed, to be normalized\n            if (startDate != null)\n                changed.startDate = me._startDate = startDate;\n            if (endDate != null)\n                changed.endDate = me._endDate = endDate;\n            if (duration != null)\n                changed.duration = me._duration = duration;\n            // Resolve assignments when event joins project after load\n            if (me.eventStore && !me.eventStore.isLoadingData) {\n                const unresolved = me.assignmentStore?.storage.findItem('event', null);\n                if (unresolved) {\n                    // To avoid n² iterations over raw assignments we cache them by raw eventId, which saves us\n                    // some iterations over the storage\n                    // https://github.com/bryntum/support/issues/3141\n                    const cachedAssignments = me.assignmentStore?.storage.findItem('eventId', me.id);\n                    if (cachedAssignments) {\n                        for (const assignment of cachedAssignments) {\n                            assignment.setChanged('event', me);\n                        }\n                    }\n                    else {\n                        for (const assignment of unresolved) {\n                            if (assignment.getCurrentOrProposed('event') === me.id) {\n                                assignment.setChanged('event', me);\n                            }\n                        }\n                    }\n                }\n            }\n            superProto.joinProject.call(me);\n        }\n        // Mimic how proper engine applies values\n        applyValue(useProp, key, value, skipAccessors, field) {\n            // @ts-ignore\n            if (this.project || this.recurringTimeSpan?.project) {\n                if (key === 'startDate' || key == 'duration' || key === 'endDate') {\n                    useProp = true;\n                    // Update cached value\n                    this['_' + key] = value;\n                }\n                if (skipAccessors) {\n                    useProp = false;\n                }\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessors, field);\n        }\n        // Catch changes from batches etc. In which case it is sometimes expected for data to be available directly\n        afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n            if (!this.$isCalculating && !skipAccessors) {\n                // In certain scenarios data is expected to be available of the bat, messy!\n                this.setData({\n                    startDate: this.getCurrentOrProposed('startDate'),\n                    endDate: this.getCurrentOrProposed('endDate'),\n                    duration: this.getCurrentOrProposed('duration'),\n                    durationUnit: this.getCurrentOrProposed('durationUnit')\n                });\n            }\n            superProto.afterChange.call(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);\n        }\n        // Normalizes dates & duration\n        calculateInvalidated() {\n            const me = this;\n            const changed = me.$changed;\n            const changedStart = 'startDate' in changed;\n            const changedEnd = 'endDate' in changed;\n            const changedDuration = 'duration' in changed;\n            const { startDate, endDate, duration, keepDuration, keepStart } = changed;\n            let calculate = null;\n            // Only start changed\n            if (changedStart && !changedEnd && !changedDuration) {\n                // Also null end when nulling start (keeping duration)\n                if (startDate === null) {\n                    changed.endDate = null;\n                }\n                // Start after end without keeping duration -> move end to start\n                else if (me.hasCurrentOrProposed('endDate') && startDate > me.getCurrentOrProposed('endDate') && !keepDuration) {\n                    changed.endDate = startDate;\n                    changed.duration = 0;\n                }\n                // Start changed and we either have a duration that we want to keep or no end -> calculate end\n                else if (me.hasCurrentOrProposed('duration') && (keepDuration || !me.hasCurrentOrProposed('endDate'))) {\n                    calculate = 'endDate';\n                }\n                // Start change and we have an end already -> calculate duration\n                else if (me.hasCurrentOrProposed('endDate')) {\n                    calculate = 'duration';\n                }\n            }\n            // Only end changed\n            else if (!changedStart && changedEnd && !changedDuration) {\n                // Also null start when nulling end (keeping duration)\n                if (endDate === null) {\n                    changed.startDate = null;\n                }\n                // End before start without keeping duration -> move start to end\n                else if (me.hasCurrentOrProposed('startDate') && !keepDuration && endDate !== true && endDate < me.getCurrentOrProposed('startDate')) {\n                    changed.startDate = endDate;\n                    changed.duration = 0;\n                }\n                // End changed and we either have a duration that we want to keep or no start -> calculate start\n                else if (me.hasCurrentOrProposed('duration') && (keepDuration || !me.hasCurrentOrProposed('startDate'))) {\n                    calculate = 'startDate';\n                }\n                // End changed and we have a start already -> calculate duration\n                else if (me.hasCurrentOrProposed('startDate')) {\n                    calculate = 'duration';\n                }\n            }\n            // Only duration changed\n            else if (!changedStart && !changedEnd && changedDuration) {\n                // Also null end when nulling duration (keeping start)\n                if (duration === null) {\n                    changed.endDate = null;\n                }\n                // Duration changed and we either have a start that we want to keep or no end -> calculate end\n                else if (me.hasCurrentOrProposed('startDate') && (keepStart || !me.hasCurrentOrProposed('endDate'))) {\n                    if (keepStart && changed.duration < 0) {\n                        changed.duration = 0;\n                    }\n                    calculate = 'endDate';\n                }\n                // Duration changed and we have an end already -> calculate start\n                else if (me.hasCurrentOrProposed('endDate')) {\n                    calculate = 'startDate';\n                }\n            }\n            // Start and end change, affect duration\n            else if (changedStart && changedEnd && !changedDuration) {\n                // Both nulled, null duration\n                if (startDate === null && endDate === null) {\n                    changed.duration = null;\n                }\n                // Other cases -> calculate duration\n                else {\n                    calculate = 'duration';\n                }\n            }\n            // Start and duration change -> calculate end\n            else if (changedStart && !changedEnd && changedDuration) {\n                calculate = 'endDate';\n            }\n            // End and duration changed -> calculate start\n            else if (!changedStart && changedEnd && changedDuration) {\n                calculate = 'startDate';\n            }\n            // All changed -> calculate whichever is null or by default end to be sure things add up\n            else if (changedStart && changedEnd && changedDuration) {\n                if (duration == null) {\n                    calculate = 'duration';\n                }\n                else if (startDate == null) {\n                    calculate = 'startDate';\n                }\n                else {\n                    calculate = 'endDate';\n                }\n            }\n            // Normalize if needed\n            const currentOrProposedStartDate = me.getCurrentOrProposed('startDate');\n            const currentOrProposedEndDate = me.getCurrentOrProposed('endDate');\n            const currentOrProposedDuration = me.getCurrentOrProposed('duration');\n            const currentOrProposedDurationUnit = me.getCurrentOrProposed('durationUnit');\n            let hourDuration, targetDuration;\n            switch (calculate) {\n                case 'startDate':\n                    changed.startDate = DateHelper.add(currentOrProposedEndDate, -currentOrProposedDuration, currentOrProposedDurationUnit);\n                    break;\n                case 'endDate':\n                    // convert proposed duration to hours to safely add over DST\n                    hourDuration = DateHelper.as('hour', currentOrProposedDuration, currentOrProposedDurationUnit);\n                    // convert calculated duration to task duration in task duration unit\n                    targetDuration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, 'h');\n                    changed.endDate = DateHelper.add(currentOrProposedStartDate, targetDuration, currentOrProposedDurationUnit);\n                    break;\n                case 'duration':\n                    // convert proposed duration to hours to safely add over DST\n                    hourDuration = DateHelper.diff(currentOrProposedStartDate, currentOrProposedEndDate, 'h');\n                    // convert calculated duration to task duration in task duration unit\n                    changed.duration = DateHelper.as(currentOrProposedDurationUnit, hourDuration, 'h');\n                    break;\n            }\n            if ('startDate' in changed && changed.startDate !== true)\n                this._startDate = changed.startDate;\n            if ('endDate' in changed && changed.endDate !== true)\n                this._endDate = changed.endDate;\n            if ('duration' in changed && changed.duration !== true)\n                this._duration = changed.duration;\n            delete changed.keepDuration;\n            delete changed.keepStart;\n        }\n    }\n    return CoreEventMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\n/**\n * Core resource model class.\n */\nexport class CoreResourceMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreResourceMixin extends base {\n        get assigned() {\n            return this.project?.assignmentStore.getResourcesAssignments(this);\n        }\n        joinProject() {\n            // Set up assignment -> resource mapping when joining store after assignment (skip during load)\n            // (note that there is no resourceStore yet when loading inline data, thus the first part of the condition)\n            if (this.resourceStore && !this.resourceStore.isLoadingData) {\n                this.assignmentStore?.query(a => a.get('resource') === this.id).forEach(unresolved => unresolved.setChanged('resource', this));\n            }\n            superProto.joinProject.call(this);\n        }\n        leaveProject(isReplacing = false) {\n            // `this.assigned` will be empty if model is added to project and then removed immediately\n            // w/o any propagations\n            // when replacing a resource, the assignments should be left intact\n            if (this.assigned && !isReplacing) {\n                const resourceStore = this.resourceStore;\n                // to batch the assignments removal, we don't remove the assignments right away, but instead\n                // add them for the batched removal to the `assignmentsForRemoval` property of the event store\n                this.assigned.forEach(assignment => resourceStore.assignmentsForRemoval.add(assignment));\n            }\n            superProto.leaveProject.call(this);\n        }\n        applyValue(useProp, key, value, skipAccessor, field) {\n            // Changing id on a resource should update resourceId on its assignments\n            // (note that field might not exist, if user supplies data for undefined fields)\n            if (field?.name === 'id') {\n                this.assigned.forEach(assignment => {\n                    assignment.set('resourceId', value);\n                });\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);\n        }\n    }\n    return CoreResourceMixin;\n}) {\n}\n","import { Mixin, isInstanceOf } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport { CoreResourceMixin } from \"./CoreResourceMixin.js\";\n/**\n * Core assignment model class. It just contains references to the [[CoreEventMixin|event]] and [[CoreResourceMixin|resource]] being assigned.\n */\nexport class CoreAssignmentMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreAssignmentMixin extends base {\n        // Fields declared in the Model way, existing decorators all assume ChronoGraph is used\n        static get fields() {\n            return [\n                // isEqual required to properly detect changed resource / event\n                { name: 'resource', isEqual: (a, b) => a === b, persist: false },\n                { name: 'event', isEqual: (a, b) => a === b, persist: false }\n            ];\n        }\n        // Resolve early + update indices to have buckets ready before commit\n        setChanged(field, value, invalidate) {\n            const { assignmentStore, eventStore, resourceStore, project } = this;\n            let update = false;\n            if (field === 'event') {\n                const event = isInstanceOf(value, CoreEventMixin) ? value : eventStore?.$master.getById(value);\n                if (event)\n                    update = true;\n                value = event || value;\n            }\n            if (field === 'resource') {\n                const resource = isInstanceOf(value, CoreResourceMixin) ? value : resourceStore?.$master.getById(value);\n                if (resource)\n                    update = true;\n                value = resource || value;\n            }\n            // Passing true as last arg, bucket expected to work before commit\n            superProto.setChanged.call(this, field, value, invalidate, true);\n            // Update on resolve, if this is a single operation and record is part of project (might be standalone record)\n            if (assignmentStore && update && !project.isPerformingCommit && !assignmentStore.isLoadingData && !resourceStore.isLoadingData && !assignmentStore.skipInvalidateIndices) {\n                assignmentStore.invalidateIndices();\n            }\n        }\n        // Resolve event and resource when joining project\n        joinProject() {\n            superProto.joinProject.call(this);\n            this.setChanged('event', this.get('event'));\n            this.setChanged('resource', this.get('resource'));\n        }\n        // Resolved resource & event as part of commit\n        // Normally done earlier in setChanged, but stores might not have been available yet at that point\n        calculateInvalidated() {\n            // Changed values, should be used instead of current where available\n            let { event = this.event, resource = this.resource } = this.$changed;\n            if (event !== null && !(isInstanceOf(event, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(event);\n                if (resolved)\n                    this.setChanged('event', resolved, false);\n            }\n            if (resource !== null && !(isInstanceOf(resource, CoreResourceMixin))) {\n                const resolved = this.resourceStore?.getById(resource);\n                if (resolved)\n                    this.setChanged('resource', resolved, false);\n            }\n        }\n        // resourceId and eventId required to be available for new datasets\n        finalizeInvalidated(silent) {\n            const changed = this.$changed;\n            if ('resource' in changed) {\n                changed.resourceId = changed.resource?.isModel ? changed.resource.id : changed.resource;\n            }\n            if ('event' in changed) {\n                changed.eventId = changed.event?.isModel ? changed.event.id : changed.event;\n            }\n            superProto.finalizeInvalidated.call(this, silent);\n        }\n        //region Event\n        set event(event) {\n            this.setChanged('event', event);\n        }\n        get event() {\n            const event = this.get('event');\n            // Engine returns null instead of id when unresolved\n            return event?.id != null ? event : null;\n        }\n        //endregion\n        //region Resource\n        set resource(resource) {\n            this.setChanged('resource', resource);\n        }\n        get resource() {\n            const resource = this.get('resource');\n            // Engine returns null instead of id when unresolved\n            return resource?.id != null ? resource : null;\n        }\n    }\n    return CoreAssignmentMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport { AbstractPartOfProjectStoreMixin } from \"./AbstractPartOfProjectStoreMixin.js\";\n/**\n * This a mixin for every Store, that belongs to a scheduler_core project.\n */\nexport class CorePartOfProjectStoreMixin extends Mixin([\n    AbstractPartOfProjectStoreMixin,\n    CorePartOfProjectGenericMixin,\n    Store\n], (base) => {\n    const superProto = base.prototype;\n    class CorePartOfProjectStoreMixin extends base {\n        setProject(project) {\n            const result = superProto.setProject.call(this, project);\n            if (project)\n                this.joinProject(project);\n            return result;\n        }\n        joinProject(project) { }\n        onCommitAsync() { }\n    }\n    return CorePartOfProjectStoreMixin;\n}) {\n}\n","import { CoreAssignmentMixin } from \"../model/scheduler_core/CoreAssignmentMixin.js\";\nimport { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { AbstractAssignmentStoreMixin } from \"./AbstractAssignmentStoreMixin.js\";\nconst emptySet = new Set();\n/**\n * A store mixin class, that represent collection of all assignments in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreAssignmentStoreMixin extends Mixin([AbstractAssignmentStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreAssignmentStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.skipInvalidateIndices = false;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CoreAssignmentMixin,\n                storage: {\n                    extraKeys: [\n                        { property: 'event', unique: false },\n                        { property: 'resource', unique: false },\n                        { property: 'eventId', unique: false }\n                    ]\n                }\n            };\n        }\n        set data(value) {\n            this.allAssignmentsForRemoval = true;\n            super.data = value;\n            this.allAssignmentsForRemoval = false;\n        }\n        getEventsAssignments(event) {\n            return this.storage.findItem('event', event, true) || emptySet;\n        }\n        getResourcesAssignments(resource) {\n            return this.storage.findItem('resource', resource.$original, true) || emptySet;\n        }\n        updateIndices() {\n            this.storage.rebuildIndices();\n        }\n        invalidateIndices() {\n            this.storage.invalidateIndices();\n        }\n        afterLoadData() {\n            this.eventStore && this.linkAssignments(this.eventStore, 'event');\n            this.resourceStore && this.linkAssignments(this.resourceStore, 'resource');\n        }\n        // Link events/resources to assignments, called when those stores are populated or joined to project\n        linkAssignments(store, modelName) {\n            // If we are passed a chained store, the ultimate source of truth is the masterStore\n            store = store.masterStore || store;\n            const unresolved = this.count && this.storage.findItem(modelName, null, true);\n            if (unresolved) {\n                for (const assignment of unresolved) {\n                    const record = store.getById(assignment.getCurrentOrProposed(modelName));\n                    if (record)\n                        assignment.setChanged(modelName, record);\n                }\n                this.invalidateIndices();\n            }\n        }\n        // Unlink events/resources from assignments, called when those stores are cleared\n        unlinkAssignments(modelName) {\n            // Invalidate links to events/resources, need to link to new records so set it back to the id (might be resource or resourceId)\n            // As assignment.resource returns null if it's an id, need to check for that in data\n            this.forEach(assignment => assignment.setChanged(modelName, assignment[modelName]?.id ?? assignment?.getData(modelName) ?? assignment[modelName + 'Id']));\n            this.invalidateIndices();\n        }\n        onCommitAsync() {\n            this.updateIndices();\n        }\n    }\n    return CoreAssignmentStoreMixin;\n}) {\n}\n","import { CorePartOfProjectModelMixin } from '../mixin/CorePartOfProjectModelMixin.js';\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { AbstractCalendarMixin } from \"../AbstractCalendarMixin.js\";\n/**\n * The calendar for project scheduling, it is used to mark certain time intervals as \"non-working\" and ignore them during scheduling.\n *\n * The calendar consists from several [[CalendarIntervalMixin|intervals]]. The intervals can be either static or recurrent.\n */\nexport class CoreCalendarMixin extends Mixin([AbstractCalendarMixin, CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreCalendarMixin extends base {\n    }\n    return CoreCalendarMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from './mixin/CorePartOfProjectStoreMixin.js';\nimport { CoreCalendarMixin } from '../model/scheduler_core/CoreCalendarMixin.js';\nimport { AbstractCalendarManagerStoreMixin } from \"./AbstractCalendarManagerStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all calendars in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreCalendarManagerStoreMixin extends Mixin([AbstractCalendarManagerStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreCalendarManagerStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                tree: true,\n                modelClass: CoreCalendarMixin\n            };\n        }\n    }\n    return CoreCalendarManagerStoreMixin;\n}) {\n}\n","import { CorePartOfProjectModelMixin } from \"../mixin/CorePartOfProjectModelMixin.js\";\nimport { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport { isInstanceOf } from '../../../../ChronoGraph/class/Mixin.js';\nexport class CoreDependencyMixin extends Mixin([CorePartOfProjectModelMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreDependencyMixin extends base {\n        static get fields() {\n            return [\n                { name: 'fromEvent', isEqual: (a, b) => a === b, persist: false },\n                { name: 'toEvent', isEqual: (a, b) => a === b, persist: false }\n            ];\n        }\n        // Resolve early + update indices to have buckets ready before commit\n        setChanged(field, value, invalidate) {\n            let update = false;\n            if (field === 'fromEvent' || field === 'toEvent') {\n                const event = isInstanceOf(value, CoreEventMixin) ? value : this.eventStore?.getById(value);\n                if (event)\n                    update = true;\n                value = event || value;\n            }\n            superProto.setChanged.call(this, field, value, invalidate, true);\n            if (update && !this.project.isPerformingCommit && !this.dependencyStore?.isLoadingData) {\n                // TODO: Improve Collection indexing to handle smaller updates\n                this.dependencyStore?.invalidateIndices();\n            }\n        }\n        // Resolve events when joining project\n        joinProject() {\n            superProto.joinProject.call(this);\n            // Initial values should be considered changed, to be normalized\n            // (needs to pass through setChanged for early normalization expected for buckets)\n            this.setChanged('fromEvent', this.get('fromEvent'));\n            this.setChanged('toEvent', this.get('toEvent'));\n        }\n        // Resolved events as part of commit\n        // Normally done earlier in setChanged, but stores might not have been available yet at that point\n        calculateInvalidated() {\n            // Changed values, should be used instead of current where available\n            let { fromEvent, toEvent } = this.$changed;\n            if (fromEvent !== null && !(isInstanceOf(fromEvent, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(fromEvent);\n                if (resolved)\n                    this.$changed.fromEvent = resolved;\n            }\n            if (toEvent !== null && !(isInstanceOf(toEvent, CoreEventMixin))) {\n                const resolved = this.eventStore?.getById(toEvent);\n                if (resolved)\n                    this.$changed.toEvent = resolved;\n            }\n        }\n        //region Events\n        // Not using \"propose\" mechanism from CoreEventMixin, because buckets are expected to be up to date right away\n        set fromEvent(fromEvent) {\n            this.setChanged('fromEvent', fromEvent);\n        }\n        get fromEvent() {\n            const fromEvent = this.get('fromEvent');\n            // Engine returns null instead of id when unresolved\n            return fromEvent?.id != null ? fromEvent : null;\n        }\n        set toEvent(toEvent) {\n            this.setChanged('toEvent', toEvent);\n        }\n        get toEvent() {\n            const toEvent = this.get('toEvent');\n            // Engine returns null instead of id when unresolved\n            return toEvent?.id != null ? toEvent : null;\n        }\n    }\n    return CoreDependencyMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { CoreDependencyMixin } from \"../model/scheduler_core/CoreDependencyMixin.js\";\nimport { AbstractDependencyStoreMixin } from \"./AbstractDependencyStoreMixin.js\";\nconst emptySet = new Set();\n/**\n * A store mixin class, that represent collection of all dependencies in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreDependencyStoreMixin extends Mixin([AbstractDependencyStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreDependencyStoreMixin extends base {\n        constructor() {\n            super(...arguments);\n            this.dependenciesForRemoval = new Set();\n            this.allDependenciesForRemoval = false;\n        }\n        static get defaultConfig() {\n            return {\n                modelClass: CoreDependencyMixin,\n                storage: {\n                    extraKeys: [\n                        { property: 'fromEvent', unique: false },\n                        { property: 'toEvent', unique: false }\n                    ]\n                }\n            };\n        }\n        getIncomingDepsForEvent(event) {\n            return this.storage.findItem('toEvent', event) || emptySet;\n        }\n        getOutgoingDepsForEvent(event) {\n            return this.storage.findItem('fromEvent', event) || emptySet;\n        }\n        set data(value) {\n            this.allDependenciesForRemoval = true;\n            super.data = value;\n            this.allDependenciesForRemoval = false;\n        }\n        updateIndices() {\n            this.storage.rebuildIndices();\n        }\n        invalidateIndices() {\n            this.storage.invalidateIndices();\n        }\n        onCommitAsync() {\n            this.updateIndices();\n        }\n    }\n    return CoreDependencyStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\nimport { AbstractHasAssignmentsMixin } from '../AbstractHasAssignmentsMixin.js';\n/**\n * This is a mixin, which can be applied to the [[CoreEventMixin]]. It provides the collection of all assignments,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class CoreHasAssignmentsMixin extends Mixin([CoreEventMixin, AbstractHasAssignmentsMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreHasAssignmentsMixin extends base {\n        get assigned() {\n            return this.project?.assignmentStore.getEventsAssignments(this) ?? this.$cachedAssignments;\n        }\n        leaveProject(isReplacing = false) {\n            // Expected to still be able to return assignments when removed from project\n            this.$cachedAssignments = this.assigned;\n            super.leaveProject(isReplacing);\n        }\n        applyValue(useProp, key, value, skipAccessor, field) {\n            // Changing id on an event should update resourceId on its assignments\n            if (key === 'id') {\n                this.assigned?.forEach(assignment => assignment.set('eventId', value));\n            }\n            superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);\n        }\n        copy(newId = null, deep = null) {\n            const copy = superProto.copy.call(this, newId, deep);\n            // If deep is everything but object - use default behavior, which is to invoke accessors\n            // If deep is an object, check if it has certain field disabled\n            if ((ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers) || !ObjectHelper.isObject(deep)) {\n                // Copy current assignments, used for occurrences\n                copy.$cachedAssignments = this.assigned;\n            }\n            return copy;\n        }\n    }\n    return CoreHasAssignmentsMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { CoreEventMixin } from \"./CoreEventMixin.js\";\n/**\n * This is a mixin, which can be applied to the [[CoreEventMixin]]. It provides the collection of all dependencies,\n * which reference this event.\n *\n * Doesn't affect scheduling.\n */\nexport class CoreHasDependenciesMixin extends Mixin([CoreEventMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreHasDependenciesMixin extends base {\n        get outgoingDeps() {\n            return this.project.dependencyStore.getOutgoingDepsForEvent(this);\n        }\n        get incomingDeps() {\n            return this.project.dependencyStore.getIncomingDepsForEvent(this);\n        }\n        leaveProject() {\n            const eventStore = this.eventStore;\n            // the buckets may be empty if a model is removed from the project immediately after adding\n            // (without propagation)\n            if (this.outgoingDeps) {\n                this.outgoingDeps.forEach(dependency => eventStore.dependenciesForRemoval.add(dependency));\n            }\n            if (this.incomingDeps) {\n                this.incomingDeps.forEach(dependency => eventStore.dependenciesForRemoval.add(dependency));\n            }\n            superProto.leaveProject.call(this);\n        }\n    }\n    return CoreHasDependenciesMixin;\n}) {\n}\n","import { Mixin } from '../../../../ChronoGraph/class/BetterMixin.js';\nimport { CoreEventMixin } from './CoreEventMixin.js';\nimport { CoreHasAssignmentsMixin } from \"./CoreHasAssignmentsMixin.js\";\nimport { CoreHasDependenciesMixin } from './CoreHasDependenciesMixin.js';\n/**\n * This is an event class, [[SchedulerCoreProjectMixin]] is working with.\n * It is constructed as [[CoreEventMixin]], enhanced with [[CoreHasAssignmentsMixin]] and [[CoreHasDependenciesMixin]]\n */\nexport class SchedulerCoreEvent extends Mixin([\n    CoreEventMixin,\n    CoreHasAssignmentsMixin,\n    CoreHasDependenciesMixin\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerCoreEvent extends base {\n    }\n    return SchedulerCoreEvent;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerCoreEvent } from \"../model/scheduler_core/SchedulerCoreEvent.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { AbstractEventStoreMixin } from \"./AbstractEventStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all events in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreEventStoreMixin extends Mixin([AbstractEventStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreEventStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                modelClass: SchedulerCoreEvent\n            };\n        }\n        joinProject() {\n            this.assignmentStore?.linkAssignments(this, 'event');\n        }\n        afterLoadData() {\n            this.afterEventRemoval();\n            this.assignmentStore?.linkAssignments(this, 'event');\n        }\n    }\n    return CoreEventStoreMixin;\n}) {\n}\n// /**\n//  * The tree store version of [[EventStoreMixin]].\n//  */\n// export class EventTreeStoreMixin extends Mixin(\n//     [ EventStoreMixin ],\n//     (base : AnyConstructor<EventStoreMixin, typeof EventStoreMixin>) => {\n//\n//     const superProto : InstanceType<typeof base> = base.prototype\n//\n//\n//         class EventTreeStoreMixin extends base {\n//             rootNode            : SchedulerBasicProjectMixin\n//\n//             buildRootNode () : object {\n//                 return this.getProject() || {}\n//             }\n//\n//\n//             static get defaultConfig () : object {\n//                 return {\n//                     tree        : true\n//                 }\n//             }\n//         }\n//\n//         return EventTreeStoreMixin\n//     }){}\n//\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport { CorePartOfProjectStoreMixin } from \"./mixin/CorePartOfProjectStoreMixin.js\";\nimport { CoreResourceMixin } from \"../model/scheduler_core/CoreResourceMixin.js\";\nimport { AbstractResourceStoreMixin } from \"./AbstractResourceStoreMixin.js\";\n/**\n * A store mixin class, that represent collection of all resources in the [[SchedulerCoreProjectMixin|project]].\n */\nexport class CoreResourceStoreMixin extends Mixin([AbstractResourceStoreMixin, CorePartOfProjectStoreMixin], (base) => {\n    const superProto = base.prototype;\n    class CoreResourceStoreMixin extends base {\n        static get defaultConfig() {\n            return {\n                modelClass: CoreResourceMixin\n            };\n        }\n        joinProject() {\n            this.assignmentStore?.linkAssignments(this, 'resource');\n        }\n        afterLoadData() {\n            this.assignmentStore?.linkAssignments(this, 'resource');\n        }\n        clear(removing) {\n            superProto.clear.call(this, removing);\n            this.assignmentStore?.unlinkAssignments('resource');\n        }\n    }\n    return CoreResourceStoreMixin;\n}) {\n}\n","import { Mixin } from \"../../../ChronoGraph/class/BetterMixin.js\";\nimport Delayable from \"../../../Core/mixin/Delayable.js\";\nimport Events from \"../../../Core/mixin/Events.js\";\nimport Model from \"../../../Core/data/Model.js\";\nexport class EventsWrapper extends Mixin([], Events) {\n}\nexport class DelayableWrapper extends Mixin([], Delayable) {\n}\n/**\n * This is an abstract project, which just lists the available stores.\n *\n * The actual project classes are [[SchedulerCoreProjectMixin]], [[SchedulerBasicProjectMixin]],\n * [[SchedulerProProjectMixin]], [[GanttProjectMixin]].\n */\nexport class AbstractProjectMixin extends Mixin([\n    EventsWrapper,\n    DelayableWrapper,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class AbstractProjectMixin extends base {\n        constructor() {\n            super(...arguments);\n            // this flag is set, when we are \"restoring\" the data from the rejected transaction and stm is disabled\n            // this involves removing the records added in that transaction (and adding removed records back, which is TODO)\n            // normally, stm is used for that, however, it might be disabled\n            this.isRestoringData = false;\n        }\n        get isRepopulatingStores() {\n            return false;\n        }\n        get isInitialCommit() {\n            return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit;\n        }\n        construct(config = {}) {\n            // Define default values for these flags here\n            // if defined where declared then TS compiles them this way:\n            // constructor() {\n            //     super(...arguments)\n            //     this.isInitialCommitPerformed   = false\n            //     this.isLoadingInlineData        = false\n            //     this.isWritingData              = false\n            //\n            // }\n            // which messes the flags values for inline data loading (since it's async)\n            this.isInitialCommitPerformed = false;\n            this.isLoadingInlineData = false;\n            this.isWritingData = false;\n            this.hasLoadedDataToCommit = false;\n            const silenceInitialCommit = ('silenceInitialCommit' in config) ? config.silenceInitialCommit : true;\n            const adjustDurationToDST = ('adjustDurationToDST' in config) ? config.adjustDurationToDST : false;\n            // 5 years roughly === 5 * 365 * 24 * 60 * 60 * 1000\n            this.maxCalendarRange = ('maxCalendarRange' in config) ? config.maxCalendarRange : 157680000000;\n            // delete configs otherwise super.construct() call treat them as fields and makes accessors for them\n            delete config.maxCalendarRange;\n            delete config.silenceInitialCommit;\n            delete config.adjustDurationToDST;\n            superProto.construct.call(this, config);\n            this.silenceInitialCommit = silenceInitialCommit;\n            this.adjustDurationToDST = adjustDurationToDST;\n        }\n        // Template method called when a stores dataset is replaced. Implemented in SchedulerBasicProjectMixin\n        repopulateStore(store) { }\n        // Template method called when replica should be repopulated. Implemented in SchedulerBasicProjectMixin\n        repopulateReplica() { }\n        deferUntilRepopulationIfNeeded(deferId, func, args) {\n            // no deferring at this level (happens in projects using engine)\n            func(...args);\n        }\n        // Template method called when a store is attached to the project\n        attachStore(store) { }\n        // Template method called when a store is detached to the project\n        detachStore(store) { }\n        async commitAsync() {\n            throw new Error(\"Abstract method called\");\n        }\n        // Different implementations for Core and Basic engines\n        isEngineReady() {\n            throw new Error(\"Abstract method called\");\n        }\n        getStm() {\n            throw new Error(\"Abstract method called\");\n        }\n    }\n    return AbstractProjectMixin;\n}) {\n}\n","import { Mixin } from \"../../../../ChronoGraph/class/BetterMixin.js\";\nimport { SchedulerCoreEvent } from \"./SchedulerCoreEvent.js\";\nimport Store from \"../../../../Core/data/Store.js\";\nimport Model from \"../../../../Core/data/Model.js\";\nimport Delayable from \"../../../../Core/mixin/Delayable.js\";\nimport { CoreEventStoreMixin } from \"../../store/CoreEventStoreMixin.js\";\nimport { CoreAssignmentMixin } from \"./CoreAssignmentMixin.js\";\nimport { CoreAssignmentStoreMixin } from \"../../store/CoreAssignmentStoreMixin.js\";\nimport { CoreResourceMixin } from \"./CoreResourceMixin.js\";\nimport { CoreResourceStoreMixin } from \"../../store/CoreResourceStoreMixin.js\";\nimport { CorePartOfProjectGenericMixin } from \"../../CorePartOfProjectGenericMixin.js\";\nimport { CoreDependencyStoreMixin } from \"../../store/CoreDependencyStoreMixin.js\";\nimport { CoreDependencyMixin } from \"./CoreDependencyMixin.js\";\nimport { CoreCalendarMixin } from './CoreCalendarMixin.js';\nimport { CoreCalendarManagerStoreMixin } from '../../store/CoreCalendarManagerStoreMixin.js';\nimport { delay } from \"../../../util/Functions.js\";\nimport StateTrackingManager from \"../../../../Core/data/stm/StateTrackingManager.js\";\nimport { AbstractProjectMixin } from \"../AbstractProjectMixin.js\";\nimport ObjectHelper from \"../../../../Core/helper/ObjectHelper.js\";\nexport class DelayableWrapper extends Mixin([], Delayable) {\n}\n/**\n * This is a project, implementing _basic scheduling_ as [[SchedulerBasicProjectMixin]] does.\n * Yet this class does not use _chronograph_ based engine.\n */\nexport class SchedulerCoreProjectMixin extends Mixin([\n    AbstractProjectMixin,\n    CorePartOfProjectGenericMixin,\n    DelayableWrapper,\n    Model\n], (base) => {\n    const superProto = base.prototype;\n    class SchedulerCoreProjectMixin extends base {\n        static get configurable() {\n            return {\n                stm: {},\n                eventStore: {},\n                assignmentStore: {},\n                resourceStore: {},\n                dependencyStore: {},\n                calendarManagerStore: {},\n                eventModelClass: SchedulerCoreEvent,\n                assignmentModelClass: CoreAssignmentMixin,\n                resourceModelClass: CoreResourceMixin,\n                dependencyModelClass: CoreDependencyMixin,\n                calendarModelClass: CoreCalendarMixin,\n                eventStoreClass: CoreEventStoreMixin,\n                assignmentStoreClass: CoreAssignmentStoreMixin,\n                resourceStoreClass: CoreResourceStoreMixin,\n                dependencyStoreClass: CoreDependencyStoreMixin,\n                calendarManagerStoreClass: CoreCalendarManagerStoreMixin,\n                assignmentsData: null,\n                calendarsData: null,\n                dependenciesData: null,\n                eventsData: null,\n                resourcesData: null\n            };\n        }\n        //endregion\n        //region Init\n        construct(config = {}) {\n            const me = this;\n            // Cannot be created with declaration, because of how TS is compiled to JS. Ends up after `construct()`\n            me.$invalidated = new Set();\n            // Define default values for these flags here\n            // if defined where declared then TS compiles them this way:\n            // constructor() {\n            //     super(...arguments)\n            //     this.isPerformingCommit   = false\n            //     this.silenceInitialCommit = true\n            //     this.ongoing              = Promise.resolve()\n            // }\n            // which messes the flags values for inline data loading (since it's async)\n            me.isPerformingCommit = false;\n            me.silenceInitialCommit = true;\n            me.ongoing = Promise.resolve();\n            if (config.eventStore && !config.assignmentStore) {\n                const eventStore = config.eventStore.masterStore || config.eventStore;\n                // In this case we must ingest the assignment store from the eventStore. Chaining it to not accidentally\n                // destroy the original store\n                if (eventStore.assignmentStore?.isAssignmentStore) {\n                    config.assignmentStore = eventStore.assignmentStore;\n                    me.isSharingAssignmentStore = true;\n                }\n            }\n            superProto.construct.call(me, config);\n            // not part of the CalendarManagerStore intentionally, not persisted\n            me.defaultCalendar = new me.calendarManagerStore.modelClass({\n                unspecifiedTimeIsWorking: me.unspecifiedTimeIsWorking\n            });\n            me.defaultCalendar.project = me;\n            const { calendarsData, eventsData, dependenciesData, resourcesData, assignmentsData } = me;\n            const hasInlineData = Boolean(calendarsData || eventsData || dependenciesData || resourcesData || assignmentsData);\n            if (hasInlineData) {\n                me.loadInlineData({\n                    calendarsData,\n                    eventsData,\n                    dependenciesData,\n                    resourcesData,\n                    assignmentsData\n                });\n                delete me.calendarsData;\n                delete me.eventsData;\n                delete me.dependenciesData;\n                delete me.resourcesData;\n                delete me.assignmentsData;\n            }\n            else {\n                // Trigger initial commit\n                me.bufferedCommitAsync();\n            }\n        }\n        doDestroy() {\n            const me = this;\n            me.eventStore?.destroy();\n            me.dependencyStore?.destroy();\n            me.assignmentStore?.destroy();\n            me.resourceStore?.destroy();\n            me.calendarManagerStore?.destroy();\n            me.defaultCalendar.destroy();\n            me.stm?.destroy();\n            superProto.doDestroy.call(this);\n        }\n        /**\n         * This method loads the \"raw\" data into the project. The loading is basically happening by\n         * assigning the individual data entries to the `data` property of the corresponding store.\n         *\n         * @param data\n         */\n        async loadInlineData(data) {\n            const me = this;\n            me.isLoadingInlineData = true;\n            if (data.calendarsData) {\n                me.calendarManagerStore.data = data.calendarsData;\n            }\n            if (data.resourcesData) {\n                me.resourceStore.data = data.resourcesData;\n            }\n            if (data.assignmentsData) {\n                me.assignmentStore.data = data.assignmentsData;\n            }\n            if (data.eventsData) {\n                me.eventStore.data = data.eventsData;\n            }\n            if (data.tasksData) {\n                me.eventStore.data = data.tasksData;\n            }\n            if (data.dependenciesData) {\n                me.dependencyStore.data = data.dependenciesData;\n            }\n            await me.commitLoad();\n            me.isLoadingInlineData = false;\n            return;\n        }\n        //endregion\n        //region Join\n        async commitLoad() {\n            await this.commitAsync();\n            // Might have been destroyed during the async operation above\n            if (!this.isDestroyed)\n                this.trigger('load');\n        }\n        joinStoreRecords(store) {\n            const fn = (record) => {\n                record.setProject(this);\n                record.joinProject();\n            };\n            if (store.rootNode) {\n                store.rootNode.traverse(fn);\n            }\n            else {\n                store.forEach(fn);\n            }\n        }\n        unJoinStoreRecords(store) {\n            const fn = (record) => {\n                record.leaveProject();\n                record.setProject(this);\n            };\n            if (store.rootNode) {\n                store.rootNode.traverse(node => {\n                    // do not unjoin/leave project for the root node, which is the project itself\n                    if (node !== store.rootNode)\n                        fn(node);\n                });\n            }\n            else {\n                store.forEach(fn);\n            }\n        }\n        //endregion\n        //region EventStore\n        resolveStoreAndModelClass(name, config) {\n            // storeClass from supplied config or our properties\n            const storeClass = config?.storeClass || this[`${name}StoreClass`];\n            // modelClass from supplied config\n            let modelClass = config?.modelClass;\n            if (!modelClass) {\n                // or from storeClass.modelClass if customized\n                // @ts-ignore\n                if (this.getDefaultConfiguration()[`${name}ModelClass`] !== storeClass.getDefaultConfiguration().modelClass) {\n                    modelClass = storeClass.getDefaultConfiguration().modelClass;\n                }\n                // and if none of the above, use from our properties\n                else {\n                    modelClass = this[`${name}ModelClass`];\n                }\n            }\n            return { storeClass, modelClass };\n        }\n        setEventStore(eventStore) {\n            this.eventStore = eventStore;\n        }\n        changeEventStore(eventStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (!(eventStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('event', eventStore);\n                eventStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, eventStore));\n            }\n            else {\n                eventStore.project = me;\n                stm.addStore(eventStore);\n                me.joinStoreRecords(eventStore);\n            }\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n                const { assignmentsForRemoval } = oldStore;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldEvent = assignment.event;\n                    if (oldEvent) {\n                        const newEvent = eventStore.getById(oldEvent.id);\n                        if (newEvent) {\n                            assignment.event = newEvent;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldStore.afterEventRemoval();\n            }\n            eventStore.setProject(me);\n            return eventStore;\n        }\n        updateEventStore(eventStore, oldStore) {\n            this.attachStore(eventStore);\n            this.trigger('eventStoreChange', { store: eventStore });\n        }\n        //endregion\n        //region AssignmentStore\n        setAssignmentStore(assignmentStore) {\n            this.assignmentStore = assignmentStore;\n        }\n        changeAssignmentStore(assignmentStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n            }\n            if (!(assignmentStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('assignment', assignmentStore);\n                assignmentStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, assignmentStore));\n            }\n            else {\n                assignmentStore.project = me;\n                stm.addStore(assignmentStore);\n                me.joinStoreRecords(assignmentStore);\n            }\n            assignmentStore.setProject(me);\n            return assignmentStore;\n        }\n        updateAssignmentStore(assignmentStore, oldStore) {\n            this.attachStore(assignmentStore);\n            this.trigger('assignmentStoreChange', { store: assignmentStore });\n        }\n        //endregion\n        //region ResourceStore\n        setResourceStore(resourceStore) {\n            this.resourceStore = resourceStore;\n        }\n        changeResourceStore(resourceStore, oldStore) {\n            const me = this, { stm } = me;\n            me.detachStore(oldStore);\n            if (!(resourceStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('resource', resourceStore);\n                resourceStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm\n                }, resourceStore));\n            }\n            else {\n                resourceStore.project = me;\n                stm.addStore(resourceStore);\n                me.joinStoreRecords(resourceStore);\n            }\n            if (oldStore && stm.hasStore(oldStore)) {\n                stm.removeStore(oldStore);\n                me.unJoinStoreRecords(oldStore);\n                const { assignmentsForRemoval } = oldStore;\n                // remap the assignment\n                assignmentsForRemoval.forEach(assignment => {\n                    const oldResource = assignment.resource;\n                    if (oldResource) {\n                        const newResource = resourceStore.getById(oldResource.id);\n                        if (newResource) {\n                            assignment.resource = newResource;\n                            // keep the assignment\n                            assignmentsForRemoval.delete(assignment);\n                        }\n                    }\n                });\n                oldStore.afterResourceRemoval();\n            }\n            resourceStore.setProject(me);\n            return resourceStore;\n        }\n        updateResourceStore(resourceStore, oldStore) {\n            this.attachStore(resourceStore);\n            this.trigger('resourceStoreChange', { store: resourceStore });\n        }\n        //endregion\n        //region DependencyStore\n        setDependencyStore(dependencyStore) {\n            this.dependencyStore = dependencyStore;\n        }\n        changeDependencyStore(dependencyStore, oldStore) {\n            const me = this;\n            me.detachStore(oldStore);\n            if (!(dependencyStore instanceof Store)) {\n                const { storeClass, modelClass } = me.resolveStoreAndModelClass('dependency', dependencyStore);\n                dependencyStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm: me.stm\n                }, dependencyStore));\n            }\n            else {\n                dependencyStore.project = me;\n                me.stm.addStore(dependencyStore);\n                me.joinStoreRecords(dependencyStore);\n            }\n            return dependencyStore;\n        }\n        updateDependencyStore(dependencyStore, oldStore) {\n            this.attachStore(dependencyStore);\n            this.trigger('dependencyStoreChange', { store: dependencyStore });\n        }\n        //endregion\n        //region CalendarManagerStore\n        setCalendarManagerStore(calendarManagerStore) {\n            this.calendarManagerStore = calendarManagerStore;\n        }\n        changeCalendarManagerStore(calendarManagerStore, oldStore) {\n            const me = this;\n            me.detachStore(oldStore);\n            if (!(calendarManagerStore instanceof Store)) {\n                // @ts-ignore\n                const storeClass = calendarManagerStore?.storeClass || me.calendarManagerStoreClass;\n                // @ts-ignore\n                const modelClass = calendarManagerStore?.modelClass || storeClass.getDefaultConfiguration().modelClass || me.calendarModelClass;\n                calendarManagerStore = new storeClass(ObjectHelper.assign({\n                    modelClass,\n                    project: me,\n                    stm: me.stm\n                }, calendarManagerStore));\n            }\n            else {\n                me.stm.addStore(calendarManagerStore);\n            }\n            calendarManagerStore.setProject(me);\n            return calendarManagerStore;\n        }\n        updateCalendarManagerStore(calendarManagerStore, oldStore) {\n            this.attachStore(calendarManagerStore);\n            this.trigger('calendarManagerStoreChange', { store: calendarManagerStore });\n        }\n        //endregion\n        //region Calendar\n        get calendar() {\n            return this.$calendar || this.defaultCalendar;\n        }\n        set calendar(calendar) {\n            this.$calendar = calendar;\n        }\n        get effectiveCalendar() {\n            return this.calendar;\n        }\n        //endregion\n        //region Add records\n        async addEvent(event) {\n            this.eventStore.add(event);\n            return this.commitAsync();\n        }\n        async addAssignment(assignment) {\n            this.assignmentStore.add(assignment);\n            return this.commitAsync();\n        }\n        async addResource(resource) {\n            this.resourceStore.add(resource);\n            return this.commitAsync();\n        }\n        async addDependency(dependency) {\n            this.dependencyStore.add(dependency);\n            return this.commitAsync();\n        }\n        //endregion\n        //region Auto commit\n        // Buffer commitAsync using setTimeout. Not using `buffer` on purpose, for performance reasons and to better\n        // mimic how graph does it\n        bufferedCommitAsync() {\n            if (!this.hasPendingAutoCommit) {\n                this.setTimeout({\n                    fn: 'commitAsync',\n                    delay: 10\n                });\n            }\n        }\n        get hasPendingAutoCommit() {\n            return this.hasTimeout('commitAsync');\n        }\n        unScheduleAutoCommit() {\n            this.clearTimeout('commitAsync');\n        }\n        //endregion\n        //region Commit\n        async commitAsync() {\n            if (this.isPerformingCommit)\n                return this.ongoing;\n            return this.ongoing = this.doCommitAsync();\n        }\n        async doCommitAsync() {\n            const me = this;\n            me.isPerformingCommit = true;\n            // Cancel any outstanding commit\n            me.unScheduleAutoCommit();\n            await delay(0);\n            if (!me.isDestroyed) {\n                // Calculate all invalidated records, updates their data silently\n                for (const record of me.$invalidated) {\n                    record.calculateInvalidated();\n                }\n                const { isInitialCommit, silenceInitialCommit } = me;\n                // apply changes silently if this is initial commit and \"silenceInitialCommit\" option is enabled\n                const silenceCommit = isInitialCommit && silenceInitialCommit;\n                // Notify stores that care about commit (internal)\n                me.assignmentStore.onCommitAsync();\n                me.dependencyStore.onCommitAsync();\n                me.isInitialCommitPerformed = true;\n                me.hasLoadedDataToCommit = false;\n                me.isPerformingCommit = false;\n                const stores = [me.assignmentStore, me.dependencyStore, me.eventStore, me.resourceStore, me.calendarManagerStore];\n                stores.forEach(store => store.suspendAutoCommit?.());\n                me.isWritingData = true;\n                // \"Real\" project triggers refresh before data is written back to records\n                me.trigger('refresh', { isInitialCommit, isCalculated: true });\n                // If we are not announcing changes, take a cheaper path\n                if (silenceCommit) {\n                    for (const record of me.$invalidated) {\n                        record.finalizeInvalidated(true);\n                    }\n                }\n                else {\n                    // Two loops looks a bit weird, but needed since editing assignment might affect event etc.\n                    // And we do only want a single update in the end\n                    // 1. Start batches and perform all calculations\n                    for (const record of me.$invalidated) {\n                        record.beginBatch(true);\n                        record.finalizeInvalidated();\n                    }\n                    // 2. End batches, announcing changes (unless initial commit)\n                    for (const record of me.$invalidated) {\n                        record.endBatch(false, true);\n                    }\n                }\n                me.isWritingData = false;\n                me.$invalidated.clear();\n                // Mimic real projects events\n                me.trigger('dataReady');\n                stores.forEach(store => store.resumeAutoCommit?.());\n                // Chrono version triggers \"dataReady\" only if there were no commit rejection\n                // (in case of a rejection it triggers \"commitRejected\" event)\n                // but in both cases it triggers \"commitFinalized\" afterwards\n                me.trigger('commitFinalized');\n                return true;\n            }\n        }\n        async propagateAsync() {\n            return this.commitAsync();\n        }\n        // Called when a record invalidates itself, queues it for calculation\n        invalidate(record) {\n            this.$invalidated.add(record);\n            this.bufferedCommitAsync();\n        }\n        // this does not account for possible scheduling conflicts\n        async isValidDependency() {\n            return true;\n        }\n        //endregion\n        //region STM\n        getStm() {\n            return this.stm;\n        }\n        /**\n         * State tracking manager instance the project relies on\n         */\n        set stm(stm) {\n            stm = this.$stm = new StateTrackingManager(ObjectHelper.assign({\n                disabled: true\n            }, stm));\n            stm.ion({\n                // Propagate on undo/redo\n                restoringStop: async () => {\n                    // Disable STM meanwhile to not pick it up as a new STM transaction\n                    stm.disable();\n                    await this.commitAsync();\n                    if (!this.isDestroyed) {\n                        stm.enable();\n                        this.trigger('stateRestoringDone');\n                    }\n                }\n            });\n        }\n        get stm() {\n            return this.$stm;\n        }\n        //endregion\n        isEngineReady() {\n            return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed;\n        }\n    }\n    //region Config\n    SchedulerCoreProjectMixin.applyConfigs = true;\n    return SchedulerCoreProjectMixin;\n}) {\n}\n","/**\n * @module Scheduler/crud/mixin/AbstractCrudManagerValidation\n */\n\n/**\n * Mixin proving responses validation API to Crud Manager.\n * @mixin\n */\nexport default Target => class AbstractCrudManagerValidation extends Target {\n\n    static get $name() {\n        return 'AbstractCrudManagerValidation';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * This config validates the response structure for requests made by the Crud Manager.\n             * When `true`, the Crud Manager checks every parsed response structure for errors\n             * and if the response format is invalid, a warning is logged to the browser console.\n             *\n             * The config is intended to help developers implementing backend integration.\n             *\n             * @config {Boolean}\n             * @default\n             * @category CRUD\n             */\n            validateResponse : true,\n\n            /**\n             * When `true` treats parsed responses without `success` property as successful.\n             * In this mode a parsed response is treated as invalid if it has explicitly set `success : false`.\n             * @config {Boolean}\n             * @default\n             * @category CRUD\n             */\n            skipSuccessProperty : true,\n\n            crudLoadValidationWarningPrefix : 'CrudManager load response error(s):',\n\n            crudSyncValidationWarningPrefix : 'CrudManager sync response error(s):',\n\n            supportShortSyncResponseNote : 'Note: Please consider enabling \"supportShortSyncResponse\" option to allow less detailed sync responses (https://bryntum.com/products/scheduler/docs/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',\n\n            disableValidationNote : 'Note: To disable this validation please set the \"validateResponse\" config to false'\n        };\n    }\n\n    get crudLoadValidationMandatoryStores() {\n        return [];\n    }\n\n    getStoreLoadResponseWarnings(storeInfo, responded, expectedResponse) {\n        const\n            messages        = [],\n            { storeId }     = storeInfo,\n            mandatoryStores = this.crudLoadValidationMandatoryStores,\n            result          = { [storeId] : {} };\n\n        // if the store section is responded\n        if (responded) {\n            if (!responded.rows) {\n                messages.push(`- \"${storeId}\" store section should have a \"rows\" property with an array of the store records.`);\n\n                result[storeId].rows = ['...'];\n            }\n        }\n        // if the store is mandatory\n        else if (mandatoryStores?.includes(storeId)) {\n            messages.push(`- No \"${storeId}\" store section found. It should contain the store data.`);\n\n            result[storeId].rows = ['...'];\n        }\n\n        // extend expected response w/ this store part\n        if (messages.length) {\n            Object.assign(expectedResponse, result);\n        }\n\n        return messages;\n    }\n\n    getLoadResponseWarnings(response) {\n        const\n            messages         = [],\n            expectedResponse = {};\n\n        if (!this.skipSuccessProperty) {\n            expectedResponse.success = true;\n        }\n\n        // iterate stores to check properties validity\n        this.forEachCrudStore((store, storeId, storeInfo) => {\n            messages.push(...this.getStoreLoadResponseWarnings(storeInfo, response?.[storeId], expectedResponse));\n        });\n\n        if (messages.length) {\n            messages.push('Please adjust your response to look like this:\\n' +\n                JSON.stringify(expectedResponse, null, 4).replace(/\"\\.\\.\\.\"/g, '...'));\n\n            messages.push(this.disableValidationNote);\n        }\n\n        return messages;\n    }\n\n    validateLoadResponse(response) {\n        const messages = this.getLoadResponseWarnings(response);\n\n        if (messages.length) {\n            console.warn(this.crudLoadValidationWarningPrefix + '\\n' + messages.join('\\n'));\n        }\n    }\n\n    getStoreSyncResponseWarnings(storeInfo, requested, responded, expectedResponse) {\n        const\n            messages         = [],\n            missingRows      = [],\n            missingRemoved   = [],\n            { storeId }      = storeInfo,\n            result           = { [storeId] : {} },\n            phantomIdField   = storeInfo.phantomIdField || this.phantomIdField,\n            { modelClass }   = storeInfo.store,\n            { idField }      = modelClass,\n            respondedRows    = responded?.rows || [],\n            respondedRemoved = responded?.removed || [];\n\n        let showSupportShortSyncResponseNote = false;\n\n        // if added records were passed in the request they should be mentioned in the response\n        if (requested?.added) {\n            missingRows.push(\n                ...requested.added.filter(record => {\n                    return !respondedRows.find(row => row[phantomIdField] == record[phantomIdField]) &&\n                        !respondedRemoved.find(row => row[phantomIdField] == record[phantomIdField] || row[idField] == record[phantomIdField]);\n                }).map(record => ({ [phantomIdField] : record[phantomIdField], [idField] : '...' }))\n            );\n\n            if (missingRows.length) {\n                const missingIds = missingRows.map(row => '#' + row[phantomIdField]).join(', ');\n\n                messages.push(`- \"${storeId}\" store \"rows\" section should mention added record(s) ${missingIds} sent in the request. ` +\n                    'It should contain the added records identifiers (both phantom and \"real\" ones assigned by the backend).');\n            }\n        }\n\n        // if short responses are enabled\n        if (this.supportShortSyncResponse) {\n            // if the data is not object, will return error\n            if (!missingRows.length && responded) {\n                if (typeof responded !== 'object' || Array.isArray(responded)) {\n                    messages.push(`- \"${storeId}\" store section should be an Object.`);\n                    result[storeId]['...'] = '...';\n                }\n\n                // for request to edit records, if rows is present, it must be an array\n                if (responded.rows && !Array.isArray(responded.rows)) {\n                    messages.push(`- \"${storeId}\" store \"rows\" section should be an array`);\n                    missingRows.push('...');\n                }\n\n                // removed if presented must be an array\n                if (responded.removed && !Array.isArray(responded.removed)) {\n                    messages.push(`- \"${storeId}\" store \"removed\" section should be an array:`);\n                    missingRemoved.push('...');\n                }\n            }\n        }\n        // if short responses are disabled\n        else {\n            // if updated records were passed in the request they should be mentioned in the response\n            if (requested?.updated) {\n                const missingUpdatedRows = requested.updated.filter(record => !respondedRows.find(row => row[idField] == record[idField]))\n                    .map(record => ({ [idField] : record[idField] }));\n\n                missingRows.push(...missingUpdatedRows);\n\n                if (missingUpdatedRows.length) {\n                    const missingIds = missingUpdatedRows.map(row => '#' + row[idField]).join(', ');\n\n                    messages.push(`- \"${storeId}\" store \"rows\" section should mention updated record(s) ${missingIds} sent in the request. ` +\n                        `It should contain the updated record identifiers.`);\n\n                    showSupportShortSyncResponseNote = true;\n                }\n\n            }\n\n            if (missingRows.length) {\n                missingRows.push('...');\n            }\n\n            // if removed records were passed in the request they should be mentioned in the response\n            if (requested?.removed) {\n                missingRemoved.push(\n                    ...requested.removed.filter(record => !respondedRows.find(row => row[idField] == record[idField]))\n                        .map(record => ({ [idField] : record[idField] }))\n                );\n\n                if (missingRemoved.length) {\n                    const missingIds = missingRemoved.map(row => '#' + row[idField]).join(', ');\n\n                    messages.push(`- \"${storeId}\" store \"removed\" section should mention removed record(s) ${missingIds} sent in the request. ` +\n                        `It should contain the removed record identifiers.`);\n\n                    result[storeId].removed = missingRemoved;\n                    missingRemoved.push('...');\n\n                    showSupportShortSyncResponseNote = true;\n                }\n            }\n\n        }\n\n        if (missingRows.length) {\n            result[storeId].rows = missingRows;\n        }\n\n        // get rid of store section if no rows/removed there\n        if (!messages.length) {\n            delete result[storeId];\n        }\n\n        // extend expected response w/ this store part\n        Object.assign(expectedResponse, result);\n\n        return { messages, showSupportShortSyncResponseNote };\n    }\n\n    getSyncResponseWarnings(response, requestDesc) {\n        const\n            messages         = [],\n            expectedResponse = {},\n            request          = requestDesc.pack;\n\n        if (!this.skipSuccessProperty) {\n            expectedResponse.success = true;\n        }\n\n        let showSupportShortSyncResponseNote = false;\n\n        // iterate stores to check properties validity\n        this.forEachCrudStore((store, storeId, storeInfo) => {\n            const warnings = this.getStoreSyncResponseWarnings(storeInfo, request?.[storeId], response[storeId], expectedResponse);\n\n            showSupportShortSyncResponseNote = showSupportShortSyncResponseNote || warnings.showSupportShortSyncResponseNote;\n\n            messages.push(...warnings.messages);\n        });\n\n        if (messages.length) {\n            messages.push('Please adjust your response to look like this:\\n' +\n                JSON.stringify(expectedResponse, null, 4).replace(/\"\\.\\.\\.\":\\s*\"\\.\\.\\.\"/g, ',,,').replace(/\"\\.\\.\\.\"/g, '...'));\n\n            if (showSupportShortSyncResponseNote) {\n                messages.push(this.supportShortSyncResponseNote);\n            }\n\n            messages.push(this.disableValidationNote);\n        }\n\n        return messages;\n    }\n\n    validateSyncResponse(response, request) {\n        const messages = this.getSyncResponseWarnings(response, request);\n\n        if (messages.length) {\n            console.warn(this.crudSyncValidationWarningPrefix + '\\n' + messages.join('\\n'));\n        }\n    }\n};\n","import Store from '../../Core/data/Store.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport Base from '../../Core/Base.js';\nimport Events from '../../Core/mixin/Events.js';\nimport AbstractCrudManagerValidation from './mixin/AbstractCrudManagerValidation.js';\n\n/**\n * @module Scheduler/crud/AbstractCrudManagerMixin\n */\n\nexport class AbstractCrudManagerError extends Error {}\n\nexport class CrudManagerRequestError extends AbstractCrudManagerError {\n    constructor(cfg = {}) {\n        super(cfg.message || cfg.request && StringHelper.capitalize(cfg.request?.type) + ' failed' || 'Crud Manager request failed');\n        Object.assign(this, cfg);\n        this.action = this.request?.type;\n    }\n}\n\nconst\n    storeSortFn     = function(lhs, rhs, sortProperty) {\n        // TODO: get rid of these StoreDescriptors. Just use Stores.\n        if (lhs.store) {\n            lhs = lhs.store;\n        }\n        if (rhs.store) {\n            rhs = rhs.store;\n        }\n\n        lhs = lhs[sortProperty] || 0;\n        rhs = rhs[sortProperty] || 0;\n        return (lhs < rhs) ? -1 : ((lhs > rhs) ? 1 : 0);\n    },\n\n    // Sorter function to keep stores in loadPriority order\n    storeLoadSortFn = function(lhs, rhs) {\n        return storeSortFn(lhs, rhs, 'loadPriority');\n    },\n\n    // Sorter function to keep stores in syncPriority order\n    storeSyncSortFn = function(lhs, rhs) {\n        return storeSortFn(lhs, rhs, 'syncPriority');\n    };\n\n/**\n * An abstract mixin that supplies most of the CrudManager functionality.\n * It implements basic mechanisms of collecting stores to organize batch communication with a server.\n * It does not contain methods related to _data transfer_ nor _encoding_.\n * These methods are to be provided in sub-classes.\n * Out of the box there are mixins implementing {@link Scheduler/crud/transport/AjaxTransport support of AJAX for data transferring}\n * and {@link Scheduler/crud/encoder/JsonEncoder JSON for data encoding system}.\n * For example this is how we make a model that will implement CrudManager protocol and use AJAX/JSON to pass the data\n * to the server:\n *\n * ```javascript\n * class SystemSettings extends JsonEncode(AjaxTransport(AbstractCrudManagerMixin(Model))) {\n *     ...\n * }\n * ```\n *\n * ## Data transfer and encoding methods\n *\n * These are methods that must be provided by subclasses of this class:\n *\n * - {@link #function-sendRequest}\n * - {@link #function-cancelRequest}\n * - {@link #function-encode}\n * - {@link #function-decode}\n *\n * @mixin\n * @mixes Core/mixin/Delayable\n * @mixes Core/mixin/Events\n * @mixes Scheduler/crud/mixin/AbstractCrudManagerValidation\n * @abstract\n */\nexport default Target => {\n\n    // Trigger $meta calculation to get up-to-date is \"isXXX\" flags\n    // (kinky construction to avoid production minification faced in Angular https://github.com/bryntum/support/issues/2889)\n    Target.$$meta = Target.$meta;\n\n    const mixins = [];\n\n    // These two mixins are mixed in the Scheduling Engine code ..but in its own way\n    // so that Base.mixin() cannot understand that they are already there and applies them 2nd time\n    if (!Target.isEvents) {\n        mixins.push(Events);\n    }\n    if (!Target.isDelayable) {\n        mixins.push(Delayable);\n    }\n\n    mixins.push(AbstractCrudManagerValidation);\n\n    return class AbstractCrudManagerMixin extends (Target || Base).mixin(...mixins) {\n\n        /**\n         * Fires before server response gets applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeResponseApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n         * @param {Object} response The decoded server response object.\n         */\n\n        /**\n         * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeLoadApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {Object} response The decoded server response object.\n         * @param {Object} options Options provided to the {@link #function-load} method.\n         */\n        /**\n         * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.\n         * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.\n         * @event beforeSyncApply\n         * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n         * @param {Object} response The decoded server response object.\n         */\n\n        static get $name() {\n            return 'AbstractCrudManagerMixin';\n        }\n\n        //region Default config\n\n        static get defaultConfig() {\n            return {\n                /**\n                 * The server revision stamp.\n                 * The _revision stamp_ is a number which should be incremented after each server-side change.\n                 * This property reflects the current version of the data retrieved from the server and gets updated\n                 * after each {@link #function-load} and {@link #function-sync} call.\n                 * @property {Number}\n                 * @readonly\n                 * @category CRUD\n                 */\n                crudRevision : null,\n\n                /**\n                 * A list of registered stores whose server communication will be collected into a single batch.\n                 * Each store is represented by a _store descriptor_.\n                 * @member {CrudManagerStoreDescriptor[]} crudStores\n                 * @category CRUD\n                 */\n\n                /**\n                 * Sets the list of stores controlled by the CRUD manager.\n                 *\n                 * When adding a store to the CrudManager, make sure the server response format is correct for `load`\n                 * and `sync` requests. Learn more in the\n                 * [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n                 *\n                 * Store can be provided by itself, its storeId or as a _store descriptor_.\n                 * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}\n                 * @category CRUD\n                 */\n                crudStores : [],\n\n                /**\n                 * Name of a store property to retrieve store identifiers from. Make sure you have an instance of a\n                 * store to use it by id. Store identifier is used as a container name holding corresponding store data\n                 * while transferring them to/from the server. By default, `storeId` property is used. And in case a\n                 * container identifier has to differ this config can be used:\n                 *\n                 * ```javascript\n                 * class CatStore extends Store {\n                 *     static configurable = {\n                 *         // store id is \"meow\" but for sending/receiving store data\n                 *         // we want to have \"cats\" container in JSON, so we create a new property \"storeIdForCrud\"\n                 *         id             : 'meow',\n                 *         storeIdForCrud : 'cats'\n                 *     }\n                 * });\n                 *\n                 * // create an instance to use a store by id\n                 * new CatStore();\n                 *\n                 * class MyCrudManager extends CrudManager {\n                 *     ...\n                 *     crudStores           : ['meow'],\n                 *     // crud manager will get store identifier from \"storeIdForCrud\" property\n                 *     storeIdProperty  : 'storeIdForCrud'\n                 * });\n                 * ```\n                 * The `storeIdProperty` property can also be specified directly on a store:\n                 *\n                 * ```javascript\n                 * class CatStore extends Store {\n                 *     static configurable = {\n                 *         // storeId is \"meow\" but for sending/receiving store data\n                 *         // we want to have \"cats\" container in JSON\n                 *         id              : 'meow',\n                 *         // so we create a new property \"storeIdForCrud\"..\n                 *         storeIdForCrud  : 'cats',\n                 *         // and point CrudManager to use it as the store identifier source\n                 *         storeIdProperty  : 'storeIdForCrud'\n                 *     }\n                 * });\n                 *\n                 * class DogStore extends Store {\n                 *     static configurable = {\n                 *         // storeId is \"dogs\" and it will be used as a container name for the store data\n                 *         storeId : 'dogs',\n                 *         // id is set to get a store by identifier\n                 *         id      : 'dogs'\n                 *     }\n                 * });\n                 *\n                 * // create an instance to use a store by id\n                 * new CatStore();\n                 * new DogStore();\n                 *\n                 * class MyCrudManager extends CrudManager {\n                 *     ...\n                 *     crudStores : ['meow', 'dogs']\n                 * });\n                 * ```\n                 * @config {String}\n                 * @category CRUD\n                 */\n                storeIdProperty : 'storeId',\n\n                // TODO: no support for remote filtering yet\n                // /**\n                //  * The name of the 'filter' parameter to send in a load request.\n                //  * @config {String}\n                //  * @default\n                //  */\n                crudFilterParam : 'filter',\n\n                /**\n                 * Sends request to the server.\n                 * @function sendRequest\n                 * @param {Object} request The request to send. An object having following properties:\n                 * @param {'load'|'sync'} request.type Request type, can be either `load` or `sync`\n                 * @param {String} request.data {@link #function-encode Encoded} request.\n                 * @param {Function} request.success Callback to be started on successful request transferring\n                 * @param {Function} request.failure Callback to be started on request transfer failure\n                 * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks\n                 * @returns {Promise} The request promise.\n                 * @abstract\n                 */\n\n                /**\n                 * Cancels request to the server.\n                 * @function cancelRequest\n                 * @param {Promise} promise The request promise to cancel (a value returned by corresponding\n                 * {@link #function-sendRequest} call).\n                 * @param {Function} reject Reject handle of the corresponding promise\n                 * @abstract\n                 */\n\n                /**\n                 * Encodes request to the server.\n                 * @function encode\n                 * @param {Object} request The request to encode.\n                 * @returns {String} The encoded request.\n                 * @abstract\n                 */\n\n                /**\n                 * Decodes response from the server.\n                 * @function decode\n                 * @param {String} response The response to decode.\n                 * @returns {Object} The decoded response.\n                 * @abstract\n                 */\n\n                transport : {},\n\n                /**\n                 * When `true` forces the CRUD manager to process responses depending on their `type` attribute.\n                 * So `load` request may be responded with `sync` response for example.\n                 * Can be used for smart server logic allowing the server to decide when it's better to respond with a\n                 * complete data set (`load` response) or it's enough to return just a delta (`sync` response).\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                trackResponseType : false,\n\n                /**\n                 * When `true` the Crud Manager does not require all updated and removed records to be mentioned in the\n                 * *sync* response. In this case response should include only server side changes.\n                 *\n                 * **Please note that added records should still be mentioned in response to provide real identifier\n                 * instead of the phantom one.**\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                supportShortSyncResponse : true,\n\n                /**\n                 * Field name to be used to transfer a phantom record identifier.\n                 * @config {String}\n                 * @default\n                 * @category CRUD\n                 */\n                phantomIdField : '$PhantomId',\n\n                /**\n                 * Field name to be used to transfer a phantom parent record identifier.\n                 * @config {String}\n                 * @default\n                 * @category CRUD\n                 */\n                phantomParentIdField : '$PhantomParentId',\n\n                /**\n                 * `true` to automatically call {@link #function-load} method after creation.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                autoLoad : false,\n\n                /**\n                 * The timeout in milliseconds to wait before persisting changes to the server.\n                 * Used when {@link #config-autoSync} is set to `true`.\n                 * @config {Number}\n                 * @default\n                 * @category CRUD\n                 */\n                autoSyncTimeout : 100,\n\n                /**\n                 * `true` to automatically persist store changes after edits are made in any of the stores monitored.\n                 * Please note that sync request will not be invoked immediately but only after\n                 * {@link #config-autoSyncTimeout} interval.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                autoSync : false,\n\n                /**\n                 * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them\n                 * to the server.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                resetIdsBeforeSync : true,\n\n                /**\n                 * @member {CrudManagerStoreDescriptor[]} syncApplySequence\n                 * An array of stores presenting an alternative sync responses apply order.\n                 * Each store is represented by a _store descriptor_.\n                 * @category CRUD\n                 */\n\n                /**\n                 * An array of store identifiers sets an alternative sync responses apply order.\n                 * By default, the order in which sync responses are applied to the stores is the same as they\n                 * registered in. But in case of some tricky dependencies between stores this order can be changed:\n                 *\n                 *```javascript\n                 * class MyCrudManager extends CrudManager {\n                 *     // register stores (will be loaded in this order: 'store1' then 'store2' and finally 'store3')\n                 *     crudStores : ['store1', 'store2', 'store3'],\n                 *     // but we apply changes from server to them in an opposite order\n                 *     syncApplySequence : ['store3', 'store2', 'store1']\n                 * });\n                 *```\n                 * @config {String[]}\n                 * @category CRUD\n                 */\n                syncApplySequence : [],\n\n                orderedCrudStores : [],\n\n                /**\n                 * `true` to write all fields from the record to the server.\n                 * If set to `false` it will only send the fields that were modified.\n                 * Note that any fields that have {@link Core/data/field/DataField#config-persist} set to `false` will\n                 * still be ignored and fields having {@link Core/data/field/DataField#config-alwaysWrite} set to `true`\n                 * will always be included.\n                 * @config {Boolean}\n                 * @default\n                 * @category CRUD\n                 */\n                writeAllFields : false,\n\n                crudIgnoreUpdates : 0,\n\n                autoSyncSuspendCounter : 0,\n\n                // Flag that shows if crud manager performed successful load request\n                crudLoaded : false,\n\n                applyingLoadResponse : false,\n                applyingSyncResponse : false,\n\n                callOnFunctions : true\n            };\n        }\n\n        static configurable = {\n            /**\n             * Convenience shortcut to set only the url to load from, when you do not need to supply any other config\n             * options in the `load` section of the `transport` config.\n             *\n             * Using `loadUrl`:\n             * ```javascript\n             * {\n             *     loadUrl : 'read.php\n             * }\n             * ```\n             *\n             * Equals the following `transport` config:\n             * ```javascript\n             * {\n             *     transport : {\n             *         load : {\n             *             url : 'read.php'\n             *         }\n             *     }\n             * }\n             * ```\n             *\n             * When read at runtime, it will return the value from `transport.load.url`.\n             *\n             * @prp {String}\n             */\n            loadUrl : null,\n\n            /**\n             * Convenience shortcut to set only the url to sync to, when you do not need to supply any other config\n             * options in the `sync` section of the `transport` config.\n             *\n             * Using `loadUrl`:\n             * ```javascript\n             * {\n             *     syncUrl : 'sync.php\n             * }\n             * ```\n             *\n             * Equals the following `transport` config:\n             * ```javascript\n             * {\n             *     transport : {\n             *         load : {\n             *             url : 'sync.php'\n             *         }\n             *     }\n             * }\n             * ```\n             *\n             * When read at runtime, it will return the value from `transport.sync.url`.\n             *\n             * @prp {String}\n             */\n            syncUrl : null,\n\n            /**\n             * Specify as `true` to force sync requests to be sent when calling `sync()`, even if there are no local\n             * changes. Useful in a polling scenario, to keep client up to date with the backend.\n             * @prp {Boolean}\n             */\n            forceSync : null\n        }\n\n        get isCrudManager() {\n            return true;\n        }\n\n        //endregion\n\n        //region Init\n\n        construct(config = {}) {\n            this._requestId = 0;\n            this.activeRequests = {};\n            this.crudStoresIndex = {};\n\n            super.construct(config);\n        }\n\n        afterConstruct() {\n            super.afterConstruct();\n\n            if (this.autoLoad) {\n                this._autoLoadPromise = this.doAutoLoad();\n            }\n        }\n\n        //endregion\n\n        //region Configs\n\n        get loadUrl() {\n            return this.transport?.load?.url;\n        }\n\n        updateLoadUrl(url) {\n            ObjectHelper.setPath(this, 'transport.load.url', url);\n        }\n\n        get syncUrl() {\n            return this.transport?.sync?.url;\n        }\n\n        updateSyncUrl(url) {\n            ObjectHelper.setPath(this, 'transport.sync.url', url);\n        }\n\n        //endregion\n\n        //region Store descriptors & index\n\n        /**\n         * Returns a registered store descriptor.\n         * @param {String|Core.data.Store} storeId The store identifier or registered store instance.\n         * @returns {CrudManagerStoreDescriptor} The descriptor of the store.\n         * @category CRUD\n         */\n        getStoreDescriptor(storeId) {\n            if (!storeId) return null;\n\n            if (storeId instanceof Store) return this.crudStores.find(storeDesc => storeDesc.store === storeId);\n\n            if (typeof storeId === 'object') return this.crudStoresIndex[storeId.storeId];\n\n            return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));\n        }\n\n        fillStoreDescriptor(descriptor) {\n            const\n                { store } = descriptor,\n                {\n                    storeIdProperty = this.storeIdProperty,\n                    modelClass\n                }         = store;\n\n            if (!descriptor.storeId) {\n                descriptor.storeId = store[storeIdProperty] || store.id;\n            }\n            if (!descriptor.idField) {\n                descriptor.idField = modelClass.idField;\n            }\n            if (!descriptor.phantomIdField) {\n                descriptor.phantomIdField = modelClass.phantomIdField;\n            }\n            if (!descriptor.phantomParentIdField) {\n                descriptor.phantomParentIdField = modelClass.phantomParentIdField;\n            }\n            if (!('writeAllFields' in descriptor)) {\n                descriptor.writeAllFields = store.writeAllFields;\n            }\n\n            return descriptor;\n        }\n\n        updateCrudStoreIndex() {\n            const\n                crudStoresIndex = this.crudStoresIndex = {};\n\n            this.crudStores.forEach(store => store.storeId && (crudStoresIndex[store.storeId] = store));\n        }\n\n        //endregion\n\n        //region Store collection (add, remove, get & iterate)\n\n        /**\n         * Returns a registered store.\n         * @param {String} storeId Store identifier.\n         * @returns {Core.data.Store} Found store instance.\n         * @category CRUD\n         */\n        getCrudStore(storeId) {\n            const storeDescriptor = this.getStoreDescriptor(storeId);\n            return storeDescriptor?.store;\n        }\n\n        forEachCrudStore(fn, thisObj = this) {\n            if (!fn) {\n                throw new Error('Iterator function must be provided');\n            }\n\n            this.crudStores.every(store =>\n                fn.call(thisObj, store.store, store.storeId, store) !== false\n            );\n        }\n\n        set crudStores(stores) {\n            this._crudStores = [];\n\n            this.addCrudStore(stores);\n\n            // Ensure preconfigured stores stay stable at the start of the array when\n            // addPrioritizedStore attempts to insert in order. Only featured gantt/scheduler stores\n            // must participate in the ordering. If they were configured in, they must not move.\n            for (const store of this._crudStores) {\n                store.loadPriority = store.syncPriority = 0;\n            }\n        }\n\n        get crudStores() {\n            return this._crudStores;\n        }\n\n        get orderedCrudStores() {\n            return this._orderedCrudStores;\n        }\n\n        set orderedCrudStores(stores) {\n            return this._orderedCrudStores = stores;\n        }\n\n        set syncApplySequence(stores) {\n            this._syncApplySequence = [];\n\n            this.addStoreToApplySequence(stores);\n        }\n\n        get syncApplySequence() {\n            return this._syncApplySequence;\n        }\n\n        internalAddCrudStore(store) {\n            const\n                me = this;\n\n            let storeInfo;\n\n            // if store instance provided\n            if (store instanceof Store) {\n                storeInfo = { store };\n            }\n            else if (typeof store === 'object') {\n                if (!store.store) {\n                    // not a store descriptor, assume it is a store config\n                    store = {\n                        storeId : store.id,\n                        store   : new Store(store)\n                    };\n                }\n\n                storeInfo = store;\n            }\n            // if it's a store identifier\n            else {\n                storeInfo = { store : Store.getStore(store) };\n            }\n\n            me.fillStoreDescriptor(storeInfo);\n\n            // store instance\n            store = storeInfo.store;\n\n            // if the store has \"setCrudManager\" hook - use it\n            if (store.setCrudManager) {\n                store.setCrudManager(me);\n            }\n            // otherwise decorate the store w/ \"crudManager\" property\n            else {\n                store.crudManager = me;\n            }\n\n            // Stores have a defaultConfig for pageSize. CrudManager does not support that.\n            // TODO: PORT currently no support for paging.\n            store.pageSize = null;\n\n            // Prevent AjaxStores from performing their own CRUD operations if CrudManager is configured with an URL\n            if (me.loadUrl || me.syncUrl) {\n                store.autoCommit = false;\n                store.autoLoad = false;\n                if (store.createUrl || store.updateUrl || store.deleteUrl || store.readUrl) {\n                    console.warn('You have configured an URL on a Store that is handled by a CrudManager that is also configured with an URL. The Store URL\\'s should be removed.');\n                }\n            }\n\n            // listen to store changes\n            me.bindCrudStoreListeners(store);\n\n            return storeInfo;\n        }\n\n        /**\n         * Adds a store to the collection.\n         *\n         *```javascript\n         * // append stores to the end of collection\n         * crudManager.addCrudStore([\n         *     store1,\n         *     // storeId\n         *     'bar',\n         *     // store descriptor\n         *     {\n         *         storeId : 'foo',\n         *         store   : store3\n         *     },\n         *     {\n         *         storeId         : 'bar',\n         *         store           : store4,\n         *         // to write all fields of modified records\n         *         writeAllFields  : true\n         *     }\n         * ]);\n         *```\n         *\n         * **Note:** Order in which stores are kept in the collection is very essential sometimes.\n         * Exactly in this order the loaded data will be put into each store.\n         *\n         * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`\n         * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.\n         *\n         * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store\n         * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.\n         * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position\n         * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.\n         * Otherwise, it will be just a position in stores collection.\n         *\n         * ```javascript\n         * // insert stores store4, store5 to the start of collection\n         * crudManager.addCrudStore([ store4, store5 ], 0);\n         * ```\n         *\n         * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position\n         * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of\n         * {@link #function-getStoreDescriptor} call).\n         *\n         * ```javascript\n         * // insert store6 just before a store having storeId equal to 'foo'\n         * crudManager.addCrudStore(store6, 0, 'foo');\n         *\n         * // insert store7 just after store3 store\n         * crudManager.addCrudStore(store7, 1, store3);\n         * ```\n         * @category CRUD\n         */\n        addCrudStore(store, position, fromStore) {\n            store = ArrayHelper.asArray(store);\n\n            if (!store?.length) {\n                return;\n            }\n\n            const\n                me     = this,\n                stores = store.map(me.internalAddCrudStore, me);\n\n            // if no position specified then append stores to the end\n            if (typeof position === 'undefined') {\n                me.crudStores.push(...stores);\n            }\n            // if position specified\n            else {\n                // if specified the store relative to which we should insert new one(-s)\n                if (fromStore) {\n                    if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);\n                    // get its position\n                    position += me.crudStores.indexOf(fromStore);\n                }\n                // insert new store(-s)\n                me.crudStores.splice(position, 0, ...stores);\n            }\n\n            me.orderedCrudStores.push(...stores);\n\n            me.updateCrudStoreIndex();\n        }\n\n        // Adds configured scheduler stores to the store collection ensuring correct order\n        // unless they're already registered.\n        addPrioritizedStore(store) {\n            const me = this;\n\n            if (!me.hasCrudStore(store)) {\n                me.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));\n            }\n            if (!me.hasApplySequenceStore(store)) {\n                me.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));\n            }\n        }\n\n        hasCrudStore(store) {\n            return this.crudStores?.some(s => s === store || s.store === store || s.storeId === store);\n        }\n\n        /**\n         * Removes a store from collection. If the store was registered in alternative sync sequence list\n         * it will be removed from there as well.\n         *\n         * ```javascript\n         * // remove store having storeId equal to \"foo\"\n         * crudManager.removeCrudStore(\"foo\");\n         *\n         * // remove store3\n         * crudManager.removeCrudStore(store3);\n         * ```\n         *\n         * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store\n         * descriptor, store identifier or store itself.\n         * @category CRUD\n         */\n        removeCrudStore(store) {\n            const\n                me         = this,\n                stores     = me.crudStores,\n                foundStore = stores.find(s => s === store || s.store === store || s.storeId === store);\n\n            if (foundStore) {\n                // unbind store listeners\n                me.unbindCrudStoreListeners(foundStore.store);\n\n                delete me.crudStoresIndex[foundStore.storeId];\n                ArrayHelper.remove(stores, foundStore);\n\n                if (me.syncApplySequence) {\n                    me.removeStoreFromApplySequence(store);\n                }\n            }\n            else {\n                throw new Error('Store not found in stores collection');\n            }\n        }\n\n        //endregion\n\n        //region Store listeners\n\n        bindCrudStoreListeners(store) {\n            store.ion({\n                name : store.id,\n\n                // When a tentatively added record gets confirmed as permanent, this signals a change\n                addConfirmed : 'onCrudStoreChange',\n                change       : 'onCrudStoreChange',\n                destroy      : 'onCrudStoreDestroy',\n                thisObj      : this\n            });\n        }\n\n        unbindCrudStoreListeners(store) {\n            this.detachListeners(store.id);\n        }\n\n        //endregion\n\n        //region Apply sequence\n\n        /**\n         * Adds a store to the alternative sync responses apply sequence.\n         * By default, the order in which sync responses are applied to the stores is the same as they registered in.\n         * But this order can be changes either on construction step using {@link #config-syncApplySequence} option\n         * or by calling this method.\n         *\n         * **Please note**, that if the sequence was not initialized before this method call then\n         * you will have to do it yourself like this for example:\n         *\n         * ```javascript\n         * // alternative sequence was not set for this crud manager\n         * // so let's fill it with existing stores keeping the same order\n         * crudManager.addStoreToApplySequence(crudManager.crudStores);\n         *\n         * // and now we can add our new store\n         *\n         * // we will load its data last\n         * crudManager.addCrudStore(someNewStore);\n         * // but changes to it will be applied first\n         * crudManager.addStoreToApplySequence(someNewStore, 0);\n         * ```\n         * add registered stores to the sequence along with the store(s) you want to add\n         *\n         * @param {Core.data.Store|CrudManagerStoreDescriptor|Core.data.Store[]|CrudManagerStoreDescriptor[]} store The\n         * store to add or its _descriptor_ (or array of stores or descriptors).\n         * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position\n         * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.\n         * Otherwise, it will be just a position in stores collection.\n         *\n         * ```javascript\n         * // insert stores store4, store5 to the start of sequence\n         * crudManager.addStoreToApplySequence([ store4, store5 ], 0);\n         * ```\n         * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position\n         * should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of\n         * {@link #function-getStoreDescriptor} call).\n         *\n         * ```javascript\n         * // insert store6 just before a store having storeId equal to 'foo'\n         * crudManager.addStoreToApplySequence(store6, 0, 'foo');\n         *\n         * // insert store7 just after store3 store\n         * crudManager.addStoreToApplySequence(store7, 1, store3);\n         * ```\n         * @category CRUD\n         */\n        addStoreToApplySequence(store, position, fromStore) {\n            if (!store) {\n                return;\n            }\n\n            store = ArrayHelper.asArray(store);\n\n            const\n                me   = this,\n                // loop over list of stores to add\n                data = store.reduce((collection, store) => {\n                    const s = me.getStoreDescriptor(store);\n                    s && collection.push(s);\n                    return collection;\n                }, []);\n\n            // if no position specified then append stores to the end\n            if (typeof position === 'undefined') {\n                me.syncApplySequence.push(...data);\n\n                // if position specified\n            }\n            else {\n                let pos = position;\n                // if specified the store relative to which we should insert new one(-s)\n                if (fromStore) {\n                    if (fromStore instanceof Store || typeof fromStore !== 'object') fromStore = me.getStoreDescriptor(fromStore);\n                    // get its position\n                    pos += me.syncApplySequence.indexOf(fromStore);\n                }\n                // insert new store(-s)\n                //me.syncApplySequence.splice.apply(me.syncApplySequence, [].concat([pos, 0], data));\n                me.syncApplySequence.splice(pos, 0, ...data);\n            }\n\n            const sequenceKeys = me.syncApplySequence.map(({ storeId }) => storeId);\n\n            me.orderedCrudStores = [...me.syncApplySequence];\n            me.crudStores.forEach(storeDesc => {\n                if (!sequenceKeys.includes(storeDesc.storeId)) {\n                    me.orderedCrudStores.push(storeDesc);\n                }\n            });\n        }\n\n        /**\n         * Removes a store from the alternative sync sequence.\n         *\n         * ```javascript\n         * // remove store having storeId equal to \"foo\"\n         * crudManager.removeStoreFromApplySequence(\"foo\");\n         * ```\n         *\n         * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store\n         * descriptor, store identifier or store itself.\n         * @category CRUD\n         */\n        removeStoreFromApplySequence(store) {\n            const index = this.syncApplySequence.findIndex(s => s === store || s.store === store || s.storeId === store);\n            if (index > -1) {\n                this.syncApplySequence.splice(index, 1);\n\n                // ordered crud stores list starts with syncApplySequence, we can use same index\n                this.orderedCrudStores.splice(index, 1);\n            }\n        }\n\n        hasApplySequenceStore(store) {\n            return this.syncApplySequence.some(s => s === store || s.store === store || s.storeId === store);\n        }\n\n        //endregion\n\n        //region Events\n\n        // Remove stores that are destroyed, to not try and apply response changes etc to them\n        onCrudStoreDestroy({ source : store }) {\n            this.removeCrudStore(store);\n        }\n\n        onCrudStoreChange(event) {\n            const me = this;\n\n            if (me.crudIgnoreUpdates) {\n                return;\n            }\n\n            /**\n             * Fires when data in any of the registered data stores is changed.\n             * ```javascript\n             *     crudManager.on('hasChanges', function (crud) {\n             *         // enable persist changes button when some store gets changed\n             *         saveButton.enable();\n             *     });\n             * ```\n             * @event hasChanges\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n             */\n\n            if (me.crudStoreHasChanges(event?.source)) {\n                me.trigger('hasChanges');\n\n                if (me.autoSync) {\n                    me.scheduleAutoSync();\n                }\n            }\n            else {\n                me.trigger('noChanges');\n            }\n        }\n\n        /**\n         * Suspends automatic sync upon store changes. Can be called multiple times (it uses an internal counter).\n         * @category CRUD\n         */\n        suspendAutoSync() {\n            this.autoSyncSuspendCounter++;\n        }\n\n        /**\n         * Resumes automatic sync upon store changes. Will trigger commit if the internal counter is 0.\n         * @param {Boolean} [doSync=true] Pass `true` to trigger data syncing after resuming (if there are pending\n         * changes) and `false` to not persist the changes.\n         * @category CRUD\n         */\n        resumeAutoSync(doSync = true) {\n            const me = this;\n\n            me.autoSyncSuspendCounter--;\n\n            if (me.autoSyncSuspendCounter <= 0) {\n                me.autoSyncSuspendCounter = 0;\n\n                // if its told to trigger persisting and there are changes\n                if (doSync && me.autoSync && me.crudStoreHasChanges()) {\n                    me.sync();\n                }\n            }\n        }\n\n        get isAutoSyncSuspended() {\n            return this.autoSyncSuspendCounter > 0;\n        }\n\n        scheduleAutoSync() {\n            const me = this;\n\n            // add deferred call if it's not scheduled yet\n            if (!me.hasTimeout('autoSync') && !me.isAutoSyncSuspended) {\n                me.setTimeout({\n                    name : 'autoSync',\n                    fn   : () => {\n                        me.sync().catch(error => {\n                            // <debug>\n                            if (!me.hasListener('syncFail') && !me.hasListener('requestFail') && !me.onSyncFail && !me.onRequestFail) {\n                                console.warn('CrudManager error while auto-syncing the data (please setup \"syncFail\" or \"requestFail\" event listeners to handle such cases)\\n', error);\n                            }\n                            // </debug>\n                        });\n                    },\n                    delay : me.autoSyncTimeout\n                });\n            }\n        }\n\n        async triggerFailedRequestEvents(request, response, responseText, fetchOptions) {\n            const { options, type : requestType } = request;\n\n            /**\n             * Fires when a request fails.\n             * @event requestFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             */\n            this.trigger('requestFail', { requestType, response, responseText, responseOptions : fetchOptions });\n            /**\n             * Fires when a {@link #function-load load request} fails.\n             * @event loadFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             * @params {Object} options Options provided to the {@link #function-load} method.\n             */\n            /**\n             * Fires when a {@link #function-sync sync request} fails.\n             * @event syncFail\n             * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager instance.\n             * @param {Object} response The decoded server response object.\n             * @param {String} responseText The raw server response text\n             * @param {Object} responseOptions The response options.\n             */\n            this.trigger(requestType + 'Fail', { response, responseOptions : fetchOptions, responseText, options });\n        }\n\n        async internalOnResponse(request, responseText, fetchOptions) {\n            const\n                me                              = this,\n                response                        = responseText ? me.decode(responseText) : null,\n                { options, type : requestType } = request;\n\n            if (responseText && !response) {\n                console.error('Failed to parse response: ' + responseText);\n            }\n\n            if (!response || (me.skipSuccessProperty ? response.success === false : !response.success)) {\n                me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);\n            }\n            else if ((me.trigger('beforeResponseApply', { requestType, response }) !== false) &&\n                (me.trigger(`before${StringHelper.capitalize(requestType)}Apply`, { response, options }) !== false)) {\n\n                me.crudRevision = response.revision;\n\n                await me.applyResponse(request, response, options);\n\n                // Might have been destroyed while applying response\n                if (me.isDestroyed) {\n                    return;\n                }\n\n                /**\n                 * Fires on successful request completion after data gets applied to the stores.\n                 * @event requestDone\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {'sync'|'load'} requestType The request type (`sync` or `load`).\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 */\n                me.trigger('requestDone', { requestType, response, responseOptions : fetchOptions });\n                /**\n                 * Fires on successful {@link #function-load load request} completion after data gets loaded to the stores.\n                 * @event load\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 * @params {Object} options Options provided to the {@link #load} method.\n                 */\n                /**\n                 * Fires on successful {@link #function-sync sync request} completion.\n                 * @event sync\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} response The decoded server response object.\n                 * @param {Object} responseOptions The server response options.\n                 */\n                me.trigger(requestType, { response, responseOptions : fetchOptions, options });\n\n                if (requestType === 'load' || !me.crudStoreHasChanges()) {\n                    /**\n                     * Fires when registered stores get into state when they don't have any\n                     * not persisted change. This happens after {@link #function-load} or {@link #function-sync} request\n                     * completion. Or this may happen after a record update which turns its fields back to their original state.\n                     *\n                     * ```javascript\n                     * crudManager.on('nochanges', function (crud) {\n                     *     // disable persist changes button when there is no changes\n                     *     saveButton.disable();\n                     * });\n                     * ```\n                     *\n                     * @event noChanges\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     */\n                    me.trigger('noChanges');\n\n                    if (requestType === 'load') {\n                        me.emitCrudStoreEvents(request.pack.stores, 'afterRequest');\n                    }\n                }\n            }\n\n            return response;\n        }\n\n        //endregion\n\n        //region Changes tracking\n\n        suspendChangesTracking() {\n            this.crudIgnoreUpdates++;\n        }\n\n        resumeChangesTracking(skipChangeCheck) {\n            if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates && !skipChangeCheck) {\n                this.onCrudStoreChange();\n            }\n        }\n\n        get isBatchingChanges() {\n            return this.crudIgnoreUpdates > 0;\n        }\n\n        /**\n         * Returns `true` if any of registered stores (or some particular store) has non persisted changes.\n         *\n         * ```javascript\n         * // if we have any unsaved changes\n         * if (crudManager.crudStoreHasChanges()) {\n         *     // persist them\n         *     crudManager.sync();\n         * // otherwise\n         * } else {\n         *     alert(\"There are no unsaved changes...\");\n         * }\n         * ```\n         *\n         * @param {String|Core.data.Store} [storeId] The store identifier or store instance to check changes for.\n         * If not specified then will check changes for all of the registered stores.\n         * @returns {Boolean} `true` if there are not persisted changes.\n         * @category CRUD\n         */\n        crudStoreHasChanges(storeId) {\n            return storeId\n                ? this.isCrudStoreDirty(this.getCrudStore(storeId))\n                : this.crudStores.some(config => this.isCrudStoreDirty(config.store));\n        }\n\n        isCrudStoreDirty(store) {\n            return Boolean(store.changes);\n        }\n\n        //endregion\n\n        //region Load\n\n        doAutoLoad() {\n            return this.load().catch(error => {\n                // <debug>\n                if (!this.isDestroyed && !this.hasListener('loadFail') && !this.hasListener('requestFail')) {\n                    console.warn('CrudManager error while auto-loading the data (please setup \"loadFail\" or \"requestFail\" event listeners to handle such cases)\\n', error);\n                }\n                // </debug>\n            });\n        }\n\n        emitCrudStoreEvents(stores, eventName, eventParams) {\n            const event = { action : 'read' + eventName, ...eventParams };\n\n            for (const store of this.crudStores) {\n                if (stores.includes(store.storeId)) {\n                    store.store.trigger(eventName, event);\n                }\n            }\n        }\n\n        getLoadPackage(options) {\n            const\n                pack        = {\n                    type      : 'load',\n                    requestId : this.requestId\n                },\n                stores      = this.crudStores,\n                optionsCopy = Object.assign({}, options);\n\n            // This is a special option which does not apply to a store.\n            // It's used as options to the AjaxTransport#sendRequest method\n            delete optionsCopy.request;\n\n            pack.stores = stores.map(store => {\n                const\n                    opts     = optionsCopy?.[store.storeId],\n                    pageSize = store.pageSize || store.store?.pageSize;\n\n                // TODO: PORT currently no support for remote filters\n                // if the store uses remote filtering\n                // if (store.store.remoteFilter && filterParam) {\n                //\n                //     opts = opts || {};\n                //\n                //     var filters = [];\n                //\n                //     store.store.getFilters().each(function(f) {\n                //         filters.push(f.serialize());\n                //     });\n                //\n                //     // put filters info into the package\n                //     opts[filterParam] = filters;\n                // }\n\n                // TODO: PORT currently no support for paging\n                if (opts || pageSize) {\n                    const\n                        params = Object.assign({\n                            storeId : store.storeId,\n                            page    : 1\n                        }, opts);\n\n                    if (pageSize) {\n                        params.pageSize = pageSize;\n                    }\n\n                    store.currentPage = params.page;\n\n                    // Remove from common request options\n                    if (opts) {\n                        delete optionsCopy[store.storeId];\n                    }\n\n                    return params;\n                }\n\n                return store.storeId;\n            });\n\n            // Apply common request options\n            Object.assign(pack, optionsCopy);\n\n            return pack;\n        }\n\n        loadCrudStore(store, data, options) {\n            const rows = data?.rows;\n\n            if (options?.append || data?.append) {\n                store.add(rows);\n            }\n            else {\n                store.data = rows;\n            }\n\n            store.trigger('load', { data : rows });\n        }\n\n        loadDataToCrudStore(storeDesc, data, options) {\n            const\n                store = storeDesc.store,\n                rows  = data?.rows;\n\n            store.__loading = true;\n\n            if (rows) {\n                this.loadCrudStore(store, data, options, storeDesc);\n            }\n\n            store.__loading = false;\n        }\n\n        /**\n         * Loads data to the Crud Manager\n         * @param {Object} response A simple object representing the data.\n         * The object structure matches the decoded `load` response structure:\n         *\n         * ```js\n         * // load static data into crudManager\n         * crudManager.loadCrudManagerData({\n         *     success   : true,\n         *     resources : {\n         *         rows : [\n         *             { id : 1, name : 'John' },\n         *             { id : 2, name : 'Abby' }\n         *         ]\n         *     }\n         * });\n         * ```\n         * @param {Object} [options] Extra data loading options.\n         * @category CRUD\n         */\n        loadCrudManagerData(response, options = {}) {\n            // we don't want to react to store changes during loading of them\n            this.suspendChangesTracking();\n\n            // we load data to the stores in the order they're kept in this.stores array\n            this.crudStores.forEach(storeDesc => {\n                const\n                    storeId = storeDesc.storeId,\n                    data    = response[storeId];\n\n                if (data) {\n                    this.loadDataToCrudStore(storeDesc, data, options[storeId]);\n                }\n            });\n\n            this.resumeChangesTracking(true);\n        }\n\n        /**\n         * Returns true if the crud manager is currently loading data\n         * @property {Boolean}\n         * @readonly\n         * @category CRUD\n         */\n        get isCrudManagerLoading() {\n            return Boolean(this.activeRequests.load || this.applyingLoadResponse);\n        }\n\n        /**\n         * Returns true if the crud manager is currently syncing data\n         * @property {Boolean}\n         * @readonly\n         * @category CRUD\n         */\n        get isCrudManagerSyncing() {\n            return Boolean(this.activeRequests.sync || this.applyingSyncResponse);\n        }\n\n        get isLoadingOrSyncing() {\n            return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing);\n        }\n\n        /**\n         * Loads data to the stores registered in the crud manager. For example:\n         *\n         * ```javascript\n         * crudManager.load(\n         *     // here are request parameters\n         *     {\n         *         store1 : { append : true, page : 3, smth : 'foo' },\n         *         store2 : { page : 2, bar : '!!!' }\n         *     }\n         * ).then(\n         *     () => alert('OMG! It works!'),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.\n         * @param {Object|String} [options] The request parameters or a URL.\n         * @param {Object} [options.request] An object which contains options to merge\n         * into the options which are passed to {@link Scheduler/crud/transport/AjaxTransport#function-sendRequest}.\n         * ```javascript\n         * {\n         *     store1 : { page : 3, append : true, smth : 'foo' },\n         *     store2 : { page : 2, bar : '!!!' },\n         *     request : {\n         *         params : {\n         *             startDate : '2021-01-01'\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * Omitting request arg:\n         * ```javascript\n         * crudManager.load().then(\n         *     () => alert('OMG! It works!'),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * When presented it should be an object where keys are store Ids and values are, in turn, objects\n         * of parameters related to the corresponding store. These parameters will be transferred in each\n         * store's entry in the `stores` property of the POST data.\n         *\n         * Additionally, for flat stores `append: true` can be specified to add loaded records to the existing records,\n         * default is to remove corresponding store's existing records first.\n         * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.\n         * @param {'sync'|'load'} [options.request.type] The request type. Either `load` or `sync`.\n         * @param {String} [options.request.url] The URL for the request. Overrides the URL defined in the `transport`\n         * object\n         * @param {String} [options.request.data] The encoded _Crud Manager_ request data.\n         * @param {Object} [options.request.params] An object specifying extra HTTP params to send with the request.\n         * @param {Function} [options.request.success] A function to be started on successful request transferring.\n         * @param {String} [options.request.success.rawResponse] `Response` object returned by the\n         * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n         * @param {Function} [options.request.failure] A function to be started on request transfer failure.\n         * @param {String} [options.request.failure.rawResponse] `Response` object returned by the\n         * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n         * @param {Object} [options.request.thisObj] `this` reference for the above `success` and `failure` functions.\n         * @returns {Promise} Promise, which is resolved if request was successful.\n         * Both the resolve and reject functions are passed a `state` object. State object has following structure:\n         *\n         * ```\n         * {\n         *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected\n         *     rawResponse     : String,  // raw response from ajax request, either response xml or text\n         *     rawResponseText : String,  // raw response text as String from ajax request\n         *     response        : Object,  // processed response in form of object\n         *     options         : Object   // options, passed to load request\n         * }\n         * ```\n         *\n         * If promise was rejected by {@link #event-beforeLoad} event, `state` object will have the following structure:\n         *\n         * ```\n         * {\n         *     cancelled : true\n         * }\n         * ```\n         * @category CRUD\n         * @async\n         */\n        load(options) {\n            if (typeof options === 'string') {\n                options = {\n                    request : {\n                        url : options\n                    }\n                };\n            }\n\n            const\n                me   = this,\n                pack = me.getLoadPackage(options);\n\n            return new Promise((resolve, reject) => {\n                /**\n                 * Fires before {@link #function-load load request} is sent. Return `false` to cancel load request.\n                 * @event beforeLoad\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                 */\n                if (me.trigger('beforeLoad', { pack }) !== false) {\n                    // if another load request is in progress let's cancel it\n                    const { load } = me.activeRequests;\n\n                    if (load) {\n                        me.cancelRequest(load.desc, load.reject);\n\n                        me.trigger('loadCanceled', { pack });\n                    }\n\n                    // TODO: refactor this\n                    const request = Objects.assign({\n                        id      : pack.requestId,\n                        data    : me.encode(pack),\n                        type    : 'load',\n                        success : me.onCrudRequestSuccess,\n                        failure : me.onCrudRequestFailure,\n                        thisObj : me\n                    }, options?.request);\n\n                    me.activeRequests.load = {\n                        type : 'load',\n                        options,\n                        pack,\n                        resolve,\n                        reject(...args) {\n                            // sendRequest will start a fetch promise, which we cannot reject from here. In fact what we\n                            // need to do, is to make fetch.then() to not call any real handlers. Which is what we do here.\n                            request.success = request.failure = null;\n                            reject(...args);\n                        },\n                        id   : pack.requestId,\n                        desc : me.sendRequest(request)\n                    };\n\n                    me.emitCrudStoreEvents(pack.stores, 'loadStart');\n\n                    me.trigger('loadStart', { pack });\n                }\n                else {\n                    /**\n                     * Fired after {@link #function-load load request} was canceled by some {@link #event-beforeLoad}\n                     * listener or due to incomplete prior load request.\n                     * @event loadCanceled\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     * @param {Object} pack The data package which contains data for all stores managed by the crud\n                     * manager.\n                     */\n                    me.trigger('loadCanceled', { pack });\n                    reject({ cancelled : true });\n                }\n            });\n        }\n\n        getActiveCrudManagerRequest(requestType) {\n            let request = this.activeRequests[requestType];\n\n            if (!request && this.trackResponseType) {\n                request = Object.values(this.activeRequests)[0];\n            }\n\n            return request;\n        }\n\n        //endregion\n\n        //region Changes (prepare, process, get)\n\n        prepareAddedRecordData(record, storeInfo) {\n            const\n                me                   = this,\n                { store }            = storeInfo,\n                { isTree }           = store,\n                phantomIdField       = storeInfo.phantomIdField || me.phantomIdField,\n                phantomParentIdField = storeInfo.phantomParentIdField || me.phantomParentIdField,\n                subStoreFields       = store.modelClass.allFields.filter(field => field.subStore),\n                cls                  = record.constructor,\n                data                 = Object.assign(record.persistableData, {\n                    [phantomIdField] : record.id\n                });\n\n            if (isTree) {\n                const { parent } = record;\n\n                if (parent && !parent.isRoot && parent.isPhantom) {\n                    data[phantomParentIdField] = parent.id;\n                }\n            }\n\n            if (me.resetIdsBeforeSync) {\n                ObjectHelper.deletePath(data, cls.idField);\n            }\n\n            // If we have store fields that should be persisted w/ Crud Manager protocol\n            subStoreFields.forEach(field => {\n                const subStore = record.get(field.name);\n\n                if (subStore.allCount) {\n                    data[field.dataSource] = {\n                        added : subStore.getRange()\n                            .map(record => me.prepareAddedRecordData(record, { store : subStore }))\n                    };\n                }\n            });\n\n            return data;\n        }\n\n        prepareAdded(list, storeInfo) {\n            return list.filter(record => record.isValid).map(record => this.prepareAddedRecordData(record, storeInfo));\n        }\n\n        prepareUpdated(list, storeInfo) {\n            const\n                { store }            = storeInfo,\n                { isTree }           = store,\n                writeAllFields       = storeInfo.writeAllFields || (storeInfo.writeAllFields !== false && this.writeAllFields),\n                phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField,\n                subStoreFields       = store.modelClass.allFields.filter(field => field.subStore);\n\n            // TODO: root node included into store.modified\n            // need to get rid of it since we don't persist it\n            if (storeInfo.store.tree) {\n                const\n                    rootNode = storeInfo.store.rootNode;\n                list = list.filter(record => record !== rootNode);\n            }\n\n            return list.filter(record => record.isValid).reduce((data, record) => {\n                let recordData;\n\n                // write all fields\n                if (writeAllFields) {\n                    recordData = record.persistableData;\n                }\n                else {\n                    recordData = record.modificationDataToWrite;\n                }\n\n                if (isTree) {\n                    const { parent } = record;\n\n                    if (parent && !parent.isRoot && parent.isPhantom) {\n                        recordData[phantomParentIdField] = parent.id;\n                    }\n                }\n\n                // If we have store fields that should be persisted w/ Crud Manager protocal\n                subStoreFields.forEach(field => {\n                    const subStore = record.get(field.name);\n\n                    recordData[field.dataSource] = this.getCrudStoreChanges({ store : subStore });\n                });\n\n                // recordData can be null\n                if (!ObjectHelper.isEmpty(recordData)) {\n                    data.push(recordData);\n                }\n\n                return data;\n            }, []);\n        }\n\n        prepareRemoved(list) {\n            return list.map(record => {\n                const cls = record.constructor;\n\n                return ObjectHelper.setPath({}, cls.idField, record.id);\n            });\n        }\n\n        getCrudStoreChanges(storeDescriptor) {\n            const { store } = storeDescriptor;\n\n            let { added = [], modified : updated = [], removed = [] } = (store.changes || {}),\n                result;\n\n            if (added.length) added = this.prepareAdded(added, storeDescriptor);\n            if (updated.length) updated = this.prepareUpdated(updated, storeDescriptor);\n            if (removed.length) removed = this.prepareRemoved(removed);\n\n            // if this store has changes\n            if (added.length || updated.length || removed.length) {\n                result = {};\n\n                if (added.length) result.added = added;\n                if (updated.length) result.updated = updated;\n                if (removed.length) result.removed = removed;\n            }\n\n            return result;\n        }\n\n        getChangesetPackage() {\n            const { changes } = this;\n\n            return changes || this.forceSync\n                ? {\n                    type      : 'sync',\n                    requestId : this.requestId,\n                    revision  : this.crudRevision,\n                    ...changes\n                } : null;\n        }\n\n        //endregion\n\n        //region Apply\n\n        /**\n         * Returns current changes as an object consisting of added/modified/removed arrays of records for every\n         * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:\n         *\n         * ```javascript\n         * {\n         *     resources : {\n         *         added    : [{ name : 'New guy' }],\n         *         modified : [{ id : 2, name : 'Mike' }],\n         *         removed  : [{ id : 3 }]\n         *     },\n         *     events : {\n         *         modified : [{  id : 12, name : 'Cool task' }]\n         *     },\n         *     ...\n         * }\n         * ```\n         *\n         * @property {Object}\n         * @readonly\n         * @category CRUD\n         */\n        get changes() {\n            const data = {};\n\n            this.crudStores.forEach(store => {\n                const changes = this.getCrudStoreChanges(store);\n\n                if (changes) {\n                    data[store.storeId] = changes;\n                }\n            });\n\n            return Object.keys(data).length > 0 ? data : null;\n        }\n\n        getRowsToApplyChangesTo({ store, storeId }, storeResponse, storePack) {\n            const\n                me             = this,\n                { modelClass } = store,\n                idDataSource   = modelClass.idField,\n                // request data\n                {\n                    updated : requestUpdated,\n                    removed : requestRemoved\n                }              = storePack || {};\n\n            let rows, removed, remote;\n\n            // If the response contains the store section\n            if (storeResponse) {\n                remote = true;\n\n                const respondedIds = {};\n\n                // responded record changes/removals\n                rows    = storeResponse.rows?.slice() || [];\n                removed = storeResponse.removed?.slice() || [];\n\n                // Collect hash w/ identifiers of responded records\n                [...rows, ...removed].forEach(responseRecord => {\n                    const id = ObjectHelper.getPath(responseRecord, idDataSource);\n\n                    respondedIds[id] = true;\n                });\n\n                // If it's told to support providing server changes only in response\n                // CrudManager should collect other records to commit from current requested data\n                if (me.supportShortSyncResponse) {\n                    // append records requested to update (if not there already)\n                    requestUpdated?.forEach(data => {\n                        const id = ObjectHelper.getPath(data, idDataSource);\n\n                        // if response doesn't include\n                        if (!respondedIds[id]) {\n                            rows.push({ [idDataSource] : id });\n                        }\n                    });\n                    // append records requested to remove (if not there already)\n                    requestRemoved?.forEach(data => {\n                        const id = ObjectHelper.getPath(data, idDataSource);\n\n                        // if response doesn't include\n                        if (!respondedIds[id]) {\n                            removed.push({ [idDataSource] : id });\n                        }\n                    });\n                }\n\n            }\n            // If there is no this store section we use records mentioned in the current request\n            else if (requestUpdated || requestRemoved) {\n                remote  = false;\n                rows    = requestUpdated;\n                removed = requestRemoved;\n            }\n\n            // return nullish \"rows\"/\"removed\" if no entries\n            rows    = rows?.length ? rows : null;\n            removed = removed?.length ? removed : null;\n\n            return {\n                rows,\n                removed,\n                remote\n            };\n        }\n\n        applyChangesToStore(storeDesc, storeResponse, storePack) {\n            const\n                me                = this,\n                phantomIdField    = storeDesc.phantomIdField || me.phantomIdField,\n                { store }         = storeDesc,\n                idField           = store.modelClass.getFieldDataSource('id'),\n                subStoreFields    = store.modelClass.allFields.filter(field => field.subStore),\n                // collect records we need to process\n                { rows, removed, remote } = me.getRowsToApplyChangesTo(storeDesc, storeResponse, storePack),\n                added = [],\n                updated = [];\n\n            // Convert to the { updated, added } format accepted by stores\n            if (rows) {\n                for (const data of rows) {\n                    // Existing records are updated\n                    if (store.getById(data[phantomIdField] ?? data[idField])) {\n                        updated.push(data);\n                    }\n                    // Others added\n                    else {\n                        added.push(data);\n                    }\n                }\n            }\n\n            const extraLogEntries = [];\n\n            // Handle sub-stores (if any)\n            if (updated.length && subStoreFields.length) {\n\n                updated.forEach(updateData => {\n                    const\n                        record = store.getById(updateData[phantomIdField] ?? updateData[idField]),\n                        // find the request portion related to the record\n                        recordRequest = storePack.added?.find(t => t[phantomIdField] == updateData[phantomIdField]) ||\n                            storePack.updated?.find(t => t[idField] == updateData[idField]);\n\n                    const extraLogInfo = {};\n\n                    subStoreFields.forEach(field => {\n                        const store = record.get(field.name);\n\n                        me.applyChangesToStore({ store }, updateData[field.dataSource],\n                            recordRequest?.[field.dataSource]\n                        );\n\n                        // We're putting the store field entry to the log\n                        // just to indicate the fact it was actually changed.\n                        // The value will not be used for comparison so we can use any.\n                        extraLogInfo[field.dataSource] = 'foo';\n\n                        delete updateData[field.dataSource];\n                    });\n\n                    extraLogEntries.push([record, extraLogInfo]);\n                });\n            }\n\n            // process added/updated records\n            const log = store.applyChangeset({ removed, added, updated }, null, phantomIdField, remote, true);\n\n            extraLogEntries.forEach(([record, logEntry]) => Object.assign(log.get(record.id), logEntry));\n\n            return log;\n        }\n\n        applySyncResponse(response, request) {\n            const\n                me     = this,\n                stores = me.orderedCrudStores;\n\n            me.applyingChangeset = me.applyingSyncResponse = true;\n            me.suspendChangesTracking();\n\n            for (const store of stores) {\n                me.applyChangesToStore(store, response[store.storeId], request?.pack?.[store.storeId]);\n            }\n\n            me.resumeChangesTracking(true);\n            me.applyingChangeset = me.applyingSyncResponse = false;\n        }\n\n        applyLoadResponse(response, options) {\n            this.applyingLoadResponse = true;\n\n            this.loadCrudManagerData(response, options);\n\n            this.applyingLoadResponse = false;\n        }\n\n        async applyResponse(request, response, options) {\n            const\n                me = this,\n                // in trackResponseType mode we check response type before deciding how to react on the response\n                responseType = me.trackResponseType && response.type || request.type;\n\n            switch (responseType) {\n                case 'load' :\n                    if (me.validateResponse) {\n                        me.validateLoadResponse(response);\n                    }\n\n                    me.applyLoadResponse(response, options);\n                    break;\n                case 'sync' :\n                    if (me.validateResponse) {\n                        me.validateSyncResponse(response, request);\n                    }\n\n                    me.applySyncResponse(response, request);\n                    break;\n            }\n        }\n\n        /**\n         * Applies a set of changes, as an object keyed by store id, to the affected stores. This function is intended\n         * to use in apps that handle their own data syncing, it is not needed when using the CrudManager approach.\n         *\n         * Example of a changeset:\n         * ```javascript\n         * project.applyChangeset({\n         *     events : {\n         *         added : [\n         *             { id : 10, name : 'Event 10', startDate : '2022-06-07' }\n         *         ],\n         *         updated : [\n         *             { id : 5, name : 'Changed' }\n         *         ],\n         *         removed : [\n         *             { id : 1 }\n         *         ]\n         *     },\n         *     resources : { ... },\n         *     ...\n         * });\n         * ```\n         *\n         * Optionally accepts a `transformFn` to convert an incoming changeset to the expected format.\n         * See {@link Core/data/Store#function-applyChangeset} for more details.\n         *\n         * @param {Object} changes Changeset to apply, an object keyed by store id where each value follows the\n         * format described in {@link Core/data/Store#function-applyChangeset}\n         * @param {Function} [transformFn] Optional function used to preprocess a changeset per store in a different\n         * format, should return an object with the format expected by {@link Core/data/Store#function-applyChangeset}\n         * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a\n         * proper id instead of a phantom id\n         */\n        applyChangeset(changes, transformFn = null, phantomIdField, logChanges = false) {\n            const\n                me  = this,\n                log = logChanges ? new Map() : undefined;\n\n            me.suspendAutoSync();\n            me.suspendChangesTracking();\n\n            for (const { store, phantomIdField } of me.orderedCrudStores) {\n                if (changes[store.id]) {\n                    const storeLog = store.applyChangeset(\n                        changes[store.id],\n                        transformFn,\n                        phantomIdField || me.phantomIdField,\n                        // mark this changeset as remote to enforce it\n                        true,\n                        logChanges\n                    );\n\n                    if (storeLog) {\n                        log.set(store.id, storeLog);\n                    }\n                }\n            }\n\n            me.resumeChangesTracking(true);\n            me.resumeAutoSync(false);\n\n            return log;\n        }\n\n        //endregion\n\n        /**\n         * Generates unique request identifier.\n         * @internal\n         * @template\n         * @returns {Number} The request identifier.\n         * @category CRUD\n         */\n        get requestId() {\n            return Number.parseInt(`${Date.now()}${(this._requestId++)}`);\n        }\n\n        /**\n         * Persists changes made on the registered stores to the server and/or receives changes made on the backend.\n         * Usage:\n         *\n         * ```javascript\n         * // persist and run a callback on request completion\n         * crud.sync().then(\n         *     () => console.log(\"Changes saved...\"),\n         *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)\n         * );\n         * ```\n         *\n         * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it\n         * until previous request completion.\n         * In this case {@link #event-syncDelayed} event will be fired.\n         *\n         * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes\n         * automatically after any data modification.\n         *\n         * ** Note: ** By default a sync request is only sent if there are any local {@link #property-changes}. To\n         * always send a request when calling this function, configure {@link #config-forceSync} as `true`.\n         *\n         * @returns {Promise} Promise, which is resolved if request was successful.\n         * Both the resolve and reject functions are passed a `state` object. State object has the following structure:\n         * ```\n         * {\n         *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected\n         *     rawResponse     : String,  // raw response from ajax request, either response xml or text\n         *     rawResponseText : String,  // raw response text as String from ajax request\n         *     response        : Object,  // processed response in form of object\n         * }\n         * ```\n         * If promise was rejected by the {@link #event-beforeSync} event, `state` object will have this structure:\n         * ```\n         * {\n         *     cancelled : true\n         * }\n         * ```\n         * @category CRUD\n         * @async\n         */\n        sync() {\n            const me = this;\n\n            // A direct call to sync cancels any outstanding autoSync\n            me.clearTimeout('autoSync');\n\n            if (me.activeRequests.sync) {\n                // let's delay this call and start it only after server response\n                /**\n                 * Fires after {@link #function-sync sync request} was delayed due to incomplete previous one.\n                 * @event syncDelayed\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} arguments The arguments of {@link #function-sync} call.\n                 */\n                me.trigger('syncDelayed');\n\n                // Queue sync request after current one\n                return me.activeSyncPromise = me.activeSyncPromise.finally(() => me.sync());\n            }\n\n            // Store current request promise. While this one is pending, all following sync requests will create chain\n            // of sequential promises\n            return me.activeSyncPromise = new Promise((resolve, reject) => {\n                // get current changes set package\n                const pack = me.getChangesetPackage();\n\n                // if no data to persist we resolve immediately\n                if (!pack) {\n                    resolve(null);\n                    return;\n                }\n\n                /**\n                 * Fires before {@link #function-sync sync request} is sent. Return `false` to cancel sync request.\n                 *\n                 * ```javascript\n                 * crudManager.on('beforesync', function() {\n                 *     // cannot persist changes before at least one record is added\n                 *     // to the `someStore` store\n                 *     if (!someStore.getCount()) return false;\n                 * });\n                 * ```\n                 * @event beforeSync\n                 * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                 * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                 */\n                if (me.trigger('beforeSync', { pack }) !== false) {\n\n                    me.trigger('syncStart', { pack });\n\n                    // keep active request details\n                    me.activeRequests.sync = {\n                        type : 'sync',\n                        pack,\n                        resolve,\n                        reject,\n                        id   : pack.requestId,\n                        desc : me.sendRequest({\n                            id      : pack.requestId,\n                            data    : me.encode(pack),\n                            type    : 'sync',\n                            success : me.onCrudRequestSuccess,\n                            failure : me.onCrudRequestFailure,\n                            thisObj : me\n                        })\n                    };\n                }\n                else {\n                    /**\n                     * Fires after {@link #function-sync sync request} was canceled by some {@link #event-beforeSync} listener.\n                     * @event syncCanceled\n                     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.\n                     * @param {Object} pack The data package which contains data for all stores managed by the crud manager.\n                     */\n                    me.trigger('syncCanceled', { pack });\n                    reject({ cancelled : true });\n                }\n            }).catch(error => {\n                // If the request was not cancelled in beforeSync listener, forward the error so the user's `catch` handler can catch it\n                if (error && !error.cancelled) {\n                    throw error;\n                }\n\n                // Pass the error object as a param to the next `then` chain\n                return error;\n            });\n        }\n\n        async onCrudRequestSuccess(rawResponse, fetchOptions, request) {\n            const\n                me = this,\n                {\n                    type : requestType,\n                    id   : requestId\n                }  = request;\n\n            if (me.isDestroyed) return;\n\n            let responseText = '';\n\n            request = me.activeRequests[requestType];\n\n            // we throw exception below to let events trigger first in internalOnResponse() call\n            try {\n                responseText = await rawResponse.text();\n            }\n            catch (e) {\n            }\n\n            // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n            if (me.isDestroyed) return;\n\n            // This situation should never occur.\n            // In the load() method, if a load is called while there is a load\n            // ongoing, the ongoing Transport request is cancelled and loadCanceled triggered.\n            // But having got here, it's too late to cancel a Transport request, so\n            // the operation is unregistered below.\n            // In the sync() method, if a sync is called while there is a sync\n            // ongoing, it waits until completion, before syncing.\n            // The activeRequest for any operation should NEVER be able to be\n            // replaced while this operation is ongoing, so this must be fatal.\n            if (request?.id !== requestId) {\n                throw new Error(`Interleaved ${requestType} operation detected`);\n            }\n\n            // Reset the active request info before we enter async code which could allow\n            // application code to run which could potentially call another request.\n            // It is too late for this request to be canceled - the activeRequest represented\n            // the Transport object and that has completed now.\n            me.activeRequests[requestType] = null;\n\n            const response = await me.internalOnResponse(request, responseText, fetchOptions);\n\n            // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n            if (me.isDestroyed) return;\n\n            if (!response || (me.skipSuccessProperty ? response?.success === false : !response?.success)) {\n                const error = {\n                    rawResponse,\n                    response,\n                    request\n                };\n                if (response?.message) {\n                    error.message = response.message;\n                }\n                request.reject(new CrudManagerRequestError(error));\n            }\n\n            // Successful request type done flag (this.crudLoaded or this.crudSynced)..\n            me['crud' + StringHelper.capitalize(request.type) + 'ed'] = true;\n\n            request.resolve({ response, rawResponse, responseText, request });\n        }\n\n        async onCrudRequestFailure(rawResponse, fetchOptions, request) {\n            const me = this;\n\n            if (me.isDestroyed) return;\n\n            request = me.activeRequests[request.type];\n\n            const\n                signal      = fetchOptions?.abortController?.signal,\n                wasAborted  = Boolean(signal?.aborted);\n\n            if (!wasAborted) {\n                let response,\n                    responseText = '';\n\n                try {\n                    responseText = await rawResponse.text();\n                    response = me.decode(responseText);\n                }\n                catch (e) {\n                }\n\n                // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n                if (me.isDestroyed) return;\n\n                me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);\n\n                // since we break the method w/ promises chain ..need to check if the instance is not destroyed in the meantime\n                if (me.isDestroyed) return;\n\n                request.reject(new CrudManagerRequestError({\n                    rawResponse,\n                    request\n                }));\n            }\n\n            // reset the active request info\n            me.activeRequests[request.type] = null;\n        }\n\n        /**\n         * Accepts all changes in all stores, resets the modification tracking:\n         * * Clears change tracking for all records\n         * * Clears added\n         * * Clears modified\n         * * Clears removed\n         * Leaves the store in an \"unmodified\" state.\n         * @category CRUD\n         */\n        acceptChanges() {\n            this.crudStores.forEach(store => store.store.acceptChanges());\n        }\n\n        /**\n         * Reverts all changes in all stores and re-inserts any records that were removed locally. Any new uncommitted\n         * records will be removed.\n         * @category CRUD\n         */\n        revertChanges() {\n            // the method aliases revertCrudStoreChanges\n            this.revertCrudStoreChanges();\n        }\n\n        revertCrudStoreChanges() {\n            this.orderedCrudStores.forEach(store => store.store.revertChanges());\n        }\n\n        /**\n         * Removes all stores and cancels active requests.\n         * @category CRUD\n         * @internal\n         */\n        doDestroy() {\n            const\n                me             = this,\n                { load, sync } = me.activeRequests;\n\n            load && me.cancelRequest(load.desc, load.reject);\n            sync && me.cancelRequest(sync.desc, sync.reject);\n\n            while (me.crudStores.length > 0) {\n                me.removeCrudStore(me.crudStores[0]);\n            }\n\n            super.doDestroy && super.doDestroy();\n        }\n    };\n};\n","import Base from '../../../Core/Base.js';\nimport AjaxHelper from '../../../Core/helper/AjaxHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n\n/**\n * @module Scheduler/crud/transport/AjaxTransport\n */\n\n/**\n * Implements data transferring functional that can be used for {@link Scheduler.crud.AbstractCrudManager} super classing.\n * Uses the fetch API for transport, https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API\n *\n * @example\n * // create a new CrudManager using AJAX as a transport system and JSON for encoding\n * class MyCrudManager extends AjaxTransport(JsonEncode(AbstractCrudManager)) {}\n *\n * @abstract\n * @mixin\n */\nexport default Target => class AjaxTransport extends (Target || Base) {\n    static get $name() {\n        return 'AjaxTransport';\n    }\n\n    /**\n     * Configuration of the AJAX requests used by _Crud Manager_ to communicate with a server-side.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // pass extra HTTP request parameter\n     *         params    : {\n     *             foo : 'bar'\n     *         }\n     *     },\n     *     sync : {\n     *         url     : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for requests\n     *         headers : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     }\n     * }\n     *```\n     * Since the class uses Fetch API you can use\n     * any its [Request interface](https://developer.mozilla.org/en-US/docs/Web/API/Request) options:\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url         : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName   : 'data',\n     *         // pass few Fetch API options\n     *         method      : 'GET',\n     *         credentials : 'include',\n     *         cache       : 'no-cache'\n     *     },\n     *     sync : {\n     *         url         : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for requests\n     *         headers     : {\n     *             'Content-Type' : 'application/json'\n     *         },\n     *         credentials : 'include'\n     *     }\n     * }\n     *```\n     *\n     * An object where you can set the following possible properties:\n     * @config {Object} transport\n     * @property {Object} transport.load Load requests configuration:\n     * @property {String} transport.load.url URL to request for data loading.\n     * @property {String} [transport.load.method='GET'] HTTP method to be used for load requests.\n     * @property {String} [transport.load.paramName='data'] Name of the parameter that will contain a serialized `load`\n     * request. The value is mandatory for requests using `GET` method (default for `load`) so if the value is not\n     * provided `data` string is used as default.\n     * This value is optional for HTTP methods like `POST` and `PUT`, the request body will be used for data\n     * transferring in these cases.\n     * @property {Object} [transport.load.params] An object containing extra HTTP parameters to pass to the server when\n     * sending a `load` request.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // pass extra HTTP request parameter\n     *         // so resulting URL will look like: http://mycool-server.com/load.php?userId=123456&data=...\n     *         params    : {\n     *             userId : '123456'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object<String,String>} [transport.load.headers] An object containing headers to pass to each server request.\n     *\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url       : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName : 'data',\n     *         // specify Content-Type for \"load\" requests\n     *         headers   : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.load.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on\n     * the upper configuration level:\n     * ```javascript\n     * transport : {\n     *     load : {\n     *         url          : 'http://mycool-server.com/load.php',\n     *         // HTTP request parameter used to pass serialized \"load\"-requests\n     *         paramName    : 'data',\n     *         // Fetch API options\n     *         method       : 'GET',\n     *         credentials  : 'include'\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.load.requestConfig] **DEPRECATED:** The config options can be defined on the upper\n     * configuration level.\n     * @property {Object} transport.sync Sync requests (`sync` in further text) configuration:\n     * @property {String} transport.sync.url URL to request for `sync`.\n     * @property {String} [transport.sync.method='POST'] HTTP request method to be used for `sync`.\n     * @property {String} [transport.sync.paramName=undefined] Name of the parameter in which `sync` data will be\n     * transferred. This value is optional for requests using methods like `POST` and `PUT`, the request body will be\n     * used for data transferring in this case (default for `sync`). And the value is mandatory for requests using `GET`\n     * method (if the value is not provided `data` string will be used as fallback).\n     * @property {Object} [transport.sync.params] HTTP parameters to pass with an HTTP request handling `sync`.\n     *\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url    : 'http://mycool-server.com/sync.php',\n     *         // extra HTTP request parameter\n     *         params : {\n     *             userId : '123456'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object<String,String>} [transport.sync.headers] HTTP headers to pass with an HTTP request handling `sync`.\n     *\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url     : 'http://mycool-server.com/sync.php',\n     *         // specify Content-Type for \"sync\" requests\n     *         headers : {\n     *             'Content-Type' : 'application/json'\n     *         }\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.sync.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on\n     * the upper configuration level:\n     * ```javascript\n     * transport : {\n     *     sync : {\n     *         url         : 'http://mycool-server.com/sync.php',\n     *         credentials : 'include'\n     *     },\n     *     ...\n     * }\n     * ```\n     * @property {Object} [transport.sync.requestConfig] **DEPRECATED:** The config options can be defined on the upper\n     * configuration level.\n     * @category CRUD\n     */\n\n    static get defaultMethod() {\n        return {\n            load : 'GET',\n            sync : 'POST'\n        };\n    }\n\n    /**\n     * Cancels a sent request.\n     * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.\n     * The _requestPromise_ is the value returned from the corresponding {@link #function-sendRequest} call.\n     * @category CRUD\n     */\n    cancelRequest(requestPromise, reject) {\n        requestPromise.abort?.();\n        // TODO fix this\n        if (!this.isDestroying) {\n            reject({ cancelled : true });\n        }\n    }\n\n    shouldUseBodyForRequestData(packCfg, method, paramName) {\n        return !(method === 'HEAD' || method === 'GET') && !paramName;\n    }\n\n    /**\n     * Sends a _Crud Manager_ request to the server.\n     * @param {Object} request The request configuration object having following properties:\n     * @param {'load'|'sync'} request.type The request type. Either `load` or `sync`.\n     * @param {String} request.url The URL for the request. Overrides the URL defined in the `transport` object\n     * @param {String} request.data The encoded _Crud Manager_ request data.\n     * @param {Object} request.params An object specifying extra HTTP params to send with the request.\n     * @param {Function} request.success A function to be started on successful request transferring.\n     * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n     * @param {Function} request.failure A function to be started on request transfer failure.\n     * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).\n     * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.\n     * @returns {Promise} The fetch Promise object.\n     * @fires beforeSend\n     * @async\n     * @category CRUD\n     */\n    sendRequest(request) {\n        const\n            me              = this,\n            { data }        = request,\n            transportConfig = me.transport[request.type] || {},\n            // clone parameters defined for this type of request\n            requestConfig   = Objects.assign({}, transportConfig, transportConfig.requestConfig);\n\n        if (request.url) {\n            requestConfig.url = request.url;\n        }\n\n        requestConfig.method = requestConfig.method || AjaxTransport.defaultMethod[request.type];\n        requestConfig.params = Objects.assign(requestConfig.params || {}, request.params);\n\n        let { paramName } = requestConfig;\n\n        // transfer package in the request body for some types of HTTP requests\n        if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {\n            requestConfig.body = data;\n\n            // for requests having body we set Content-Type to 'application/json' by default\n            requestConfig.headers = requestConfig.headers || {};\n            requestConfig.headers['Content-Type'] = requestConfig.headers['Content-Type'] || 'application/json';\n        }\n        else {\n            // when we don't use body paramName is mandatory so fallback to 'data' as name\n            paramName = paramName || 'data';\n\n            requestConfig.params[paramName] = data;\n        }\n\n        if (!requestConfig.url) {\n            throw new Error('Trying to request without URL specified');\n        }\n\n        // sanitize request config\n        delete requestConfig.requestConfig;\n        delete requestConfig.paramName;\n\n        let ajaxPromise, resultPromise;\n\n        function performSend() {\n            // AjaxHelper.fetch call it \"queryParams\"\n            requestConfig.queryParams = requestConfig.params;\n\n            delete requestConfig.params;\n\n            let cancelled = false;\n\n            const fetchOptions = Objects.assign({}, requestConfig, requestConfig.fetchOptions);\n\n            ajaxPromise  = AjaxHelper.fetch(requestConfig.url, fetchOptions);\n\n            return ajaxPromise.catch(error => {\n                ajaxPromise.done = true;\n\n                me.trigger?.('responseReceived', { success : false });\n\n                const signal = fetchOptions.abortController?.signal;\n\n                if (signal) {\n                    cancelled = signal.aborted;\n\n                    if (!cancelled) {\n                        console.warn(error);\n                    }\n                }\n\n                return { error, cancelled };\n            }).then(response => {\n                ajaxPromise.done = true;\n\n                me.trigger?.('responseReceived', { success : Boolean(response?.ok) });\n\n                const callback = response?.ok ? request.success : request.failure;\n\n                return callback?.call(request.thisObj || me, response, fetchOptions, request);\n            });\n        }\n\n        /**\n         * Fires before a request is sent to the server.\n         *\n         * ```javascript\n         * crudManager.on('beforeSend', function ({ params, type }) {\n         *     // let's set \"sync\" request parameters\n         *     if (type == 'sync') {\n         *         // dynamically depending on \"flag\" value\n         *         if (flag) {\n         *             params.foo = 'bar';\n         *         }\n         *         else {\n         *             params.foo = 'smth';\n         *         }\n         *     }\n         * });\n         * ```\n         * @event beforeSend\n         * @param {Scheduler.crud.AbstractCrudManager} crudManager The CRUD manager.\n         * @param {Object} params HTTP request params to be passed in the request URL.\n         * @param {'sync'|'load'} type CrudManager request type (`load`/`sync`)\n         * @param {Object} requestConfig Configuration object for Ajax request call\n         * @async\n         */\n        const beforeSendResult = me.trigger('beforeSend', {\n            params : requestConfig.params,\n            type   : request.type,\n            requestConfig,\n            config : request\n        });\n\n        if (Objects.isPromise(beforeSendResult)) {\n            resultPromise = beforeSendResult.then(performSend);\n        }\n        else {\n            resultPromise = performSend();\n        }\n\n        resultPromise.abort = () => {\n            if (!ajaxPromise.done) {\n                ajaxPromise.abort?.();\n            }\n        };\n\n        return resultPromise;\n    }\n};\n","import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/crud/encoder/JsonEncoder\n */\n\n/**\n * Implements data encoding functional that should be mixed to a {@link Scheduler.crud.AbstractCrudManager} sub-class.\n * Uses _JSON_ as an encoding system.\n *\n * @example\n * // create a new CrudManager using AJAX as a transport system and JSON for encoding\n * class MyCrudManager extends JsonEncode(AjaxTransport(AbstractCrudManager)) {}\n *\n * @mixin\n */\nexport default Target => class JsonEncoder extends (Target || Base) {\n    static get $name() {\n        return 'JsonEncoder';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Configuration of the JSON encoder used by the _Crud Manager_.\n             *\n             * @config {Object}\n             * @property {Object} encoder.requestData Static data to send with the data request.\n             *\n             * ```js\n             * new CrudManager({\n             *     // add static \"foo\" property to all requests data\n             *     encoder : {\n             *         requestData : {\n             *             foo : 'Bar'\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * The above snippet will result adding \"foo\" property to all requests data:\n             *\n             * ```json\n             *     {\n             *         \"requestId\"   : 756,\n             *         \"type\"        : \"load\",\n             *\n             *         \"foo\"         : \"Bar\",\n             *\n             *         \"stores\"      : [\n             *             ...\n             * ```\n             * @category CRUD\n             */\n            encoder : {}\n        };\n    }\n\n    /**\n     * Encodes a request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.\n     * Supposed to be overridden in case data provided by the _Crud Manager_ has to be transformed into format requested by server.\n     * @param {Object} requestData The request to encode.\n     * @returns {String} The encoded request.\n     * @category CRUD\n     */\n    encode(requestData) {\n        requestData = Object.assign({}, this.encoder?.requestData, requestData);\n\n        return StringHelper.safeJsonStringify(requestData);\n    }\n\n    /**\n     * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.\n     * Supposed to be overridden in case data provided by server has to be transformed into format requested by the _Crud Manager_.\n     * @param {String} responseText The response text to decode.\n     * @returns {Object} The decoded response.\n     * @category CRUD\n     */\n    decode(responseText) {\n        return StringHelper.safeJsonParse(responseText);\n    }\n};\n","/**\n * @module Scheduler/crud/mixin/CrudManagerView\n */\n\nimport LoadMaskable from '../../../Core/mixin/LoadMaskable.js';\nimport Mask from '../../../Core/widget/Mask.js';\n\n/**\n * Mixin to track Crud Manager requests to the server and mask the view during them. For masking it\n * uses the {@link Core.mixin.LoadMaskable#config-loadMask} and {@link Core.mixin.LoadMaskable#config-syncMask}\n * properties.\n *\n * @mixin\n * @extends Core/mixin/LoadMaskable\n */\nexport default Target => class CrudManagerView extends Target.mixin(LoadMaskable) {\n    static get $name() {\n        return 'CrudManagerView';\n    }\n\n    static config = {\n        clearMaskDelay : null,\n\n        // Test environment may be in a poll wait for mask to disappear.\n        // Hiding the mask immediately, before the load sequence ends releases it too early\n        testConfig : {\n            clearMaskDelay : 0\n        }\n    };\n\n    //region Init\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        const { crudManager, project } = this;\n\n        if (this.loadMask && (crudManager || project).isCrudManagerLoading) {\n            // Show loadMask if crud manager is already loading\n            this.onCrudManagerLoadStart();\n        }\n    }\n\n    //endregion\n\n    /**\n     * Applies the {@link Scheduler.crud.mixin.CrudManagerView#config-syncMask} as the\n     * {@link Core.widget.Widget#config-masked mask} for this widget.\n     * @internal\n     */\n    applySyncMask() {\n        const { syncMask } = this;\n\n        if (syncMask) {\n            this.masked = Mask.mergeConfigs(this.loadMaskDefaults, syncMask);\n        }\n    }\n\n    /**\n     * Hooks up crud manager listeners\n     * @private\n     * @category Store\n     */\n    bindCrudManager(crudManager) {\n        this.detachListeners('crudManager');\n\n        crudManager?.ion({\n            name             : 'crudManager',\n            loadStart        : 'onCrudManagerLoadStart',\n            load             : 'onCrudManagerLoad',\n            loadCanceled     : 'onCrudManagerLoadCanceled',\n            syncStart        : 'onCrudManagerSyncStart',\n            sync             : 'onCrudManagerSync',\n            syncCanceled     : 'onCrudManagerSyncCanceled',\n            requestFail      : 'onCrudManagerRequestFail',\n            responseReceived : 'onAjaxTransportResponseReceived',\n            thisObj          : this\n        });\n    }\n\n    onCrudManagerLoadStart() {\n        // Show loadMask before crud manager starts loading\n        this.applyLoadMask();\n        this.toggleEmptyText?.();\n    }\n\n    onCrudManagerSyncStart() {\n        this.applySyncMask();\n    }\n\n    onCrudManagerRequestFinalize(successful = true, requestType, response) {\n        const\n            me = this;\n\n        if (successful) {\n            me.toggleEmptyText?.();\n        }\n        else {\n            if (!me.masked) {\n                me.applyLoadMask();\n            }\n            // Do not remove. Assertion strings for Localization sanity check.\n            // 'L{GridBase.loadFailedMessage}'\n            // 'L{GridBase.syncFailedMessage}'\n\n            me.applyMaskError(\n                `<div class=\"b-grid-load-failure\">\n                    <div class=\"b-grid-load-fail\">${me.L(`L{GridBase.${requestType}FailedMessage}`)}</div>\n                    ${response && response.message ? `<div class=\"b-grid-load-fail\">${me.L('L{CrudManagerView.serverResponseLabel}')} ${response.message}</div>` : ''}\n                </div>`);\n        }\n    }\n\n    onCrudManagerLoadCanceled() {\n        this.onCrudManagerRequestFinalize(true, 'load');\n    }\n\n    onCrudManagerSyncCanceled() {\n        this.onCrudManagerRequestFinalize(true, 'sync');\n    }\n\n    onCrudManagerLoad() {\n        this.onCrudManagerRequestFinalize(true, 'load');\n    }\n\n    onCrudManagerSync() {\n        this.onCrudManagerRequestFinalize(true, 'sync');\n\n        // Repaint rows to have \"b-sch-dirty\" class up-to-date on the event elements.\n        // Needed when no new changes come from server, and there is nothing to apply back to the records.\n        // TODO: when https://github.com/bryntum/support/issues/2720 is done, we can refresh specific rows (note, Calendar has many views)\n        this.refresh();\n    }\n\n    onCrudManagerRequestFail({ requestType, response }) {\n        this.onCrudManagerRequestFinalize(false, requestType, response);\n    }\n\n    onAjaxTransportResponseReceived() {\n        const me = this;\n        if (me.clearMaskDelay != null) {\n            me.setTimeout(() => me.masked = null, me.clearMaskDelay);\n        }\n        else {\n            me.masked = null;\n        }\n    }\n\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/data/mixin/PartOfProject\n */\n\n/**\n * This is a mixin, included in all models and stores of the Scheduler project. It provides a common API for accessing\n * all stores of the project.\n *\n * @mixin\n */\nexport default Target => class PartOfProject extends (Target || Base) {\n\n    /**\n     * Returns the project this entity belongs to.\n     *\n     * @member {Scheduler.model.ProjectModel} project\n     * @readonly\n     * @category Project\n     */\n\n    /**\n     * Returns the event store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.EventStore} eventStore\n     * @readonly\n     * @category Project\n     */\n\n    /**\n     * Returns the dependency store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @readonly\n     * @category Project\n     */\n\n    /**\n     * Returns the assignment store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @readonly\n     * @category Project\n     */\n\n    /**\n     * Returns the resource store of the project this entity belongs to.\n     *\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @readonly\n     * @category Project\n     */\n\n    static get $name() {\n        return 'PartOfProject';\n    }\n};\n","/**\n * @module Scheduler/model/mixin/AssignmentModelMixin\n */\n\n/**\n * Mixin that holds configuration shared between assignments in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class AssignmentModelMixin extends Target {\n    static get $name() {\n        return 'AssignmentModelMixin';\n    }\n\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * ```javascript\n     * assignment.set('resourceId', 2);\n     * // assignment.resource is not yet resolved\n     *\n     * await assignment.setAsync('resourceId', 2);\n     * // assignment.resource is resolved\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n\n    //region Fields\n\n    static get fields() {\n        return [\n            /**\n             * Id for the resource to assign to\n             * @field {String|Number} resourceId\n             * @category Common\n             */\n            'resourceId',\n\n            /**\n             * Id for the event to assign\n             * @field {String|Number} eventId\n             * @category Common\n             */\n            'eventId',\n\n            /**\n             * Specify `false` to opt out of drawing dependencies from/to this assignment\n             * @field {Boolean} drawDependencies\n             * @category Common\n             */\n            { name : 'drawDependencies', type : 'boolean' },\n\n            'event',\n\n            'resource'\n        ];\n    }\n\n    //endregion\n\n    construct(data, ...args) {\n        data = data || {};\n\n        const\n            eventId    = data[this.fieldMap.eventId.dataSource],\n            resourceId = data[this.fieldMap.resourceId.dataSource];\n\n        // Engine expects event and resource, not eventId and resourceId. We need to support both\n        if (eventId != null) {\n            data.event = eventId;\n        }\n\n        if (resourceId != null) {\n            data.resource = resourceId;\n        }\n\n        super.construct(data, ...args);\n    }\n\n    //region Event & resource\n\n    /**\n     * A key made up from the event id and the id of the resource assigned to.\n     * @property eventResourceKey\n     * @readonly\n     * @internal\n     */\n    get eventResourceKey() {\n        return this.buildEventResourceKey(this.event, this.resource);\n    }\n\n    buildEventResourceKey(event, resource) {\n        let eventKey, resourceKey;\n\n        if (event) {\n            eventKey = event.isModel ? event.id : event;\n        }\n        else {\n            eventKey = this.internalId;\n        }\n\n        if (resource) {\n            resourceKey = resource.isModel ? resource.id : resource;\n        }\n        else {\n            resourceKey = this.internalId;\n        }\n        return `${eventKey}-${resourceKey}`;\n    }\n\n    buildIndexKey({ event, resource }) {\n        return this.buildEventResourceKey(event, resource);\n    }\n\n    set(field, value, ...args) {\n        const toSet = this.fieldToKeys(field, value);\n\n        // If resource was set, store its id as resourceId and announce it\n        if ('resource' in toSet) {\n            if (toSet.resource?.id) {\n                toSet.resourceId = toSet.resource.id;\n            }\n        }\n        // If resourceId was set, we need to replace resource to have it re-referenced in engine\n        else if ('resourceId' in toSet && this.constructor.isProAssignmentModel) {\n            toSet.resource = toSet.resourceId;\n        }\n\n        // Same for event\n        if ('event' in toSet) {\n            if (toSet.event?.id) {\n                toSet.eventId = toSet.event.id;\n            }\n        }\n        else if ('eventId' in toSet && this.constructor.isProAssignmentModel) {\n            toSet.event = toSet.eventId;\n        }\n\n        return super.set(toSet, null, ...args);\n    }\n\n    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {\n        const me = this;\n\n        // Make sure Core Engine implementation notices \"resourceId\" change\n        // and updates \"resource\" field value respectively\n        if (!me.constructor.isProAssignmentModel && wasSet?.resourceId &&\n            me.resource?.id !== wasSet.resourceId.value) {\n            me.resource = wasSet.resourceId.value;\n        }\n        // If that's non-Core Engine and we have \"eventId\" indicated as just set\n        // and there was also \"event\" passed to set but it was not set\n        // and if that happens when propagating after sync-response applied\n        // - this means an event has changed its identifier\n        // (this fixes 11_backend.t.js in the Gantt)\n        else if (me.constructor.isProAssignmentModel && me.project?.propagatingSyncChanges &&\n            wasSet?.eventId && !wasSet?.event &&\n            (toSet.event.value === wasSet.eventId.value || toSet.event.value.id === wasSet.eventId.value)\n        ) {\n            // sanitize both wasSet and meta.modified\n            delete wasSet.eventId;\n            delete me.meta.modified.eventId;\n        }\n\n        return super.afterChange(...arguments);\n    }\n\n    // Settings resourceId relays to `resource`. Underlying data will be updated in `afterChange()` above\n    set resourceId(value) {\n        const { resource } = this;\n\n        // When assigning a new id to a resource, it will update the resourceId of the assignment. But the assignments\n        // resource is still the same so we need to announce here\n        if (resource?.isModel && resource.id === value) {\n            this.set('resourceId', value);\n        }\n        else {\n            this.resource = value;\n        }\n    }\n\n    get resourceId() {\n        // If assigned using `resource` and not `resourceId` there will be no resourceId\n        return this.get('resourceId') || this.resource?.id;\n    }\n\n    // Same for event as for resourceId\n    set eventId(value) {\n        const { event } = this;\n\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (event?.isModel && event.id === value) {\n            this.set('eventId', value);\n        }\n        else {\n            this.event = value;\n        }\n    }\n\n    get eventId() {\n        // If assigned using `event` and not `eventId` there will be no eventId\n        return this.get('eventId') || this.event?.id;\n    }\n\n    /**\n     * Convenience property to get the name of the associated event.\n     * @property {String}\n     * @readonly\n     */\n    get eventName() {\n        return this.event?.name;\n    }\n\n    /**\n     * Convenience property to get the name of the associated resource.\n     * @property {String}\n     * @readonly\n     */\n    get resourceName() {\n        return this.resource?.name;\n    }\n\n    // TODO : Deprecate in favor of `get resource`\n    /**\n     * Returns the resource associated with this assignment.\n     *\n     * @returns {Scheduler.model.ResourceModel} Instance of resource\n     */\n    getResource() {\n        return this.resource;\n    }\n\n    //endregion\n\n    // Convenience getter to not have to check `instanceof AssignmentModel`\n    get isAssignment() {\n        return true;\n    }\n\n    /**\n     * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')\n     *\n     * @property {Boolean}\n     */\n    get isPersistable() {\n        const\n            {\n                event,\n                resource,\n                unjoinedStores,\n                assignmentStore\n            }           = this,\n            crudManager = assignmentStore?.crudManager;\n\n        let result;\n\n        if (assignmentStore) {\n            // If the owning event is not persistable, this assignment is also not persistable.\n            // if crud manager is used it can deal with phantom event/resource since it persists all records in one batch\n            // if no crud manager used we have to wait till event/resource are persisted\n            result = this.isValid && event.isPersistable && (crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);\n        }\n        // if we remove the record\n        else {\n            result = !this.isPhantom && Boolean(unjoinedStores[0]);\n        }\n\n        // Records not yet fully created cannot be persisted\n        return result && super.isPersistable && !this.event?.isCreating;\n    }\n\n    get isValid() {\n        return this.resource != null && this.event != null;\n    }\n\n    /**\n     * Returns a textual representation of this assignment (e.g. Mike 50%).\n     * @returns {String}\n     */\n    toString() {\n        if (this.resourceName) {\n            return `${this.resourceName} ${Math.round(this.units)}%`;\n        }\n\n        return '';\n    }\n\n    //region STM hooks\n\n    shouldRecordFieldChange(fieldName, oldValue, newValue) {\n        if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n            return false;\n        }\n\n        if (fieldName === 'event' || fieldName === 'eventId') {\n            const eventStore = this.project?.eventStore;\n\n            if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {\n                return false;\n            }\n        }\n\n        if (fieldName === 'resource' || fieldName === 'resourceId') {\n            const resourceStore = this.project?.resourceStore;\n\n            if (resourceStore && resourceStore.oldIdMap[oldValue] === resourceStore.getById(newValue)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    //endregion\n};\n","import Model from '../../Core/data/Model.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport AssignmentModelMixin from './mixin/AssignmentModelMixin.js';\n/* <remove-on-release> */\nimport { BaseAssignmentMixin } from '../../Engine/quark/model/scheduler_basic/BaseAssignmentMixin.js';\n/* </remove-on-release> */\nimport { CoreAssignmentMixin } from '../../Engine/quark/model/scheduler_core/CoreAssignmentMixin.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? BaseAssignmentMixin : /* </remove-on-release> */CoreAssignmentMixin;\n\n/**\n * @module Scheduler/model/AssignmentModel\n */\n\n/**\n * This model represents a single assignment of a resource to an event in the scheduler, usually added to a\n * {@link Scheduler.data.AssignmentStore}.\n *\n * It is a subclass of the {@link Core.data.Model} class. Please refer to the documentation for that class to become\n * familiar with the base interface of this class.\n *\n * ## Fields and references\n *\n * An Assignment has the following fields:\n * - `id` - The id of the assignment\n * - `resourceId` - The id of the resource assigned (optionally replaced with `resource` for load)\n * - `eventId` - The id of the event to which the resource is assigned (optionally replaced with `event` for load)\n *\n * The data source for these fields can be customized by subclassing this class:\n *\n * ```javascript\n * class MyAssignment extends AssignmentModel {\n *   static get fields() {\n *       return [\n *          { name : 'resourceId', dataSource : 'linkedResource' }\n *       ];\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `event` - The linked event record\n * - `resource` - The linked resource record\n *\n * ## Async resolving of references\n *\n * As described above, an assignment links an event to a resource. It holds references to an event record and a resource\n * record. These references are populated async, using the calculation engine of the project that the assignment via\n * its store is a part of. Because of this asyncness, references cannot be used immediately after modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // assignment.resource is not yet available\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // assignment.resource is available\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // assignment.resource is available\n * ```\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/AssignmentModelMixin\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class AssignmentModel extends AssignmentModelMixin(PartOfProject(EngineMixin.derive(Model))) {\n    // NOTE: Leave field defs at top to be picked up by jsdoc\n\n    /**\n     * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after\n     * load it will be populated with the actual event and not its id. This field is not persistable.\n     * @field {Scheduler.model.EventModel} event\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Common\n     */\n\n    /**\n     * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after\n     * load it will be populated with the actual resource and not its id. This field is not persistable.\n     * @field {Scheduler.model.ResourceModel} resource\n     * @accepts {String|Number|Scheduler.model.ResourceModel}\n     * @category Common\n     */\n\n    static get $name() {\n        return 'AssignmentModel';\n    }\n\n    get resource() {\n        return super.resource;\n    }\n\n    set resource(resource) {\n        super.resource  = resource;\n\n        this.setChanged('resourceId', this.constructor.asId(resource));\n    }\n}\n\nAssignmentModel.exposeProperties();\n","import Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Scheduler/data/mixin/AssignmentStoreMixin\n */\n\n/**\n * This is a mixin, containing functionality related to managing assignments.\n *\n * It is consumed by the regular {@link Scheduler.data.AssignmentStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class AssignmentStoreMixin extends Target {\n    static get $name() {\n        return 'AssignmentStoreMixin';\n    }\n\n    /**\n     * Add assignments to the store.\n     *\n     * NOTE: References (event, resource) on the assignments are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [assignment] = assignmentStore.add({ eventId, resourceId });\n     * // assignment.event is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [assignment] = assignmentStore.add({ eventId, resourceId });\n     * await assignmentStore.project.commitAsync();\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.AssignmentModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n\n    /**\n     * Add assignments to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added assignments.\n     *\n     * ```javascript\n     * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });\n     * // assignment.event is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.AssignmentModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n\n    /**\n     * Applies a new dataset to the AssignmentStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (assignments, resources) on the assignments are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * assignmentStore.data = [{ eventId, resourceId }];\n     * // assignmentStore.first.event is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * assignmentStore.data = [{ eventId, resourceId  }];\n     * await assignmentStore.project.commitAsync();\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * @member {AssignmentModelConfig[]} data\n     * @category Records\n     */\n\n    /**\n     * Applies a new dataset to the AssignmentStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);\n     * // assignmentStore.first.event is available\n     * ```\n     *\n     * @param {AssignmentModelConfig[]} data Array of AssignmentModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 300,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 300,\n\n            storeId : 'assignments'\n        };\n    }\n\n    add(newAssignments, ...args) {\n        newAssignments = ArrayHelper.asArray(newAssignments);\n\n        for (let i = 0; i < newAssignments.length; i++) {\n            let assignment = newAssignments[i];\n\n            if (!(assignment instanceof Model)) {\n                newAssignments[i] = assignment = this.createRecord(assignment);\n            }\n            if (!this.isSyncingDataOnLoad && this.storage.findIndex('eventResourceKey', assignment.eventResourceKey, true) !== -1) {\n                throw new Error(`Duplicate assignment Event: ${assignment.eventId} to resource: ${assignment.resourceId}`);\n            }\n            if (assignment.event?.isCreating) {\n                assignment.isCreating = true;\n            }\n        }\n        return super.add(newAssignments, ...args);\n    }\n\n    includesAssignment(eventId, resourceId) {\n        return this.storage.findIndex('eventResourceKey', `${eventId}-${resourceId}`, true) !== -1;\n    }\n\n    setStoreData(data) {\n        //<debug>\n        if (this.usesSingleAssignment) {\n            throw new Error('Data loading into AssignmentStore (multi-assignment mode) cannot be combined EventStore data containing resourceId (single-assignment mode)');\n        }\n        //</debug>\n\n        super.setStoreData(data);\n    }\n\n    //region Init & destroy\n\n    // This index fixes poor performance when you add large number of events to an event store with large number of\n    // events - if cache is missing existing records are iterated n² times.\n    // https://github.com/bryntum/support/issues/3154#issuecomment-881336588\n\n    set storage(storage) {\n        super.storage = storage;\n\n        // This allows a map based, fast lookup of assignments by their eventResourceKey.\n        // This is so that the test for duplicate assignment adding is fast.\n        this.storage.addIndex({ property : 'eventResourceKey', dependentOn : { event : true, resource : true } });\n    }\n\n    get storage() {\n        // Micro optimization to avoid expensive super call\n        return this._storage || super.storage;\n    }\n\n    //endregion\n\n    //region Stores\n\n    // To not have to do instanceof checks\n    get isAssignmentStore() {\n        return true;\n    }\n\n    //endregion\n\n    //region Recurrence\n\n    /**\n     * Returns a \"fake\" assignment used to identify a certain occurrence of a recurring event.\n     * If passed the original event, it returns `originalAssignment`.\n     * @param {Scheduler.model.AssignmentModel} originalAssignment\n     * @param {Scheduler.model.EventModel} occurrence\n     * @returns {Object} Temporary assignment\n     * @internal\n     */\n    getOccurrence(originalAssignment, occurrence) {\n        // Pass along the original assignment for non occurrence related calls\n        if (!originalAssignment || !occurrence?.isOccurrence) {\n            return originalAssignment;\n        }\n\n        // Not for saving chars, needed in fn below\n        const me = this;\n\n        return {\n            id                     : `${occurrence.id}:a${originalAssignment.id}`,\n            event                  : occurrence,\n            resource               : originalAssignment.resource,\n            eventId                : occurrence.id,\n            resourceId             : originalAssignment.resource.id,\n            isAssignment           : true,\n            // This field is required to distinguish this fake assignment when event is being removed from UI\n            isOccurrenceAssignment : true,\n            // Not being an actual record, instanceMeta is stored on the store instead\n            instanceMeta(instanceOrId) {\n                return me.occurrenceInstanceMeta(this, instanceOrId);\n            }\n        };\n    }\n\n    // Per fake assignment instance meta, stored on store since fakes are always generated on demand\n    occurrenceInstanceMeta(occurrenceAssignment, instanceOrId) {\n        const\n            me         = this,\n            instanceId = instanceOrId.id || instanceOrId,\n            { id }     = occurrenceAssignment;\n\n        let { occurrenceMeta } = me;\n\n        if (!occurrenceMeta) {\n            occurrenceMeta = me.occurrenceMeta = {};\n        }\n\n        if (!occurrenceMeta[id]) {\n            occurrenceMeta[id] = {};\n        }\n\n        return occurrenceMeta[id][instanceId] || (occurrenceMeta[id][instanceId] = {});\n    }\n\n    //endregion\n\n    //region Mapping\n\n    /**\n     * Maps over event assignments.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @param {Function} [fn]\n     * @param {Function} [filterFn]\n     * @returns {Scheduler.model.EventModel[]|Array}\n     * @category Assignments\n     */\n    mapAssignmentsForEvent(event, fn, filterFn) {\n        event = this.eventStore.getById(event);\n\n        const\n            fnSet           = Boolean(fn),\n            filterFnSet     = Boolean(filterFn);\n\n        if (fnSet || filterFnSet) {\n            return event.assignments.reduce((result, assignment) => {\n                const mapResult = fnSet ? fn(assignment) : assignment;\n\n                if (!filterFnSet || filterFn(mapResult)) {\n                    result.push(mapResult);\n                }\n\n                return result;\n            }, []);\n        }\n\n        return event.assignments;\n    }\n\n    /**\n     * Maps over resource assignments.\n     *\n     * @param {Scheduler.model.ResourceModel|Number|String} resource\n     * @param {Function} [fn]\n     * @param {Function} [filterFn]\n     * @returns {Scheduler.model.ResourceModel[]|Array}\n     * @category Assignments\n     */\n    mapAssignmentsForResource(resource, fn, filterFn) {\n        resource = this.resourceStore.getById(resource);\n\n        const\n            fnSet           = Boolean(fn),\n            filterFnSet     = Boolean(filterFn);\n\n        if (fnSet || filterFnSet) {\n            return resource.assignments.reduce((result, assignment) => {\n                const mapResult = fnSet ? fn(assignment) : assignment;\n\n                if (!filterFnSet || filterFn(mapResult)) {\n                    result.push(mapResult);\n                }\n\n                return result;\n            }, []);\n        }\n\n        return resource.assignments;\n    }\n\n    /**\n     * Returns all assignments for a given event.\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignments\n     */\n    getAssignmentsForEvent(event) {\n        return event.assignments;\n    }\n\n    /**\n     * Removes all assignments for given event\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @category Assignments\n     */\n    removeAssignmentsForEvent(event) {\n        return this.remove(event.assignments);\n    }\n\n    /**\n     * Returns all assignments for a given resource.\n     *\n     * @param {Scheduler.model.ResourceModel} resource\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignments\n     */\n    getAssignmentsForResource(resource) {\n        resource = this.resourceStore.getById(resource);\n        return resource.assignments;\n    }\n\n    /**\n     * Removes all assignments for given resource\n     *\n     * @param {Scheduler.model.ResourceModel|*} resource\n     * @category Assignments\n     */\n    removeAssignmentsForResource(resource) {\n        this.remove(this.getAssignmentsForResource(resource));\n    }\n\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Scheduler.model.ResourceModel[]}\n     * @category Assignments\n     */\n    getResourcesForEvent(event) {\n        return event.resources;\n    }\n\n    /**\n     * Returns all events assigned to a resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Scheduler.model.TimeSpan[]}\n     * @category Assignments\n     */\n    getEventsForResource(resource) {\n        resource = this.resourceStore.getById(resource);\n\n        return resource?.events;\n    }\n\n    /**\n     * Creates and adds assignment record(s) for a given event and resource(s).\n     *\n     * @param {Scheduler.model.TimeSpan} event\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resources The resource(s) to assign to the event\n     * @param {Function} [assignmentSetupFn] A hook function which takes an assignment as its argument and must return an assignment.\n     * @param {Boolean} [removeExistingAssignments] `true` to remove assignments for other resources\n     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)\n     * @category Assign\n     */\n    assignEventToResource(event, resources, assignmentSetupFn = null, removeExistingAssignments = false) {\n        const\n            me       = this,\n            toRemove = removeExistingAssignments ? new Set(event.assignments) : null;\n\n        resources = ArrayHelper.asArray(resources).map(r => r.$original ?? r);\n\n        if (me.eventStore?.usesSingleAssignment) {\n            // Use same code path as other single assignments if already assigned\n            if (event.assignments?.length) {\n                if (!me.isEventAssignedToResource(event, resources[0])) {\n                    event.resource = resources[0];\n                }\n                return [];\n            }\n            // otherwise - set \"resourceId\" and proceed to assignment creation\n            else {\n                event.resourceId = resources[0].id;\n            }\n        }\n\n        let newAssignments = [];\n\n        me.suspendAutoCommit();\n\n        // Assign\n        resources.forEach(resource => {\n            const existingAssignment = me.getAssignmentForEventAndResource(event, resource);\n            if (!existingAssignment) {\n                const assignment = {\n                    event,\n                    resource\n                };\n\n                newAssignments.push(assignmentSetupFn?.(assignment) ?? assignment);\n            }\n            else if (removeExistingAssignments) {\n                toRemove.delete(existingAssignment);\n            }\n        });\n\n        newAssignments = me.add(newAssignments);\n\n        if (removeExistingAssignments) {\n            me.remove(Array.from(toRemove));\n        }\n\n        // If true, will trigger a commit\n        me.resumeAutoCommit();\n\n        return newAssignments;\n    }\n\n    /**\n     * Removes assignment record for a given event and resource.\n     *\n     * @param {Scheduler.model.TimeSpan|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} [resources] The resource to unassign the event from. If omitted, all resources of the events will be unassigned\n     * @returns {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}\n     * @category Assign\n     */\n    unassignEventFromResource(event, resources) {\n        const\n            me = this,\n            assignmentsToRemove = [];\n\n        if (!resources) {\n            return me.removeAssignmentsForEvent(event);\n        }\n\n        resources = ArrayHelper.asArray(resources);\n\n        for (let i = 0; i < resources.length; i++) {\n            if (me.isEventAssignedToResource(event, resources[i])) {\n                assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));\n            }\n        }\n\n        return me.remove(assignmentsToRemove);\n    }\n\n    /**\n     * Checks whether an event is assigned to a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event Event record or id\n     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id\n     * @returns {Boolean}\n     * @category Assignments\n     */\n    isEventAssignedToResource(event, resource) {\n        return Boolean(this.getAssignmentForEventAndResource(event, resource));\n    }\n\n    /**\n     * Returns an assignment record for a given event and resource\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event The event or its id\n     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id\n     * @returns {Scheduler.model.AssignmentModel}\n     * @category Assignments\n     */\n    getAssignmentForEventAndResource(event, resource) {\n        let assignments;\n\n        // Note: In order to not evaluate conditions which do not have to be evaluated each condition is assigned to a\n        // variable within the condition.\n        if (\n            !(event = this.eventStore.getById(event)) ||\n            !(assignments = event.assignments) ||\n            // Also note that resources are looked for in the master store if chained, to handle dragging between\n            // schedulers using chained versions of the same resource store. Needed since assignmentStore is shared and\n            // might point to wrong resourceStore (can only point to one)\n            !(resource = this.resourceStore.$master.getById(resource))\n        ) {\n            return null;\n        }\n\n        return this.getOccurrence(assignments.find(a => a.resource?.$original === resource.$original), event);\n    }\n\n    //endregion\n};\n","import AjaxStore from '../../Core/data/AjaxStore.js';\nimport AssignmentModel from '../model/AssignmentModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\nimport AssignmentStoreMixin from './mixin/AssignmentStoreMixin.js';\n/* <remove-on-release> */\nimport { ChronoAssignmentStoreMixin } from '../../Engine/quark/store/ChronoAssignmentStoreMixin.js';\n/* </remove-on-release> */\nimport { CoreAssignmentStoreMixin } from '../../Engine/quark/store/CoreAssignmentStoreMixin.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? PartOfBaseProject(ChronoAssignmentStoreMixin.derive(AjaxStore)) : /* </remove-on-release> */PartOfProject(CoreAssignmentStoreMixin.derive(AjaxStore));\n\n/**\n * @module Scheduler/data/AssignmentStore\n */\n\n/**\n * A store representing a collection of assignments between events in the {@link Scheduler.data.EventStore} and resources\n * in the {@link Scheduler.data.ResourceStore}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.AssignmentModel}.\n *\n * An AssignmentStore is usually connected to a project, which binds it to other related stores (EventStore,\n * ResourceStore and DependencyStore). The project also handles references (event, resource) to related records for the\n * records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * assignmentStore.data = [{ eventId, resourceId }, ...];\n *\n * // references (event, resource) not resolved yet\n *\n * await assignmentStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await assignmentStore.loadDataAsync([{ eventId, resourceId }, ...]);\n *\n * // references (event, resource) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/AssignmentStoreMixin\n * @mixes Scheduler/data/mixin/PartOfProject\n * @extends Core/data/AjaxStore\n */\nexport default class AssignmentStore extends AssignmentStoreMixin(EngineMixin) {\n\n    static $name = 'AssignmentStore';\n\n    static get defaultConfig() {\n        return {\n            modelClass : AssignmentModel\n        };\n    }\n\n}\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/data/mixin/ResourceStoreMixin\n */\n\n/**\n * This is a mixin for the ResourceStore functionality. It is consumed by the {@link Scheduler.data.ResourceStore}.\n *\n * @mixin\n */\nexport default Target => class ResourceStoreMixin extends (Target || Base) {\n    static get $name() {\n        return 'ResourceStoreMixin';\n    }\n\n    get isResourceStore() {\n        return true;\n    }\n\n    /**\n     * Add resources to the store.\n     *\n     * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [resource] = resourceStore.add({ id });\n     * // resource.events is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [resource] = resourceStore.add({ id });\n     * await resourceStore.project.commitAsync();\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [resource] = await resourceStore.addAsync({ id });\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.ResourceModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n\n    /**\n     * Add resources to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added resources.\n     *\n     * ```javascript\n     * const [resource] = await resourceStore.addAsync({ id });\n     * // resource.events is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.ResourceModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n\n    /**\n     * Applies a new dataset to the ResourceStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * resourceStore.data = [{ id }];\n     * // resourceStore.first.events is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * resourceStore.data = [{ id }];\n     * await resourceStore.project.commitAsync();\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await resourceStore.loadDataAsync([{ id }]);\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * @member {ResourceModelConfig[]} data\n     * @category Records\n     */\n\n    /**\n     * Applies a new dataset to the ResourceStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await resourceStore.loadDataAsync([{ id }]);\n     * // resourceStore.first.events is available\n     * ```\n     *\n     * @param {ResourceModelConfig[]} data Array of ResourceModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 200,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 100,\n            storeId      : 'resources',\n            autoTree     : true\n        };\n    }\n\n    construct(config) {\n        super.construct(config);\n\n        if (!this.modelClass.isResourceModel) {\n            throw new Error('Model for ResourceStore must subclass ResourceModel');\n        }\n    }\n\n    removeAll() {\n        const result = super.removeAll(...arguments);\n\n        // Removing all resources removes all assignments\n        result && this.assignmentStore.removeAll();\n\n        return result;\n    }\n\n    // Apply id changes also to assignments (used to be handled automatically by relations earlier, but engine does not\n    // care about ids so needed now)\n    // problems:\n    // 1. orientation/HorizontalRendering listens to assignment store changes and is trying to refresh view\n    // When we update resource id on assignment, listener will be invoked and view will try to refresh. And it will\n    // fail, because row is not updated yet. Flag is raised on resource store to make HorizontalRendering to skip\n    // refreshing view in this particular case of resource id changing\n    onRecordIdChange({ record, oldValue, value }) {\n        super.onRecordIdChange({ record, oldValue, value });\n\n        if (record.isFieldModified('id')) {\n            this.isChangingId = true;\n\n            record.updateAssignmentResourceIds();\n\n            this.isChangingId = false;\n        }\n    }\n\n    // Cache used by VerticalRendering, reset from there\n    get allResourceRecords() {\n        return this._allResourceRecords || (this._allResourceRecords = this.getAllDataRecords());\n    }\n\n    /**\n     * Returns all resources that have no events assigned during the specified time range.\n     * @param {Date} startDate Time range start date\n     * @param {Date} endDate Time range end date\n     * @returns {Scheduler.model.ResourceModel[]} Resources without events\n     */\n    getAvailableResources({ startDate, endDate }) {\n        return this.query(resource => this.eventStore.isDateRangeAvailable(startDate, endDate, null, resource));\n    }\n};\n","/**\n * @module Scheduler/model/mixin/ResourceModelMixin\n */\n\n/**\n * Mixin that holds configuration shared between resources in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class ResourceModelMixin extends Target {\n    static get $name() {\n        return 'ResourceModelMixin';\n    }\n\n    // Flag checked by ResourceStore to make sure it uses a valid subclass\n    static get isResourceModel() {\n        return true;\n    }\n\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * This does not matter much on the resource itself, but is of importance when manipulating its references:\n     *\n     * ```javascript\n     * assignment.set('resourceId', 2);\n     * // resource.assignments is not yet up to date\n     *\n     * await assignment.setAsync('resourceId', 2);\n     * // resource.assignments is up to date\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n\n    //region Fields\n\n    static get fields() {\n        return [\n            /**\n             * Unique identifier\n             * @field {String|Number} id\n             * @category Common\n             */\n\n            /**\n             * Get or set resource name\n             * @field {String} name\n             * @category Common\n             */\n            { name : 'name', type : 'string', persist : true },\n\n            /**\n             * Controls the primary color used for events assigned to this resource. Can be overridden per event using\n             * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventColor eventColor config}. See Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for available\n             * colors.\n             * @field {String} eventColor\n             * @category Styling\n             */\n            'eventColor',\n\n            /**\n             * Controls the style used for events assigned to this resource. Can be overridden per event using\n             * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventStyle eventStyle config}. See Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for available\n             * options.\n             * @field {String} eventStyle\n             * @category Styling\n             */\n            'eventStyle',\n\n            /**\n             * Fully qualified image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image\n             * for the resource.\n             * @field {String} imageUrl\n             * @category Styling\n             */\n            'imageUrl',\n\n            /**\n             * Image name relative to {@link Scheduler/view/mixin/SchedulerEventRendering#config-resourceImagePath},\n             * used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image\n             * for the resource.\n             * @field {String} image\n             * @category Styling\n             */\n            'image',\n\n            /**\n             * Margin from rows edge to topmost event bar for this resource, in px.\n             * @field {Number} resourceMargin\n             * @category Layout\n             */\n            { name : 'resourceMargin', type : 'number' },\n\n            /**\n             * Margin between stacked event bars for this resource, in px.\n             * @field {Number} barMargin\n             * @category Layout\n             */\n            { name : 'barMargin', type : 'number' },\n\n            /**\n             * Base height of this resource, in px. When unset, Schedulers configured rowHeight is used.\n             *\n             * This value is used in horizontal mode to determine row height. When stacking, it is used as input for\n             * calculating the actual row height:\n             *\n             * ```javascript\n             * row.height = (resource.rowHeight - resourceMargin * 2) * overlap count - barMargin * (overlap count - 1)\n             * ```\n             *\n             * When packing or overlapping, it is used as the actual row height.\n             *\n             * @field {Number} rowHeight\n             * @category Layout\n             */\n\n            /**\n             * Base width of this resource, in px. If not set, the `columnWidth` specified in\n             * the Scheduler's configured {@link Scheduler.view.Scheduler#config-resourceColumns} is used.\n             *\n             * This value is used in vertical mode to determine column width.\n             *\n             * @field {Number} columnWidth\n             * @category Layout\n             */\n\n            /**\n             * Specify this to use a resource specific event layout in horizontal mode, see\n             * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} for options.\n             *\n             * When unset (the default) Schedulers setting is used.\n             *\n             * @field {'stack'|'pack'|'mixed'|'none'} eventLayout\n             * @category Layout\n             */\n            'eventLayout'\n        ];\n    }\n\n    //endregion\n\n    //region Id change\n\n    updateAssignmentResourceIds() {\n        this.assigned.forEach(assignment => {\n            assignment.resourceId = this.id;\n        });\n    }\n\n    syncId(value) {\n        super.syncId(value);\n\n        this.updateAssignmentResourceIds();\n    }\n\n    //endregion\n\n    //region Getters\n\n    /**\n     * Get associated events\n     *\n     * @property {Scheduler.model.EventModel[]}\n     * @readonly\n     */\n    get events() {\n        return this.assignments.reduce((events, assignment) => {\n            if (assignment.event) {\n                events.push(assignment.event);\n            }\n\n            return events;\n        }, []);\n    }\n\n    /**\n     * Returns all assignments for the resource\n     *\n     * @property {Scheduler.model.AssignmentModel[]}\n     */\n    get assignments() {\n        return this.assigned ? [...this.assigned] : [];\n    }\n\n    set assignments(assignments) {\n        // Engine does not allow assigning to `assigned`, handle it here\n        assignments.forEach(assignment => {\n            assignment.resource = this;\n        });\n    }\n\n    /**\n     * Returns an array of events, associated with this resource\n     *\n     * @returns {Scheduler.model.EventModel[]}\n     */\n    getEvents() {\n        // TODO: Deprecate in favor of .events\n        return this.events;\n    }\n\n    /**\n     * Returns true if the Resource can be persisted.\n     * In a flat store, a resource is always considered persistable. In a tree store, a resource is considered\n     * persistable if its parent node is persistable.\n     *\n     * @property {Boolean}\n     * @readonly\n     */\n    get isPersistable() {\n        return super.isPersistable && (!this.parent || this.parent.isPersistable);\n    }\n\n    //endregion\n\n    /**\n     * Unassigns this Resource from all its Events\n     */\n    unassignAll() {\n        this.assignments && this.assignmentStore.remove(this.assignments);\n    }\n\n    /**\n     * Returns the initials (first letter of the first & last space-separated word in the name) or an empty string\n     * if this resource has no name. You can override this method in a ResourceModel subclass to provide your own implementation\n     *\n     * @property {String}\n     * @readonly\n     */\n    get initials() {\n        const\n            { name = '' } = this;\n\n        if (!name) {\n            return '';\n        }\n\n        const names         = name.split(' '),\n            firstInitial  = names[0][0],\n            lastInitial   = (names.length > 1 ? names[names.length - 1][0] : '');\n\n        return firstInitial + lastInitial;\n    }\n\n    isWorkingTime(date) {\n        const calendar = (this.effectiveCalendar || this.project?.calendar);\n\n        return !calendar || calendar.isWorkingTime?.(date);\n    }\n};\n","import GridRowModel from '../../Grid/data/GridRowModel.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\nimport ResourceModelMixin from './mixin/ResourceModelMixin.js';\n/* <remove-on-release> */\nimport { BaseResourceMixin } from '../../Engine/quark/model/scheduler_basic/BaseResourceMixin.js';\n/* </remove-on-release> */\nimport { CoreResourceMixin } from '../../Engine/quark/model/scheduler_core/CoreResourceMixin.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? BaseResourceMixin : /* </remove-on-release> */CoreResourceMixin;\n\n/**\n * @module Scheduler/model/ResourceModel\n */\n\n/**\n * This class represent a single Resource in scheduler, usually added to a {@link Scheduler.data.ResourceStore}.\n *\n * It is a subclass of  {@link Core.data.Model}. Please refer to the documentation for that class to become familiar\n * with the base interface of the resource.\n *\n * ## Fields and references\n *\n * A resource has a few predefined fields, see Fields below. If you want to add more fields with meta data describing\n * your resources then you should subclass this class:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *       // \"id\" and \"name\" fields are already provided by the superclass\n *       { name: 'company', type : 'string' }\n *     ];\n *   }\n * });\n * ```\n *\n * If you want to use other names in your data for the id and name fields you can configure them as seen below:\n *\n * ```javascript\n * class MyResource extends ResourceModel {\n *   static get fields() {\n *     return [\n *        { name: 'name', dataSource: 'userName' }\n *     ];\n *   },\n * });\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `assignments` - The linked assignment records\n * - `events` - The linked (through assignments) event records\n *\n * ## Async resolving of references\n *\n * As described above, a resource has links to assignments and events. These references are populated async, using the\n * calculation engine of the project that the resource via its store is a part of. Because of this asyncness, references\n * cannot be used immediately after assignment modifications:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * // resource.assignments is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * assignment.resourceId = 2;\n * await assignment.project.commitAsync();\n * // resource.assignments is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await assignment.setAsync({ resourceId : 2});\n * // resource.assignments is up to date\n * ```\n *\n * @extends Grid/data/GridRowModel\n * @mixes Scheduler/model/mixin/ResourceModelMixin\n */\nexport default class ResourceModel extends ResourceModelMixin(PartOfProject(EngineMixin.derive(GridRowModel))) {\n    static get $name() {\n        return 'ResourceModel';\n    }\n}\n\nResourceModel.exposeProperties();\n","import ResourceStoreMixin from './mixin/ResourceStoreMixin.js';\nimport ResourceModel from '../model/ResourceModel.js';\nimport AjaxStore from '../../Core/data/AjaxStore.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n/* <remove-on-release> */\nimport { ChronoResourceStoreMixin } from '../../Engine/quark/store/ChronoResourceStoreMixin.js';\n/* </remove-on-release> */\nimport { CoreResourceStoreMixin } from '../../Engine/quark/store/CoreResourceStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? PartOfBaseProject(ChronoResourceStoreMixin.derive(AjaxStore)) : /* </remove-on-release> */PartOfProject(CoreResourceStoreMixin.derive(AjaxStore));\n\n/**\n * @module Scheduler/data/ResourceStore\n */\n\n/**\n * A store holding all the {@link Scheduler.model.ResourceModel resources} to be rendered into a\n * {@link Scheduler.view.Scheduler Scheduler}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.ResourceModel}.\n *\n * A ResourceStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and DependencyStore). The project also handles references (assignments, events) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * resourceStore.data = [{ id }, ...];\n *\n * // references (assignments, events) not resolved yet\n *\n * await resourceStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await resourceStore.loadDataAsync([{ id }, ...]);\n *\n * // references (assignments, events) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/ResourceStoreMixin\n * @extends Core/data/AjaxStore\n */\nexport default class ResourceStore extends ResourceStoreMixin(EngineMixin) {\n\n    static get defaultConfig() {\n        return {\n            modelClass : ResourceModel\n        };\n    }\n\n}\n","import Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport FunctionHelper from '../../../Core/helper/FunctionHelper.js';\n\n/**\n * @module Scheduler/data/mixin/EventStoreMixin\n */\n\n/**\n * This is a mixin, containing functionality related to managing events.\n *\n * It is consumed by the regular {@link Scheduler.data.EventStore} class and the Scheduler Pro's `EventStore` class.\n *\n * @mixin\n */\nexport default Target => class EventStoreMixin extends (Target || Base) {\n    static get $name() {\n        return 'EventStoreMixin';\n    }\n\n    //region Init & destroy\n\n    construct(config) {\n        super.construct(config);\n\n        this.autoTree = true;\n    }\n\n    //endregion\n\n    //region Events records, iteration etc.\n\n    set filtersFunction(filtersFunction) {\n        super.filtersFunction = filtersFunction;\n    }\n\n    get filtersFunction() {\n        // Generate the real filterFn.\n        const result = super.filtersFunction;\n\n        // We always filter *in* records which are being created by the UI.\n        if (result && result !== FunctionHelper.returnTrue) {\n            return r => r.isCreating || result(r);\n        }\n        return result;\n    }\n\n    /**\n     * Returns a `Map`, keyed by `YYYY-MM-DD` date keys containing event counts for all the days\n     * between the passed `startDate` and `endDate`. Occurrences of recurring events are included.\n     *\n     * Example:\n     *\n     * ```javascript\n     *  eventCounts = eventStore.getEventCounts({\n     *      startDate : scheduler.timeAxis.startDate,\n     *      endDate   : scheduler.timeAxis.endDate\n     *  });\n     * ```\n     *\n     * @param {Object} options An options object determining which events to return\n     * @param {Date} options.startDate The start date for the range of events to include.\n     * @param {Date} [options.endDate] The end date for the range of events to include.\n     * @category Events\n     */\n    getEventCounts(options) {\n        const\n            me     = this,\n            {\n                filtersFunction,\n                added\n            }      = me,\n            // Must use getEvents so that the loadDateRange event is triggered.\n            result = me.getEvents({\n                ...options,\n                storeFilterFn : me.isFiltered ? (me.reapplyFilterOnAdd ? filtersFunction : eventRecord => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord)) : null,\n                dateMap       : options.dateMap || true\n            });\n\n        result.forEach((value, key) => result.set(key, value.length));\n        return result;\n    }\n\n    /**\n     * Calls the supplied iterator function once for every scheduled event, providing these arguments\n     * - event : the event record\n     * - startDate : the event start date\n     * - endDate : the event end date\n     *\n     * Returning false cancels the iteration.\n     *\n     * @param {Function} fn iterator function\n     * @param {Object} [thisObj] `this` reference for the function\n     * @category Events\n     */\n    forEachScheduledEvent(fn, thisObj = this) {\n        this.forEach(event => {\n            const { startDate, endDate } = event;\n\n            if (startDate && endDate) {\n                return fn.call(thisObj, event, startDate, endDate);\n            }\n        });\n    }\n\n    /**\n     * Returns an object defining the earliest start date and the latest end date of all the events in the store.\n     *\n     * @returns {Object} An object with 'startDate' and 'endDate' properties (or null values if data is missing).\n     * @category Events\n     */\n    getTotalTimeSpan() {\n        let earliest = new Date(9999, 0, 1),\n            latest   = new Date(0);\n\n        this.forEach(event => {\n            if (event.startDate) {\n                earliest = DateHelper.min(event.startDate, earliest);\n            }\n            if (event.endDate) {\n                latest = DateHelper.max(event.endDate, latest);\n            }\n        });\n\n        // TODO: this will fail in programs designed to work with events in the past (after Jan 1, 1970)\n        earliest = earliest < new Date(9999, 0, 1) ? earliest : null;\n        latest   = latest > new Date(0) ? latest : null;\n\n        // keep last calculated value to be able to track total timespan changes\n        return (this.lastTotalTimeSpan = {\n            startDate : earliest || null,\n            endDate   : latest || earliest || null\n        });\n    }\n\n    /**\n     * Checks if given event record is persistable. By default it always is, override EventModels `isPersistable` if you\n     * need custom logic.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Boolean}\n     * @category Events\n     */\n    isEventPersistable(event) {\n        return event.isPersistable;\n    }\n\n    //endregion\n\n    //region Resource\n\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Resource\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        // NOTE: Also exists in TaskStore.js\n\n        // Cannot assign anything to generated parents\n        if (resource.data.generatedParent) {\n            return false;\n        }\n\n        // This should be a collection of unique event records\n        const allEvents = new Set(this.getEventsForResource(resource));\n\n        // In private mode we can pass an AssignmentModel. In this case, we assume that multi-assignment is used.\n        // So we need to make sure that other resources are available for this time too.\n        // No matter if the event retrieved from the assignment belongs to the target resource or not.\n        // We gather all events from the resources the event is assigned to except of the one from the assignment record.\n        // Note, events from the target resource are added above.\n        if (excludeEvent?.isAssignment) {\n            const\n                currentEvent = excludeEvent.event,\n                resources    = currentEvent.resources;\n\n            resources.forEach(resource => {\n                // Ignore events for the resource which is passed as an AssignmentModel to excludeEvent\n                if (resource.id !== excludeEvent.resourceId) {\n                    this.getEventsForResource(resource).forEach(event => allEvents.add(event));\n                }\n            });\n        }\n\n        if (excludeEvent) {\n            const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;\n            allEvents.delete(eventToRemove);\n        }\n\n        return !Array.from(allEvents).some(event => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));\n    }\n\n    /**\n     * Filters the events associated with a resource, based on the function provided. An array will be returned for those\n     * events where the passed function returns true.\n     * @param {Scheduler.model.ResourceModel} resource\n     * @param {Function} fn The function\n     * @param {Object} [thisObj] `this` reference for the function\n     * @returns {Scheduler.model.EventModel[]} the events in the time span\n     * @private\n     * @category Resource\n     */\n    filterEventsForResource(resource, fn, thisObj = this) {\n        return resource.getEvents(this).filter(fn.bind(thisObj));\n    }\n\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @returns {Scheduler.model.ResourceModel[]}\n     * @category Resource\n     */\n    getResourcesForEvent(event) {\n        // If we are sent an occurrence, use its parent\n        if (event.isOccurrence) {\n            event = event.recurringTimeSpan;\n        }\n\n        return this.assignmentStore.getResourcesForEvent(event);\n    }\n\n    /**\n     * Returns all events assigned to a resource.\n     * *NOTE:* this does not include occurrences of recurring events. Use the\n     * {@link Scheduler/data/mixin/GetEventsMixin#function-getEvents} API to include occurrences of recurring events.\n     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id.\n     * @returns {Scheduler.model.EventModel[]}\n     * @category Resource\n     */\n    getEventsForResource(resource) {\n        return this.assignmentStore.getEventsForResource(resource);\n    }\n\n    //endregion\n\n    //region Assignment\n\n    /**\n     * Returns all assignments for a given event.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignment\n     */\n    getAssignmentsForEvent(event) {\n        return this.assignmentStore.getAssignmentsForEvent(event) || [];\n    }\n\n    /**\n     * Returns all assignments for a given resource.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Scheduler.model.AssignmentModel[]}\n     * @category Assignment\n     */\n    getAssignmentsForResource(resource) {\n        return this.assignmentStore.getAssignmentsForResource(resource) || [];\n    }\n\n    /**\n     * Creates and adds assignment record for a given event and a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource The resource(s) to assign to the event\n     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments\n     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)\n     * @category Assignment\n     */\n    assignEventToResource(event, resource, removeExistingAssignments = false) {\n        return this.assignmentStore.assignEventToResource(event, resource, undefined, removeExistingAssignments);\n    }\n\n    /**\n     * Removes assignment record for a given event and a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @category Assignment\n     */\n    unassignEventFromResource(event, resource) {\n        this.assignmentStore.unassignEventFromResource(event, resource);\n    }\n\n    /**\n     * Reassigns an event from an old resource to a new resource\n     *\n     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from\n     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to\n     * @category Assignment\n     */\n    reassignEventFromResourceToResource(event, oldResource, newResource) {\n        const\n            me            = this,\n            newResourceId = Model.asId(newResource),\n            assignment    = me.assignmentStore.getAssignmentForEventAndResource(event, oldResource);\n\n        if (assignment) {\n            assignment.resourceId = newResourceId;\n        }\n        else {\n            me.assignmentStore.assignEventToResource(event, newResource);\n        }\n\n    }\n\n    /**\n     * Checks whether an event is assigned to a resource.\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @returns {Boolean}\n     * @category Assignment\n     */\n    isEventAssignedToResource(event, resource) {\n        return this.assignmentStore.isEventAssignedToResource(event, resource);\n    }\n\n    /**\n     * Removes all assignments for given event\n     *\n     * @param {Scheduler.model.EventModel|String|Number} event\n     * @category Assignment\n     */\n    removeAssignmentsForEvent(event) {\n        this.assignmentStore.removeAssignmentsForEvent(event);\n    }\n\n    /**\n     * Removes all assignments for given resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource\n     * @category Assignment\n     */\n    removeAssignmentsForResource(resource) {\n        this.assignmentStore.removeAssignmentsForResource(resource);\n    }\n\n    //endregion\n};\n","import DateHelper from '../../../Core/helper/DateHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n\n/**\n * @module Scheduler/data/mixin/GetEventsMixin\n */\n\nconst\n    returnTrue   = () => true,\n    notRecurring = event => !event.isRecurring;\n\n/**\n * Mixing containing functionality for retrieving a range of events, mainly used during rendering.\n *\n * Consumed by EventStore in Calendar, Scheduler & Scheduler Pro and TaskStore in Gantt.\n *\n * @mixin\n */\nexport default Target => class GetEventsMixin extends Target {\n\n    static $name = 'GetEventsMixin';\n\n    /**\n     * Returns an array of events for the date range specified by the `startDate` and `endDate` options.\n     *\n     * By default, for any date, this includes any event which *intersects* that date.\n     *\n     * To only include events that are fully contained *within* the date range, pass the `allowPartial`\n     * option as `false`.\n     *\n     * By default, any occurrences of recurring events are included in the resulting array (not applicable in Gantt). If\n     * that is not required, pass the `includeOccurrences` option as `false`. **Note that if `includeOccurrences` is\n     * `true`, the start date and end date options are mandatory. The method must know what range of occurrences needs\n     * to be generated and returned.**\n     *\n     * Example:\n     *\n     * ```javascript\n     *  visibleEvents = eventStore.getEvents({\n     *      resourceRecord : myResource,\n     *      startDate      : scheduler.timeAxis.startDate,\n     *      endDate        : scheduler.timeAxis.endDate\n     *  });\n     * ```\n     *\n     * @param {Object} options An options object determining which events to return\n     * @param {Date} [options.date] If only one date is required, pass this option instead of the\n     * `startDate` and `endDate` options.\n     * @param {Date} options.startDate The start date for the range of events to include.\n     * @param {Date} [options.endDate] The end date for the range of events to include.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord Pass a resource to only return events assigned to\n     *   this resource. Not supported when using the `dateMap` option (see below)\n     * @param {Function} [options.filter] A function to filter out events which are not required.\n     * @param {Boolean} [options.ignoreFilters] By default, store filters are honoured. Pass this\n     * as `true` to include filtered out events.\n     * @param {Boolean} [options.includeOccurrences=true] Occurrences of recurring events are included by default.\n     * @param {Boolean} [options.allowPartial=true] Events which start before or after the range, but *intersect* the\n     *   range are included by default.\n     * @param {Boolean} [options.startOnly] Pass `true` to only include events which *start on* each date in the range.\n     * @param {Boolean} [options.onlyAssigned] Pass `true` to only include events that are assigned to a resource\n     * @param {Boolean|Map} [options.dateMap] Populates the passed `Map`, or if passed as `true`, creates and\n     * returns a new `Map`. The keys are `YYYY-MM-DD` date strings and the entries are arrays of\n     * {@link Scheduler.model.EventModel EventModel}s.\n     * @returns {Scheduler.model.EventModel[]|Map} Events which match the passed configuration.\n     * @category Events\n     */\n    getEvents({\n        filter,\n        date,\n        startDate,                  // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences,         // Interpolate occurrences into the returned event set\n        allowPartial,               // Include events which *intersect* the date range\n        onlyAssigned = false,       // Only include events that are assigned to a resource\n        dateMap = false,            // Return a Map keyed by date each value being an array of events\n        dayTime = null,\n\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const\n            me                = this,\n            options           = arguments[0],\n            {\n                lastDateRange,\n                added,\n                filtersFunction\n            } = me,\n            passedFilter      = filter;\n\n        // Add filtering for only assigned events if requested.\n        if (onlyAssigned) {\n            options.filter = passedFilter ? e => passedFilter(e) && e.resources.length : e => e.resources.length;\n        }\n\n        // Note that we cannot use defaulting in the argument block because we pass\n        // the incoming options object down into implementations.\n        if (!('startDate' in options)) {\n            startDate = options.startDate = date;\n        }\n        if (!('includeOccurrences' in options)) {\n            includeOccurrences = options.includeOccurrences = true;\n        }\n        if (!('allowPartial' in options)) {\n            allowPartial = options.allowPartial = !startOnly;\n        }\n\n        // We can't use me.filtersFunction if reapplyFilterOnAdd is false because there may be newly\n        // added events which may not be subject to the filter. Records which are still in\n        // the added bag must be tested for presence using indexOf so as to be always in sync\n        // with the store being refiltered. Parens help readability.\n        // Don't use the store's filtering function if we were asked to ignore filters.\n        // eslint-disable-next-line no-extra-parens\n        options.storeFilterFn = me.isFiltered && !options.ignoreFilters ? (me.reapplyFilterOnAdd ? filtersFunction : (eventRecord => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord))) : null;\n\n        // Default to a one day range if only startDate passed\n        if (!endDate) {\n            if (startDate) {\n                endDate = options.endDate = DateHelper.clearTime(startDate);\n                endDate.setDate(endDate.getDate() + 1);\n            }\n            // If no dates passed, the dateFilter will include all.\n            else {\n                // We need to know what occurrences to generate.\n                if (includeOccurrences) {\n                    throw new Error('getEvents MUST be passed startDate and endDate if recurring occurrences are requested');\n                }\n                options.dateFilter = returnTrue;\n            }\n        }\n\n        if (!options.dateFilter) {\n            // Must start in the date range\n            if (startOnly) {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate;\n\n                    return eventStartDate && !(DateHelper.clearTime(eventStartDate) - startDate);\n                };\n            }\n            // Any intersection with our date range\n            else if (allowPartial) {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const\n                        eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate,\n                        eventEndDate   = e.hasBatchedChange('endDate') ? e.get('endDate') : e.endDate || eventStartDate,\n                        isMilestone    = !(eventStartDate - eventEndDate);\n\n                    return eventStartDate && (isMilestone ? DateHelper.betweenLesserEqual(eventStartDate, startDate, endDate) : DateHelper.intersectSpans(eventStartDate, eventEndDate, startDate, endDate));\n                };\n            }\n            // Must be wholly contained with the our range\n            else {\n                options.dateFilter = e => {\n                    // Avoid hitting getter twice. Use batched value if present.\n                    const\n                        eventStartDate = e.hasBatchedChange('startDate') ? e.get('startDate') : e.startDate,\n                        eventEndDate   = e.hasBatchedChange('endDate') ? e.get('endDate') : e.endDate || eventStartDate;\n\n                    return eventStartDate && eventStartDate >= startDate && eventEndDate <= endDate;\n                };\n            }\n        }\n\n        const newDateRange = {\n            startDate,\n            endDate\n        };\n\n        // Ensure the listeners are present\n        me.processConfiguredListeners();\n\n        /**\n         * Fired when a range of events is requested from the {@link #function-getEvents} method.\n         * @event loadDateRange\n         * @param {Scheduler.data.EventStore} source This EventStore\n         * @param {Object} old The old date range\n         * @param {Date} old.startDate the old start date.\n         * @param {Date} old.endDate the old end date.\n         * @param {Object} new The new date range\n         * @param {Date} new.startDate the new start date.\n         * @param {Date} new.endDate the new end date.\n         * @param {Boolean} changed `true` if the date range is different from the last time a request was made.\n         */\n        me.trigger('loadDateRange', {\n            old     : lastDateRange || {},\n            new     : Objects.clone(newDateRange),\n            changed : !lastDateRange || (lastDateRange.startDate - newDateRange.startDate || lastDateRange.endDate - newDateRange.endDate)\n        });\n        // Dates are mutable, so we must keep our own copy.\n        me.lastDateRange = Objects.clone(newDateRange);\n\n        return dateMap ? me.getEventsAsMap(options) : me.getEventsAsArray(options);\n    }\n\n    /**\n     * Internal implementation for {@link #function-getEvents} to use when not using dateMap.\n     * @private\n     */\n    getEventsAsArray({\n        filter,\n        date,\n        resourceRecord,\n        startDate = date,           // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences = true,  // Interpolate occurrences into the returned event set\n        dayTime = null,\n\n        // Injected by the getEvents master method\n        dateFilter,\n\n        storeFilterFn,\n\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const\n            me     = this,\n            events = [],\n            count  = storeFilterFn ? me.count : me.allCount;\n\n        if (count) {\n            let candidateEvents = resourceRecord ? me.getEventsForResource(resourceRecord) : null;\n\n            // If there *was* a resourceRecord, candidateEvents will already be set up using me.getEventsForResource.\n            // If no resourceRecord specified, we are gathering by date, so use the indices.\n            if (!resourceRecord) {\n                const\n                    dateIndex = me.useDayIndex(dayTime),\n                    eventSet  = new Set(),\n                    indexName = startOnly ? 'startDate' : 'date';\n\n                // Add all recurring events which started on or before our date range.\n                me.recurringEvents.forEach(e => {\n                    if (dateIndex.dayTime.startOfDay(e.startDate) <= startDate) {\n                        eventSet.add(e);\n                    }\n                });\n\n                // Iterate the date range, using the indices to find qualified events.\n                for (const date = new Date(startDate); date < endDate; date.setDate(date.getDate() + 1)) {\n                    const coincidingEvents = dateIndex.get(getDateIndex ? getDateIndex(date) : indexName, date);\n\n                    coincidingEvents?.forEach(e => eventSet.add(e));\n                }\n\n                // We gathered all events which *coincide* with each date.\n                // We also added in all recurring events which started on or before our date range.\n                // All these were made unique by the Set.\n                // Return it to array form.\n                candidateEvents = [...eventSet];\n            }\n\n            // Events found from the date indices won't be filtered.\n            // On the other side, when using getEventForResource we will get all events for\n            // the resource even if the EventStore is filtered, handle this by excluding \"invisible\" events here\n            if (storeFilterFn) {\n                candidateEvents = candidateEvents.filter(storeFilterFn);\n            }\n\n            // Go through candidates.\n            // For a recurring event, and we are including recurrences, add date-qualifying occurrences.\n            // For a non-recurring event, add it if it's date-qualified.\n            for (let i = 0, { length } = candidateEvents; i < length; i++) {\n                const e = candidateEvents[i];\n\n                // For recurring events, add date-qualifying occurrences, not the base\n                if (includeOccurrences && e.isRecurring) {\n                    events.push.apply(events, e.getOccurrencesForDateRange(startDate, endDate).filter(dateFilter));\n                }\n                // For ordinary events, add if it's date-qualified\n                else if (dateFilter(e)) {\n                    events.push(e);\n                }\n            }\n        }\n\n        return filter ? events.filter(filter) : events;\n    }\n\n    /**\n     * Internal implementation for {@link #function-getEvents} to use when using dateMap.\n     * @private\n     */\n    getEventsAsMap({\n        filter : passedFilter,\n        date,\n        resourceRecord,             // Not supported yet. Will add if ever requested.\n        startDate = date,           // Events which intersect the startDate/endDate\n        endDate,                    // will be returned\n        startOnly,                  // Only events which start on each date will be returned\n        includeOccurrences = true,  // Interpolate occurrences into the returned event set\n        dateMap,                    // Return a Map keyed by date each value being an array of events\n        dayTime = null,\n\n        storeFilterFn,\n\n        // Private option. Select which date index to look up events in depending on the date\n        // we are examining in the date iteration process. Some callers may want to use\n        // different indices depending on the stage through the date iteration.\n        // See Calendar package for usage.\n        getDateIndex\n    }) {\n        const me = this;\n\n        // Convert `true` to a Map.\n        if (dateMap?.clear) {\n            dateMap.clear();\n        }\n        else {\n            dateMap = new Map();\n        }\n\n        if (me.count) {\n            const\n                dateIndex       = me.useDayIndex(dayTime),\n                indexName       = startOnly ? 'startDate' : 'date',\n                recurringEvents = [],\n                filter          = e => (!passedFilter || passedFilter(e)) && (!storeFilterFn || storeFilterFn(e)),\n                baseEventFilter = e => notRecurring(e) && filter(e);\n\n            dayTime = dateIndex.dayTime;  // dayTime=null becomes DayTime instance for midnight\n\n            // We can't yet do this for just a resource.\n            if (resourceRecord) {\n                throw new Error('Querying for events for a resource and returning a date-keyed Map is not supported');\n            }\n            else {\n                // Add all recurring events which started before the end of our date range.\n                // There are none in Gantt projects\n                me.recurringEvents?.forEach(e => {\n                    if (dayTime.startOfDay(e.startDate) < endDate) {\n                        recurringEvents.push(e);\n                    }\n                });\n\n                // Iterate the date range, using the indices to find qualified events.\n                for (const date = new Date(startDate); date < endDate; date.setDate(date.getDate() + 1)) {\n                    let [coincidingEvents, key] = dateIndex.get(getDateIndex ? getDateIndex(date) : indexName, date, true);\n\n                    // The index entry may be there, but it could be empty.\n                    if (coincidingEvents?.size) {\n                        // Convert Set which index holds into an Array.\n                        // A recurring event doesn't go into the Map, its occurrences do.\n                        // Then filter by the passed filter and this Store's filter function\n                        // because events found from the date indices won't be filtered.\n                        coincidingEvents = [...coincidingEvents].filter(baseEventFilter);\n\n                        // Only create the entry for the day if there are events found\n                        if (coincidingEvents.length) {\n                            (dateMap.get(key) || (dateMap.set(key, []).get(key))).push(...coincidingEvents);\n                        }\n                    }\n                }\n            }\n\n            // Go through matching recurring events.\n            for (let i = 0, { length } = recurringEvents; i < length; i++) {\n                const\n                    e = recurringEvents[i],\n                    // For each recurring event, add occurrences if we are including occurrences else, add the base.\n                    // Then filter by the passed filter and this Store's filter function\n                    // because events found from the date indices won't be filtered.\n                    occurrences = (includeOccurrences ? e.getOccurrencesForDateRange(startDate, endDate) : [e]).filter(filter),\n                    lastDate    = DateHelper.add(endDate, 1, 'day');\n\n                // Add occurrences to dateMap\n                for (let bucket, i = 0, { length } = occurrences; i < length; i++) {\n                    const\n                        occurrence = occurrences[i],\n                        date = dayTime.startOfDay(occurrence.startDate),\n                        indexName = getDateIndex ? getDateIndex(date) : (startOnly ? 'startDate' : 'date'),\n                        lastInteresctingDate = (indexName === 'startDate') || occurrence.allDay\n                            ? DateHelper.add(date, 1, 'day')\n                            : DateHelper.min(occurrence.endDate || DateHelper.add(occurrence.startDate, occurrence.duration, occurrence.durationUnit), lastDate);\n\n                    // Loop through covered dates, adding to dateMap if required\n                    for (; date < lastInteresctingDate; date.setDate(date.getDate() + 1)) {\n                        const key = dayTime.dateKey(date);\n\n                        (bucket = dateMap.get(key)) || dateMap.set(key, bucket = []);\n\n                        bucket.push(occurrence);\n                    }\n                }\n            }\n        }\n\n        return dateMap;\n    }\n\n};\n","import DayTime from '../../../Core/util/DayTime.js';\n\n/**\n * @module Scheduler/data/util/EventDayIndex\n */\n\nconst\n    // Maps an index name that can be requested to its storage property on the EventDayIndex instance:\n    indexNameMap = {\n        date      : '_dateIndex',\n        startDate : '_startDateIndex'\n    },\n    indexProps         = Object.values(indexNameMap),\n    emptyArray         = Object.freeze([]),\n    { MILLIS_PER_DAY } = DayTime;\n\n/**\n * This utility class is used by event stores to index events by their day (a \"YYYY-MM-DD\" value, also known as a\n * \"date key\"). This key is produced by a {@link Core.util.DayTime} instance. If two `DayTime` instances have a common\n * `startShift`, they can share an index.\n *\n * @internal\n */\nexport default class EventDayIndex {\n    constructor(store, dayTime) {\n        /**\n         * The `DayTime` definition for this index. This is set to the initial DayTime instance but can be used for\n         * any other {@link #function-register registered} `DayTime` instances since they all posses the same value for\n         * `startShift`.\n         *\n         * This defaults to {@link Core.util.DayTime#property-MIDNIGHT-static}.\n         * @member {Core.util.DayTime} dayTime\n         * @readonly\n         */\n        this.dayTime = dayTime || DayTime.MIDNIGHT;\n\n        /**\n         * The owning store instance of this index.\n         * @member {Scheduler.data.EventStore} store\n         * @private\n         * @readonly\n         */\n        this.store = store;\n\n        /**\n         * The `DayTime` instances {@link #function-register registered} with this index instance. As instances are\n         * {@link #function-unregister unregistered} they are removed from this array. Once this array is empty, this\n         * index can be discarded.\n         * @member {Core.util.DayTime[]} users\n         * @private\n         */\n        this.users = [this.dayTime];\n    }\n\n    /**\n     * Adds an event record to the specified index (either \"startDate\" or \"date\") for a given `date`.\n     * @param {String} indexName The index to which the event record is to be added (either \"startDate\" or \"date\").\n     * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}\n     * method is used to convert this date to a \"YYYY-MM-DD\" key for the index.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    add(indexName, date, eventRecord) {\n        const\n            index    = this[indexNameMap[indexName]],\n            key      = this.dayTime.dateKey(date),\n            entry    = index[key] || (index[key] = new Set());\n\n        entry.add(eventRecord);\n    }\n\n    /**\n     * Adds an event record to all indexes for all dates which the event overlaps.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    addEvent(eventRecord) {\n        let dateMS = this.dayTime.startOfDay(eventRecord.startDate)?.getTime(),\n            endDateMS;\n\n        if (dateMS) {\n            endDateMS = eventRecord.endDate?.getTime() ?? dateMS;\n            this.add('startDate', dateMS, eventRecord);\n\n            do {\n                this.add('date', dateMS, eventRecord);\n                dateMS += MILLIS_PER_DAY;\n            } while (dateMS < endDateMS);\n        }\n    }\n\n    /**\n     * Clear this index.\n     */\n    clear() {\n        indexProps.forEach(name => this[name] = Object.create(null));\n    }\n\n    /**\n     * Returns an object that has properties named by the {@link Core.util.DayTime#function-dateKey} method, or the\n     * array of event records if a `date` is specified, or the event record array and the date key in a 2-element array\n     * if `returnKey` is `true`.\n     * @param {String} indexName The name of the desired index (either 'date' or 'startDate').\n     * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch. When passed, this method will return\n     * the array of event records for this date.\n     * @param {Boolean} [returnKey] Specify `true` to return the date key along with the event record array.\n     * @returns {Object|Scheduler.model.EventModel[]}\n     */\n    get(indexName, date, returnKey) {\n        // Date indices are created on first usage and after that kept up to date on changes\n        !this.initialized && this.initialize();\n\n        let ret = this[indexNameMap[indexName]],\n            key;\n\n        if (date) {\n            key = this.dayTime.dateKey(date);\n            ret = returnKey ? [ret[key], key] : ret[key];\n        }\n\n        return ret;\n    }\n\n    /**\n     * Called when this index is first used. Once called, further store changes will be used to maintain this index.\n     * @private\n     */\n    initialize() {\n        this.initialized = true;\n\n        this.clear();\n        this.sync('splice', this.store.storage.allValues);\n    }\n\n    invalidate() {\n        this.initialized = false;\n\n        indexProps.forEach(name => this[name] = null);\n    }\n\n    /**\n     * Returns `true` if the given `dayTime` matches this index.\n     * @param {Core.util.DayTime} dayTime\n     * @returns {Boolean}\n     */\n    matches(dayTime) {\n        return this.dayTime.startShift === dayTime.startShift;\n    }\n\n    /**\n     * Removes an event record from the specified index (either \"startDate\" or \"date\") for a given `date`.\n     * @param {String} indexName The index to which the event record is to be removed (either \"startDate\" or \"date\").\n     * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}\n     * method is used to convert this date to a \"YYYY-MM-DD\" key for the index.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @private\n     */\n    remove(indexName, date, eventRecord) {\n        const\n            index = this[indexNameMap[indexName]],\n            key   = this.dayTime.dateKey(date),\n            entry = index[key];\n\n        if (entry) {\n            entry.delete(eventRecord);\n        }\n    }\n\n    /**\n     * Removes an event record from all indexes for all dates which the event overlaps.\n     * @param {Scheduler.model.EventModel} eventRecord The event record.\n     * @param {Date} startDate The start date for the event. This may be different from the `startDate` of the given\n     * `eventRecord` when the event is rescheduled.\n     * @param {Date} endDate The end date for the event. This may be different from the `endDate` of the given\n     * `eventRecord` when the event is rescheduled.\n     * @private\n     */\n    removeEvent(eventRecord, startDate, endDate) {\n        let dateMS = this.dayTime.startOfDay(startDate)?.getTime(),\n            endDateMS;\n\n        if (dateMS) {\n            endDateMS = endDate?.getTime() ?? dateMS;\n            this.remove('startDate', dateMS, eventRecord);\n\n            do {\n                this.remove('date', dateMS, eventRecord);\n                dateMS += MILLIS_PER_DAY;\n            } while (dateMS < endDateMS);\n        }\n    }\n\n    // TODO: Improve Collection indices to handle this\n    // Keeps date & startDate indices up to date, used by Calendar and recurrence\n    // The indices are initialized lazily on first access, and then kept up to date on changes\n    sync(action, added, removed, replaced, wasSet) {\n        added = added || emptyArray;\n        removed = removed || emptyArray;\n\n        const\n            me            = this,\n            addedCount    = added.length,\n            removedCount  = removed.length,\n            replacedCount = replaced?.length;\n\n        let i, newEvent, outgoingEvent;\n\n        if (!me.initialized) {\n            return;\n        }\n\n        switch (action) {\n            case 'clear':\n                me.clear();\n                break;\n\n            // Add and remove\n            case 'splice':\n                // Handle replacement of records by instances with same ID\n                if (replacedCount) {\n                    added = added.slice();\n                    removed = removed.slice();\n\n                    for (i = 0; i < replacedCount; i++) {\n                        removed.push(replaced[i][0]);\n                        added.push(replaced[i][1]);\n                    }\n                }\n\n                // Remove entries from indices\n                if (removedCount) {\n                    for (i = 0; i < removedCount; i++) {\n                        outgoingEvent = removed[i];\n\n                        me.removeEvent(outgoingEvent, outgoingEvent.startDate, outgoingEvent.endDate);\n                    }\n                }\n\n                // Add entries to indices\n                if (addedCount) {\n                    for (i = 0; i < addedCount; i++) {\n                        newEvent = added[i];\n\n                        // Can only be date-indexed if it's scheduled.\n                        // Also ignore parent events (likely using a Gantt project)\n                        if (newEvent.isScheduled && !newEvent.isParent) {\n                            me.addEvent(newEvent);\n                        }\n                    }\n                }\n                break;\n\n            // invoked when the start or end changes so that the event can be re-indexed.\n            case 'reschedule':\n                outgoingEvent = added[0];\n\n                me.removeEvent(outgoingEvent, wasSet.startDate?.oldValue || outgoingEvent.startDate,\n                    wasSet.endDate?.oldValue || outgoingEvent.endDate);\n\n                // Now process as as splice with an add and no removes.\n                me.sync('splice', added);\n\n                break;\n        }\n    }\n\n    /**\n     * This method registers a `dayTime` instance with this index in the `users` array.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     */\n    register(dayTime) {\n        this.users.push(dayTime);\n    }\n\n    /**\n     * This method unregisters a `dayTime` instance, removing it from the `users` array. This method returns `true` if\n     * this was the last registered instance and this index is no longer needed.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     * @returns {Boolean}\n     */\n    unregister(dayTime) {\n        const\n            { users } = this,\n            i = users.indexOf(dayTime);\n\n        if (i > -1) {\n            users.splice(i, 1);\n        }\n\n        return !users.length;\n    }\n};\n\n// To avoid shape changes:\nconst proto = EventDayIndex.prototype;\n\nindexProps.forEach(name => proto[name] = null);\nproto.initialized = false;\n","import DayTime from '../../../Core/util/DayTime.js';\nimport EventDayIndex from '../util/EventDayIndex.js';\n\n/**\n * @module Scheduler/data/mixin/DayIndexMixin\n */\n\nconst { MIDNIGHT } = DayTime;\n\n/**\n * Mixing handling Calendars day indices.\n *\n * Consumed by EventStore in Scheduler & Scheduler Pro and TaskStore in Gantt.\n *\n * @mixin\n * @internal\n */\nexport default Target => class DayIndexMixin extends Target {\n\n    static $name = 'DayIndexMixin';\n\n    construct(config) {\n        super.construct(config);\n\n        this.dayIndices = null;\n    }\n\n    //region Keeping index in sync\n\n    // Override to syncIndices on initial load\n    afterLoadData() {\n        this.syncIndices('splice', this.storage.allValues);\n        super.afterLoadData?.();\n    }\n\n    /**\n     * Responds to mutations of the underlying storage Collection.\n     *\n     * Maintain indices for fast finding of events by date.\n     * @param {Object} event\n     * @private\n     */\n    onDataChange({ action, added, removed, replaced }) {\n        // Indices must be synced before responding to change\n        this.syncIndices(action, added, removed, replaced);\n\n        super.onDataChange(...arguments);\n    }\n\n    onDataReplaced(action, data) {\n        // Indices must be synced before responding to change\n        this.syncIndices('clear');\n        this.syncIndices('splice', this.storage.values);\n\n        super.onDataReplaced(action, data);\n    }\n\n    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {\n        // Ensure by-date indices are up to date.\n        if (('startDate' in wasSet) || ('endDate' in wasSet)) {\n            this.syncIndices('reschedule', [record], null, null, wasSet);\n        }\n\n        super.onModelChange(...arguments);\n    }\n\n    //endregion\n\n    //region Index\n\n    /**\n     * Invalidates associated day indices.\n     * @internal\n     */\n    invalidateDayIndices() {\n        this.dayIndices?.forEach(dayIndex => dayIndex.invalidate());\n    }\n\n    /**\n     * Registers a `DayTime` instance, creating an `EventDayIndex` for each distinct `startShift`. This index is\n     * maintained until all instances with a matching `startShift` are {@link #function-unregisterDayIndex unregistered}.\n     * @param {Core.util.DayTime} dayTime The instance to register.\n     * @internal\n     * @category Indexing\n     */\n    registerDayIndex(dayTime) {\n        const\n            me = this,\n            dayIndices = me.dayIndices || (me.dayIndices = []);\n\n        let dayIndex, i;\n\n        for (i = 0; !dayIndex && i < dayIndices.length; ++i) {\n            if (dayIndices[i].matches(dayTime)) {\n                (dayIndex = dayIndices[i]).register(dayTime);\n            }\n        }\n\n        !dayIndex && dayIndices.push(dayIndex = new EventDayIndex(me, dayTime));\n\n        return dayIndex;\n    }\n\n    syncIndices(...args) {\n        this.dayIndices?.forEach(dayIndex => dayIndex.sync(...args));\n    }\n\n    /**\n     * Removes a registered `DayTime` instance. If this is the last instance registered to an `EventDayIndex`, that\n     * index is removed.\n     * @param {Core.util.DayTime} dayTime The instance to unregister.\n     * @internal\n     * @category Indexing\n     */\n    unregisterDayIndex(dayTime) {\n        const\n            me = this,\n            { dayIndices } = me;\n\n        for (let i = dayIndices?.length; i-- > 0; /* empty */) {\n            if (dayIndices[i].matches(dayTime)) {\n                if (dayIndices[i].unregister(dayTime)) {\n                    dayIndices.splice(i, 1);\n                }\n\n                break;\n            }\n        }\n    }\n\n    /**\n     * Returns the `EventDayIndex` to use for the given `DayTime` instance. This may be the primary instance or a\n     * child instance created by {@link #function-registerDayIndex}.\n     * @param {Core.util.DayTime} dayTime The `DayTime` of the desired index.\n     * @returns {Scheduler.data.util.EventDayIndex}\n     * @private\n     * @category Indexing\n     */\n    useDayIndex(dayTime) {\n        const\n            me             = this,\n            { dayIndices } = me;\n\n        dayTime = dayTime || MIDNIGHT;\n\n        for (let i = 0; dayIndices && i < dayIndices.length; ++i) {\n            if (dayIndices[i].matches(dayTime)) {\n                return dayIndices[i];\n            }\n        }\n\n        if (dayTime.startShift) {\n            throw new Error(`No day index registered for ${dayTime} on ${me.id}`);\n        }\n\n        return me.registerDayIndex(MIDNIGHT);\n    }\n\n    //endregion\n};\n","/* eslint-disable no-unused-expressions */\n\n/**\n * @module Scheduler/data/mixin/SharedEventStoreMixin\n */\n\n/**\n * This is a mixin, containing functionality related to managing events.\n *\n * It is consumed by the regular {@link Scheduler.data.EventStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class SharedEventStoreMixin extends Target {\n    static get $name() {\n        return 'SharedEventStoreMixin';\n    }\n\n    /**\n     * Add events to the store.\n     *\n     * NOTE: Dates, durations and references (assignments, resources) on the events are determined async by a calculation\n     * engine. Thus they cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * eventStore.add({ startDate, duration });\n     * // endDate is not yet calculated\n     * ```\n     *\n     * To guarantee data is in a calculated state, wait for calculations for finish:\n     *\n     * ```javascript\n     * eventStore.add({ startDate, duration });\n     * await eventStore.project.commitAsync();\n     * // endDate is calculated\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * await eventStore.addAsync({ startDate, duration });\n     * // endDate is calculated\n     * ```\n     *\n     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.EventModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n\n    /**\n     * Add events to the store and triggers calculations directly after. Await this function to have up to date data on\n     * the added events.\n     *\n     * ```javascript\n     * await eventStore.addAsync({ startDate, duration });\n     * // endDate is calculated\n     * ```\n     *\n     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.EventModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n\n    /**\n     * Applies a new dataset to the EventStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: Dates, durations and relations (assignments, resources) on the events are determined async by a calculation\n     * engine. Thus they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * eventStore.data = [{ startDate, duration }];\n     * // eventStore.first.endDate is not yet calculated\n     * ```\n     *\n     * To guarantee data is in a calculated state, wait for calculations for finish:\n     *\n     * ```javascript\n     * eventStore.data = [{ startDate, duration }];\n     * await eventStore.project.commitAsync();\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await eventStore.loadDataAsync([{ startDate, duration }]);\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * @member {EventModelConfig[]} data\n     * @category Records\n     */\n\n    /**\n     * Applies a new dataset to the EventStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await eventStore.loadDataAsync([{ startDate, duration }]);\n     * // eventStore.first.endDate is calculated\n     * ```\n     *\n     * @param {EventModelConfig[]} data Array of EventModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 100,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 200,\n\n            storeId : 'events',\n\n            /**\n             * Configure with `true` to also remove the event when removing the last assignment from the linked\n             * AssignmentStore. This config has not effect when using EventStore in legacy `resourceId`-mode.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            removeUnassignedEvent : true,\n\n            /**\n             * Configure with `true` to force single-resource mode, an event can only be assigned to a single resource.\n             * If not provided, the mode will be inferred from\n             *\n             * 1. presence of an assignment store (i.e. multi-assignment)\n             * 2. presence of `resourceId` in the event store data (i.e. single assignment mode)\n             * @config {Boolean}\n             * @category Common\n             */\n            singleAssignment : null\n        };\n    }\n\n    /**\n     * Class used to represent records. Defaults to class EventModel.\n     * @member {Scheduler.model.EventModel} modelClass\n     * @typings {typeof EventModel}\n     * @category Records\n     */\n\n    construct(config) {\n        super.construct(config, true);\n\n        if (this.singleAssignment) {\n            this.usesSingleAssignment = true;\n        }\n\n        if (!this.modelClass.isEventModel) {\n            throw new Error('The model for the EventStore must subclass EventModel');\n        }\n    }\n\n    /**\n     * Appends a new record to the store\n     * @param {Scheduler.model.EventModel} record The record to append to the store\n     * @category CRUD\n     */\n    append(record) {\n        return this.add(record);\n    }\n\n    //region Project\n\n    get project() {\n        return super.project;\n    }\n\n    set project(project) {\n        super.project = project;\n\n        this.detachListeners('project');\n\n        if (project) {\n            // Project already has AssignmentStore instance? Attach to it.\n            if (project.assignmentStore?.isAssignmentStore) {\n                this.attachToAssignmentStore(project.assignmentStore);\n            }\n\n            // Accessing assignmentStore would trigger `assignmentStoreChange` event on the project, so we set up\n            // the listener after\n            project.ion({\n                name                  : 'project',\n                assignmentStoreChange : 'onProjectAssignmentStoreChange',\n                thisObj               : this,\n                prio                  : 200 // Before UI updates\n            });\n        }\n    }\n\n    //endregion\n\n    //region Single assignment\n\n    get usesSingleAssignment() {\n        if (this.isChained) {\n            return this.masterStore.usesSingleAssignment;\n        }\n        return this._usesSingleAssignment;\n    }\n\n    set usesSingleAssignment(value) {\n        this._usesSingleAssignment = value;\n    }\n\n    processRecords(eventRecords) {\n        const\n            { assignmentStore } = this,\n            assignmentsToAdd = [];\n\n        // Same as on `joinRecordsToStore`, when adding a number of event records CoreEventMixin#joinProject method\n        // will clear/rebuild cache in a loop. We raise this flag to skip invalidating assignment store indices for the time\n        // we are joining records to the store. When they're added and indices are read, we will invalidate them.\n        if (assignmentStore) {\n            assignmentStore.skipInvalidateIndices = true;\n        }\n\n        eventRecords = super.processRecords(eventRecords, assignmentStore && !this.stm?.isRestoring && (eventRecord => {\n            // AssignmentStore found, add an assignment to it if this is not a dataset operation\n            const resourceId = eventRecord.get('resourceId');\n\n            if (!eventRecord.reassignedFromReplace && resourceId != null) {\n                // Check if the event is already assigned to the resource, though it's not in the event store.\n                // It could happen when you remove an event, so both event and assignment records are removed,\n                // then you \"undo\" the action and the assignment is restored before the event is restored.\n                if (!assignmentStore.includesAssignment(eventRecord.id, resourceId)) {\n                    // Cannot use `event.assign(resourceId)` since event is not part of store yet\n                    // Using a bit shorter generated id to not look so ugly in DOM\n                    assignmentsToAdd.push({\n                        id      : assignmentStore.modelClass.generateId(''),\n                        resourceId,\n                        eventId : eventRecord.id\n                    });\n                }\n            }\n\n            // clear flag\n            eventRecord.reassignedFromReplace = false;\n        }) || undefined);\n\n        if (assignmentStore) {\n            assignmentStore.storage.invalidateIndices();\n            assignmentStore.skipInvalidateIndices = false;\n\n            assignmentStore.add(assignmentsToAdd);\n        }\n\n        return eventRecords;\n    }\n\n    joinRecordsToStore(records) {\n        const { assignmentStore } = this;\n\n        if (assignmentStore) {\n            // When adding a number of event records CoreEventMixin#joinProject method will clear/rebuild cache in a loop.\n            // We raise this flag to skip invalidating assignment store indices for the time we are joining records to\n            // the store. When they're added and indices are read, we will invalidate them.\n            assignmentStore.skipInvalidateIndices = true;\n\n            super.joinRecordsToStore(records);\n\n            assignmentStore.storage.invalidateIndices();\n\n            assignmentStore.skipInvalidateIndices = false;\n        }\n        else {\n            super.joinRecordsToStore(records);\n        }\n    }\n\n    processRecord(eventRecord, isDataset = false) {\n        eventRecord = super.processRecord(eventRecord, isDataset);\n\n        const resourceId = eventRecord.get('resourceId');\n\n        if (resourceId != null && !eventRecord.meta.skipEnforcingSingleAssignment) {\n            const\n                me                  = this,\n                { assignmentStore } = me,\n                existingRecord      = me.getById(eventRecord.id),\n                isReplacing         = existingRecord && existingRecord !== eventRecord && !isDataset;\n\n            // Replacing an existing event, repoint the resource of its assignment\n            // (already repointed to the new event by engine in EventStoreMixin)\n            if (isReplacing) {\n                // Have to look assignment up on store, removed by engine in super call above\n                const assignment = assignmentStore.find(e => e.eventId === eventRecord.id);\n                if (assignment) {\n                    assignment.resource = resourceId;\n                    eventRecord.reassignedFromReplace = true;\n                }\n            }\n            // No AssignmentStore assigned yet, need to process when that happens. Or if it is a dataset operation,\n            // processing will happen at the end of it to not add individual assignment (bad for performance)\n            else {\n                me.$processResourceIds = true;\n            }\n\n            // Flag that we have been loaded using resourceId, checked by CrudManager to exclude the internal\n            // AssignmentStore from sync\n            me.usesSingleAssignment = true;\n        }\n\n        return eventRecord;\n    }\n\n    processResourceIds() {\n        const { assignmentStore } = this;\n\n        if (this.$processResourceIds && assignmentStore?.isAssignmentStore && !this.project.isSharingAssignmentStore) {\n            const assignments = [];\n\n            // resourceIds used during initialization, convert into assignments\n            this.forEach(eventRecord => {\n                const { resourceId, id : eventId } = eventRecord;\n                if (resourceId != null) {\n                    // Using a bit shorter generated id to not look so ugly in DOM\n                    assignments.push({\n                        id : assignmentStore.modelClass.generateId(''),\n                        resourceId,\n                        eventId\n                    });\n                }\n            });\n\n            // Disable as much as possible, since we are in full control of this store when using single assignment mode\n            assignmentStore.useRawData = {\n                disableDefaultValue     : true,\n                disableDuplicateIdCheck : true,\n                disableTypeConversion   : true\n            };\n            // Flag that throws in AssignmentStore if data is loaded some other way when using single assignment\n            assignmentStore.usesSingleAssignment = false;\n            // These assignments all use generated ids, and are not meant to be searialized anyway so bypass check\n            assignmentStore.verifyNoGeneratedIds = false;\n\n            assignmentStore.data = assignments;\n\n            assignmentStore.usesSingleAssignment = true;\n\n            this.$processResourceIds = false;\n        }\n    }\n\n    loadData() {\n        super.loadData(...arguments);\n\n        this.processResourceIds();\n    }\n\n    // Optionally remove unassigned events\n    onBeforeRemoveAssignment({ records }) {\n        const me = this;\n\n        if (\n            me.removeUnassignedEvent && !me.isRemoving && !me.isSettingData &&\n            !me.stm?.isRestoring && !me.usesSingleAssignment &&\n            // Do not remove unassigned events when syncing data, new assignments etc might be synced afterwards\n            !me.assignmentStore.isSyncingDataOnLoad && !me.resourceStore.isSyncingDataOnLoad\n        ) {\n            const toRemove = new Set();\n            // Collect all events that are unassigned after the remove\n            records.forEach(assignmentRecord => {\n                const { event } = assignmentRecord;\n                // Assignment might not have an event or the event might already be removed\n                if (event && !event.isRemoved && event.assignments.every(a => records.includes(a))) {\n                    toRemove.add(event);\n                }\n            });\n\n            // And remove them\n            if (toRemove.size) {\n                me.remove([...toRemove]);\n            }\n        }\n    }\n\n    onProjectAssignmentStoreChange({ store }) {\n        this.attachToAssignmentStore(store);\n    }\n\n    attachToAssignmentStore(assignmentStore) {\n        const me = this;\n\n        me.detachListeners('assignmentStore');\n\n        if (assignmentStore) {\n            me.processResourceIds();\n\n            assignmentStore.ion({\n                name : 'assignmentStore',\n\n                // Adding an assignment in single assignment mode should set events resourceId if needed\n                addPreCommit({ records }) {\n                    if (me.usesSingleAssignment && !me.isSettingData && !me.isAssigning) {\n                        records.forEach(assignment => {\n                            const { event } = assignment;\n                            if (event?.isEvent && event.resourceId !== assignment.resourceId) {\n                                event.meta.isAssigning = true;\n                                event.set('resourceId', assignment.resourceId);\n                                event.meta.isAssigning = false;\n                            }\n                        });\n                    }\n                },\n\n                // Called both for remove and removeAll\n                beforeRemove : 'onBeforeRemoveAssignment',\n\n                // Removing an assignment in single assignment mode should set events resourceId to null\n                removePreCommit({ records }) {\n                    if (me.usesSingleAssignment) {\n                        records.forEach(assignment => {\n                            // With engine link to event is already broken when we get here, hence the lookup\n                            me.getById(assignment.eventId)?.set('resourceId', null);\n                        });\n                    }\n                },\n\n                removeAllPreCommit() {\n                    if (me.usesSingleAssignment && !me.isSettingData) {\n                        me.allRecords.forEach(eventRecord => eventRecord.set('resourceId', null));\n                    }\n                },\n\n                // Keep events resourceId in sync with assignment on changes in single assignment mode\n                update({ record, changes }) {\n                    if (me.usesSingleAssignment && 'resourceId' in changes) {\n                        const { event } = record;\n                        event.meta.isAssigning = true;\n                        event.set('resourceId', changes.resourceId.value);\n                        event.meta.isAssigning = false;\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n\n    set data(data) {\n        this.isSettingData = true;\n\n        // When using single assignment, remove all assignments when loading a new set of events.\n        // Don't do it when filling a chained store, assignments are for the master store\n        if (this.usesSingleAssignment && !this.syncDataOnLoad && !this.isChained) {\n            this.assignmentStore.removeAll(true);\n        }\n\n        super.data = data;\n\n        this.isSettingData = false;\n    }\n\n    // Override trigger to decorate update/change events with a flag if resourceId was the only thing changed, in which\n    // case the change most likely can be ignored since the assignment will also change\n    trigger(eventName, params) {\n        const { changes } = params || {};\n\n        if (changes && 'resourceId' in changes && Object.keys(changes).length === 1) {\n            params.isAssign = true;\n        }\n\n        return super.trigger(...arguments);\n    }\n\n    //endregion\n};\n","import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n\n/**\n * @module Scheduler/data/mixin/RecurringTimeSpansMixin\n */\n\nconst\n    emptyArray = Object.freeze([]);\n\n/**\n * This mixin class provides recurring timespans functionality to a store of {@link Scheduler.model.TimeSpan TimeSpan} models.\n * @mixin\n */\nexport default Target => class RecurringTimeSpansMixin extends (Target || Base) {\n    static get $name() {\n        return 'RecurringTimeSpansMixin';\n    }\n\n    construct(...args) {\n        const me = this;\n\n        // We store all generated occurrences keyed by `_generated_${recurringTimeSpan.id}:${occurrenceStartDate}`\n        // So that when asked to generate an occurrence for a date, an already generated one can be returned.\n        me.globalOccurrences = new Map();\n\n        // All recurring events added to the store are accessible through this Set. It's used\n        // to generate occurrences.\n        me.recurringEvents = new Set();\n\n        super.construct(...args);\n    }\n\n    // Override to refreshRecurringEventsCache on initial load\n    afterLoadData() {\n        // All cached occurrences are now potentially invalid.\n        // A store reload might imply any number of changes which invalidate any occurrence.\n        this.globalOccurrences.clear();\n\n        // Clear and rebuild the recurring events cache\n        this.refreshRecurringEventsCache('clear');\n        this.refreshRecurringEventsCache('splice', this.storage.allValues);\n        super.afterLoadData && super.afterLoadData();\n    }\n\n    /**\n     * Responds to mutations of the underlying storage Collection.\n     *\n     * Maintain indices for fast finding of events by date.\n     * @param {Object} event\n     * @private\n     */\n    onDataChange({ action, added, removed, replaced }) {\n        // Recurring events cache must be refreshed before responding to change\n        this.refreshRecurringEventsCache(action, added, removed, replaced);\n        super.onDataChange(...arguments);\n    }\n\n    refreshRecurringEventsCache(action, added = emptyArray, removed = emptyArray, replaced) {\n        const\n            me                  = this,\n            { recurringEvents } = me,\n            replacedCount       = replaced?.length;\n\n        switch (action) {\n            case 'clear':\n                recurringEvents.clear();\n                break;\n\n            // Add and remove\n            case 'splice': {\n                // Handle replacement of records by instances with same ID\n                if (replacedCount) {\n                    added = added.slice();\n                    removed = removed.slice();\n\n                    for (let i = 0; i < replacedCount; i++) {\n                        removed.push(replaced[i][0]);\n                        added.push(replaced[i][1]);\n                    }\n                }\n\n                const\n                    addedCount   = added.length,\n                    removedCount = removed.length;\n\n                // Track the recurring events we contain\n                if (removedCount && recurringEvents.size) {\n                    for (let i = 0; i < removedCount; i++) {\n                        // If it's being removed, remove it from the recurring events cache.\n                        // If it's not a recurring event, it doesn't matter, it won't be in there.\n                        recurringEvents.delete(removed[i]);\n                    }\n                }\n                // Track the recurring events we contain\n                if (addedCount) {\n                    for (let i = 0; i < addedCount; i++) {\n                        const newEvent = added[i];\n\n                        // Allow easy access to recurring events\n                        if (newEvent.isRecurring) {\n                            recurringEvents.add(newEvent);\n                        }\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    //<debug>\n    add(record, ...args) {\n        // StoreCRUD#add always converts to array anyway, so do it first here\n        // so that the occurrence check can be reliable.\n        const records = ArrayHelper.asArray(record);\n\n        // Occurrences can never be in the store.\n        // When an occurrence is edited, it becomes an exception\n        // and is promoted to be a full event and THEN added.\n        if (this.isEventStore && records.some(r => r.isOccurrence)) {\n            throw new Error('Occurrences must not be added to the event store');\n        }\n        else {\n            return super.add(records, ...args);\n        }\n    }\n    //</debug>\n\n    getById(id) {\n        let result = super.getById(id);\n\n        // If the id is not found in the Store, then it could be one of our generated occurrences\n        if (!result) {\n            result = this.globalOccurrences.get(this.modelClass.asId(id));\n        }\n\n        return result;\n    }\n\n    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {\n        const isRecurrenceRelatedFieldChange = this.isRecurrenceRelatedFieldChange(record, wasSet);\n\n        // If this is the base of a recurring sequence, then any reactors to events from\n        // the super call must regenerate occurrences, so must be done at top.\n        // If silent is true, occurrences won't be recalculated. Do not remove occurrences from cache in such case.\n        if (isRecurrenceRelatedFieldChange && !silent) {\n            record.removeOccurrences();\n        }\n\n        super.onModelChange(...arguments);\n\n        // If this is the base of a recurring sequence, then the EventStore must\n        // trigger a refresh event so that UIs refresh themselves.\n        // This could be at the tail end of the creation of an exception\n        // or a new recurring base.\n        if (isRecurrenceRelatedFieldChange && !silent) {\n            const event = { action : 'batch', records : this.storage.values };\n\n            this.trigger('refresh', event);\n            this.trigger('change', event);\n        }\n    }\n\n    /**\n     * The method restricts which field modifications should trigger timespan occurrences building.\n     * By default, any field change of a recurring timespan causes the rebuilding.\n     * @param  {Scheduler.model.TimeSpan} timeSpan The modified timespan.\n     * @param  {Object} wasSet Object containing the change set.\n     * @returns {Boolean} `True` if the fields modification should trigger the timespan occurrences rebuilding.\n     * @internal\n     * @category Recurrence\n     */\n    isRecurrenceRelatedFieldChange(timeSpan, wasSet) {\n        return timeSpan.isRecurring || 'recurrenceRule' in wasSet;\n    }\n\n    /**\n     * Builds occurrences for the provided timespan across the provided date range.\n     * @private\n     * @category Recurrence\n     */\n    getOccurrencesForTimeSpan(timeSpan, startDate, endDate) {\n        const result = [];\n\n        if (timeSpan.isRecurring) {\n            timeSpan.recurrence.forEachOccurrence(startDate, endDate, r => result.push(r));\n        }\n\n        return result;\n    }\n\n    set data(data) {\n        // All cached occurrences are now invalid with a new dataset\n        this.globalOccurrences.clear();\n        super.data = data;\n    }\n\n    /**\n     * Returns all the recurring timespans.\n     * @returns {Scheduler.model.TimeSpan[]} Array of recurring events.\n     * @category Recurrence\n     */\n    getRecurringTimeSpans() {\n        return [...this.recurringEvents];\n    }\n};\n","import Base from '../../../Core/Base.js';\nimport RecurringTimeSpansMixin from './RecurringTimeSpansMixin.js';\n\n/**\n * @module Scheduler/data/mixin/RecurringEventsMixin\n */\n\n/**\n * This mixin class provides recurring events functionality to the {@link Scheduler.data.EventStore event store}.\n * @extends Scheduler/data/mixin/RecurringTimeSpansMixin\n * @mixin\n */\nexport default Target => class RecurringEventsMixin extends RecurringTimeSpansMixin(Target || Base) {\n\n    static get $name() {\n        return 'RecurringEventsMixin';\n    }\n\n    /**\n     * Returns all the recurring events.\n     *\n     * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getRecurringTimeSpans} method.\n     *\n     * @returns {Scheduler.model.EventModel[]} Array of recurring events.\n     * @category Recurrence\n     */\n    getRecurringEvents() {\n        return this.getRecurringTimeSpans();\n    }\n\n    isEventPersistable(event) {\n        // occurrences are not persistable\n        return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);\n    }\n};\n","import TimeSpan from '../TimeSpan.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/model/mixin/TimeZoneDatesMixin\n */\n\nconst dateFieldsToConvert = {\n    startDate      : 1,\n    endDate        : 1,\n    constraintDate : 1,\n    deadlineDate   : 1\n};\n\n/**\n * This mixin class overrides default Model functionality to provide support for time zone converted dates\n * @private\n * @mixin\n * @mixinbase TimeSpan\n */\nexport default Target => class TimeZonedDatesMixin extends (Target || TimeSpan) {\n\n    static $name = 'TimeZonedDatesMixin';\n\n    setLocalDate(field, date) {\n        this.set(field, this._inTimeZone ? TimeZoneHelper.toTimeZone(date, this._inTimeZone) : date, true);\n        // Need to set data to fool engine that the dates havn't changed\n        this.data[field] = this[field];\n    }\n\n    getLocalDate(field) {\n        if (this._inTimeZone && this[field]) {\n            return TimeZoneHelper.fromTimeZone(this[field], this._inTimeZone);\n        }\n        return this[field];\n    }\n\n    applyChangeset(rawChanges) {\n        const { _inTimeZone } = this;\n\n        // When a sync response arrives from backend, the data will need to be converted to time zone before applied.\n        if (_inTimeZone != null) {\n            for (const field in dateFieldsToConvert) {\n                if (rawChanges[field]) {\n                    this.setLocalDate(field, new Date(rawChanges[field]));\n                    delete rawChanges[field];\n                }\n            }\n        }\n        return super.applyChangeset(...arguments);\n    }\n\n    getFieldPersistentValue(field) {\n        if (this._inTimeZone) {\n            const fieldName = field?.field ?? field?.name ?? field;\n\n            // Used when saving/syncing. Returns local system dates\n            if (dateFieldsToConvert[fieldName]) {\n                return this.getLocalDate(fieldName);\n            }\n        }\n\n        return super.getFieldPersistentValue(field);\n    }\n\n    // Converts current record into a timeZone\n    convertToTimeZone(timeZone) {\n        const\n            me            = this,\n            metaModified  = { ...me.meta.modified },\n            convertFields = { ...dateFieldsToConvert };\n\n        // Do not convert start and end dates on task unless manually scheduled\n        if (me.isTask && !me.manuallyScheduled) {\n            delete convertFields.startDate;\n            delete convertFields.endDate;\n        }\n\n        // Collect values\n        for (const field in convertFields) {\n            // Only convert if field has value\n            if (me[field] != null) {\n                convertFields[field] = me[field];\n\n                // If already converted, restore to local system time zone\n                if (me._inTimeZone) {\n                    convertFields[field] = me.getLocalDate(field);\n\n                    // Restore value in meta modified as well\n                    if (metaModified[field]) {\n                        metaModified[field] = TimeZoneHelper.fromTimeZone(metaModified[field], me._inTimeZone);\n                    }\n                }\n            }\n            else {\n                delete convertFields[field];\n            }\n        }\n\n        // Change time zone\n        me._inTimeZone = timeZone;\n\n        // Set values\n        for (const field in convertFields) {\n            // Convert and set field date silently\n            me.setLocalDate(field, convertFields[field], false);\n            convertFields[field] = 1; // For clearing changes below\n\n            // Convert value in meta modified as well\n            if (me._inTimeZone && metaModified[field]) {\n                metaModified[field] = TimeZoneHelper.toTimeZone(metaModified[field], me._inTimeZone);\n            }\n        }\n\n        // Clear modification metadata\n        me.clearChanges(true, true, convertFields);\n\n        // If old modification metadata, restore them to record and store\n        if (!ObjectHelper.isEmpty(metaModified)) {\n            me.meta.modified = metaModified;\n            me.stores.forEach(store => store.modified.add(me));\n        }\n    }\n};\n","import Model from '../../Core/data/Model.js';\nimport TimeZonedDatesMixin from './mixin/TimeZonedDatesMixin.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Duration from '../../Core/data/Duration.js';\n\n/**\n * @module Scheduler/model/TimeSpan\n */\n\n/**\n * This class represent a simple date range. It is being used in various subclasses and plugins which operate on date ranges.\n *\n * It's a subclass of {@link Core.data.Model}.\n * Please refer to documentation of those classes to become familiar with the base interface of this class.\n *\n * A TimeSpan has the following fields:\n *\n * - {@link #field-startDate}    - start date of the task in the ISO 8601 format\n * - {@link #field-endDate}      - end date of the task in the ISO 8601 format (not inclusive)\n * - {@link #field-duration}     - duration, time between start date and end date\n * - {@link #field-durationUnit} - unit used to express the duration\n * - {@link #field-name}         - an optional name of the range\n * - {@link #field-cls}          - an optional CSS class to be associated with the range.\n *\n * The data source of any field can be customized in the subclass. Please refer to {@link Core.data.Model} for details. To specify\n * another date format:\n *\n * ```javascript\n * class MyTimeSpan extends TimeSpan {\n *   static get fields() {\n *      { name: 'startDate', type: 'date', dateFormat: 'DD/MM/YY' }\n *   }\n * }\n * ```\n *\n * @extends Core/data/Model\n */\nexport default class TimeSpan extends Model.mixin(TimeZonedDatesMixin) {\n\n    static get $name() {\n        return 'TimeSpan';\n    }\n\n    //region Field definitions\n\n    static get fields() {\n        return [\n            /**\n             * The start date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} startDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            {\n                name : 'startDate',\n                type : 'date'\n            },\n\n            /**\n             * The end date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} endDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n            {\n                name : 'endDate',\n                type : 'date'\n            },\n\n            /**\n             * The numeric part of the timespan's duration (the number of units).\n             * @field {Number} duration\n             * @category Scheduling\n             */\n            {\n                name      : 'duration',\n                type      : 'number',\n                allowNull : true,\n                internal  : true\n            },\n\n            /**\n             * The unit part of the TimeSpan duration, defaults to \"d\" (days). Valid values are:\n             *\n             * - \"millisecond\" - Milliseconds\n             * - \"second\" - Seconds\n             * - \"minute\" - Minutes\n             * - \"hour\" - Hours\n             * - \"day\" - Days\n             * - \"week\" - Weeks\n             * - \"month\" - Months\n             * - \"quarter\" - Quarters\n             * - \"year\"- Years\n             *\n             * This field is readonly after creation, to change durationUnit use #setDuration().\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit\n             * @category Scheduling\n             */\n            {\n                type         : 'durationunit',\n                name         : 'durationUnit',\n                defaultValue : 'd',\n                internal     : true\n            },\n\n            {\n                name    : 'fullDuration',\n                persist : false,\n                column  : {\n                    type : 'duration'\n                }\n            },\n\n            /**\n             * An encapsulation of the CSS classes to add to the rendered time span element.\n             *\n             * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For\n             * granular control of adding and removing individual classes, it is recommended to use the\n             * {@link Core.helper.util.DomClassList} API.\n             *\n             * @field {Core.helper.util.DomClassList} cls\n             * @accepts {Core.helper.util.DomClassList|String|String[]|Object}\n             *\n             * @category Styling\n             */\n            {\n                name         : 'cls',\n                defaultValue : '',\n                internal     : true\n            },\n\n            /**\n             * CSS class specifying an icon to apply to the rendered time span element.\n             * **Note**: In case event is a milestone, using `iconCls` with dependency feature might slightly decrease\n             * performance because feature will refer to the DOM to get exact size of the element.\n             * @field {String} iconCls\n             * @category Styling\n             */\n            {\n                name     : 'iconCls',\n                internal : true\n            },\n\n            /**\n             * A CSS style string (applied to `style.cssText`) or object (applied to `style`)\n             * ```\n             * record.style = 'color: red;font-weight: 800';\n             * ```\n             *\n             * @field {String} style\n             * @category Styling\n             */\n            {\n                name     : 'style',\n                type     : 'object',\n                internal : true\n            },\n\n            /**\n             * The name of the time span (or Event / Task)\n             * @field {String} name\n             * @category Common\n             */\n            {\n                name         : 'name',\n                type         : 'string',\n                defaultValue : ''\n            }\n        ];\n    }\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        // This should probably be a property setter of some mandatory config, then we would not need an afterConfigure implementation.\n        this.normalize();\n    }\n\n    /**\n     * Returns the event store this event is part of, if any.\n     *\n     * @property {Scheduler.data.EventStore}\n     * @readonly\n     * @category Misc\n     */\n    get eventStore() {\n        const me = this;\n\n        // If we are an occurrence, return our base recurring event's store\n        if (me.isOccurrence) {\n            return me.recurringTimeSpan.eventStore;\n        }\n        if (!me._eventStore) {\n            me._eventStore = me.stores?.find(s => s.isEventStore);\n        }\n        return me._eventStore;\n    }\n\n    normalize() {\n        const\n            me                                             = this,\n            { startDate, endDate, duration, durationUnit } = me,\n            hasDuration                                    = duration != null;\n\n        // need to calculate duration (checking first since seemed most likely to happen)\n        if (startDate && endDate && !hasDuration) {\n            me.setData('duration', DH.diff(startDate, endDate, durationUnit, true));\n        }\n        // need to calculate endDate?\n        else if (startDate && !endDate && hasDuration) {\n            me.setData('endDate', DH.add(startDate, duration, durationUnit));\n        }\n        // need to calculate startDate\n        else if (!startDate && endDate && hasDuration) {\n            me.setData('startDate', DH.add(endDate, -duration, durationUnit));\n        }\n    }\n\n    //endregion\n\n    //region Getters & Setters\n\n    updateInternalCls(cls) {\n        if (this._cls) {\n            this._cls.value = cls;\n        }\n        else {\n            this._cls = new DomClassList(cls);\n        }\n    }\n\n    set internalCls(cls) {\n        this.updateInternalCls(cls);\n        this.set('cls', this._cls.value);\n    }\n\n    get internalCls() {\n        const { cls } = this;\n        // `cls` getter can be overriden so return `cls` value if it is DomClassList or assign it to `this._cls`\n        if (cls?.isDomClassList) {\n            return cls;\n        }\n        this.internalCls = cls;\n        return this._cls;\n    }\n\n    get cls() {\n        if (!this._cls) {\n            this._cls = new DomClassList(super.get('cls'));\n        }\n        return this._cls;\n    }\n\n    set cls(cls) {\n        this.internalCls = cls;\n    }\n\n    get startDate() {\n        return this.get('startDate');\n    }\n\n    set startDate(date) {\n        this.setStartDate(date);\n    }\n\n    get endDate() {\n        return this.get('endDate');\n    }\n\n    set endDate(date) {\n        this.setEndDate(date);\n    }\n\n    // TODO This can go away if Calendar would avoid rendering prior to the engine being ready (i.e., having calculated\n    //  all endDate values)\n    get endingDate() {\n        const\n            me = this,\n            {\n                endDate,\n                startDate\n            }  = me;\n\n        if (endDate) {\n            // Special case of startDate===endDate for allDay event:\n            // if (Number(endDate) === Number(startDate) && me.allDay) {\n            //     return DH.add(startDate, 1, 'd');\n            // }\n            // Nope... the above works fine except when the day start time is shifted. In this case we want the\n            // event to appear as \"all day\" on the shifted day, but the above will push the endingDate beyond the\n            // end of the shifted day.\n\n            return endDate;\n        }\n\n        return DH.add(startDate, me.duration, me.durationUnit);\n    }\n\n    get duration() {\n        return this.get('duration');\n    }\n\n    set duration(duration) {\n        this.setDuration(duration, this.durationUnit);\n    }\n\n    get durationUnit() {\n        return this.get('durationUnit');\n    }\n\n    /**\n     * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is\n     * readonly after creation\n     * @param {Number} duration Duration value\n     * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit Unit for\n     * specified duration value, see {@link #field-durationUnit} for valid values\n     * @category Scheduling\n     */\n    setDuration(duration, durationUnit = this.durationUnit) {\n        // Must be a number\n        duration = parseFloat(duration);\n\n        const toSet = {\n            duration,\n            durationUnit\n        };\n\n        if (this.startDate) {\n            toSet.endDate = DH.add(this.startDate, duration, durationUnit);\n        }\n        else if (this.endDate) {\n            toSet.startDate = DH.add(this.endDate, -duration, durationUnit);\n        }\n\n        this.set(toSet);\n    }\n\n    /**\n     * Returns duration of the event in given unit. This is a wrapper for {@link Core.helper.DateHelper#function-getDurationInUnit-static}\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit\n     * @param {Boolean} [doNotRound]\n     * @private\n     * @returns {Number}\n     */\n    getDurationInUnit(unit, doNotRound) {\n        if (this.starDate && this.endDate) {\n            return DH.getDurationInUnit(this.startDate, this.endDate, unit, doNotRound);\n        }\n        else {\n            return DH.as(unit, this.duration, this.durationUnit);\n        }\n    }\n\n    /**\n     * Property which encapsulates the duration's magnitude and units.\n     * @property {Core.data.Duration}\n     */\n    get fullDuration() {\n        // Used for formatting during export\n        return new Duration({\n            unit      : this.durationUnit,\n            magnitude : this.duration\n        });\n    }\n\n    set fullDuration(duration) {\n        if (typeof duration === 'string') {\n            duration = DH.parseDuration(duration, true, this.durationUnit);\n        }\n\n        this.setDuration(duration.magnitude, duration.unit);\n    }\n\n    /**\n     * Sets the range start date\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task (\"move\" the event), `false` to change the duration (\"resize\" the event).\n     * Defaults to `true`\n     * @category Scheduling\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me    = this,\n            toSet = {\n                startDate : date\n            };\n\n        if (date) {\n            let calcEndDate;\n\n            if (keepDuration) {\n                calcEndDate = me.duration != null;\n            }\n            else {\n                if (me.endDate) {\n                    toSet.duration = DH.diff(date, me.endDate, me.durationUnit, true);\n\n                    if (toSet.duration < 0) throw new Error('Negative duration');\n                }\n                else {\n                    calcEndDate = this.duration != null;\n                }\n            }\n\n            if (calcEndDate) {\n                // Use hours to set end date in order to correctly process DST crossings\n                toSet.endDate = DH.add(date, me.getDurationInUnit('h'), 'h');\n            }\n        }\n        else {\n            toSet.duration = null;\n        }\n\n        me.set(toSet);\n    }\n\n    /**\n     * Sets the range end date\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the task (\"move\" the event), `false` to change the duration (\"resize\" the event).\n     * Defaults to `false`\n     * @category Scheduling\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me    = this,\n            toSet = {\n                endDate : date\n            };\n\n        if (date) {\n            let calcStartDate;\n\n            if (keepDuration === true) {\n                calcStartDate = me.duration != null;\n            }\n            else {\n                if (me.startDate) {\n                    toSet.duration = DH.diff(me.startDate, date, me.durationUnit, true);\n\n                    if (toSet.duration < 0) throw new Error('Negative duration');\n                }\n                else {\n                    calcStartDate = this.duration != null;\n                }\n            }\n\n            if (calcStartDate) {\n                toSet.startDate = DH.add(date, -me.duration, me.durationUnit);\n            }\n        }\n\n        me.set(toSet);\n    }\n\n    /**\n     * Sets the event start and end dates\n     *\n     * @param {Date} start The new start date\n     * @param {Date} end The new end date\n     * @param {Boolean} [silent] Pass `true` to not trigger events\n     * @category Scheduling\n     */\n    setStartEndDate(start, end, silent) {\n        this.set({\n            startDate : start,\n            endDate   : end\n        }, null, silent);\n    }\n\n    /**\n     * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.\n     * @readonly\n     * @property {Date[]}\n     * @category Scheduling\n     */\n    get dates() {\n        const\n            dates     = [],\n            startDate = DH.startOf(this.startDate, 'day'),\n            endDate   = this.endDate;\n\n        for (let date = startDate; date < endDate; date = DH.add(date, 1, 'day')) {\n            dates.push(date);\n        }\n\n        return dates;\n    }\n\n    get startDateMS() {\n        return (this.batching && this.hasBatchedChange('startDate') ? this.get('startDate') : this.startDate)?.getTime();\n    }\n\n    get endDateMS() {\n        return (this.batching && this.hasBatchedChange('endDate') ? this.get('endDate') : this.endDate)?.getTime();\n    }\n\n    /**\n     * Returns the duration of this Event in milliseconds.\n     * @readonly\n     * @property {Number}\n     * @category Scheduling\n     */\n    get durationMS() {\n        const { endDateMS, startDateMS } = this;\n\n        if (endDateMS && startDateMS) {\n            return endDateMS - startDateMS;\n        }\n        else {\n            return DH.asMilliseconds(this.duration || 0, this.durationUnit);\n        }\n    }\n\n    /**\n     * Returns true if record is a milestone.\n     * @readonly\n     * @property {Boolean}\n     * @category Scheduling\n     */\n    get isMilestone() {\n        return this.duration === 0;\n    }\n\n    inSetNormalize(field) {\n        if (typeof field !== 'string') {\n            // If user is updating multiple properties in one go using an object, we help out\n            // by filling out missing schedule related data\n\n            let { startDate, endDate, duration, durationUnit = this.durationUnit } = field;\n\n            // Conversion is usually handled in inSet, but we are normalizing prior to that and have to handle it here\n            if (typeof startDate === 'string') {\n                startDate = this.getFieldDefinition('startDate').convert(startDate);\n            }\n\n            if (typeof endDate === 'string') {\n                endDate = this.getFieldDefinition('endDate').convert(endDate);\n            }\n\n            if ('duration' in field) {\n                if (startDate && !endDate) {\n                    endDate = DH.add(startDate, duration, durationUnit, true, true);\n                }\n\n                if (!startDate && endDate) {\n                    startDate = DH.add(endDate, -duration, durationUnit, true, true);\n                }\n            }\n            else if (startDate && endDate) {\n                // Calculate duration in hours and covert to target duration unit in order to avoid extra DST conversion\n                duration = DH.as(durationUnit, DH.diff(startDate, endDate, 'h', true), 'h');\n            }\n\n            // A framework (React tested) may freeze passed field object, so clone it in that case\n            const fieldOrClone = Object.isFrozen(field) ? ObjectHelper.clone(field) : field;\n            startDate && (fieldOrClone.startDate = startDate);\n            endDate && (fieldOrClone.endDate = endDate);\n            duration != null && (fieldOrClone.duration = duration);\n\n            return fieldOrClone;\n        }\n    }\n\n    inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly) {\n        if (!skipAccessors) {\n            field = this.inSetNormalize(field) || field;\n        }\n\n        return super.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly);\n    }\n\n    // Cls requires special handling since it is converted to a DomClassList\n    applyValue(useProp, key, value, skipAccessors, field) {\n        if (key === 'cls') {\n            this.updateInternalCls(value);\n        }\n        // When setting fullDuration with record.set()\n        if (key === 'fullDuration') {\n            this[key] = value;\n        }\n\n        super.applyValue(useProp, key, value, skipAccessors, field);\n    }\n\n    //endregion\n\n    //region Iteration\n\n    /**\n     * Iterates over the {@link #property-dates}\n     * @param {Function} func The function to call for each date\n     * @param {Object} thisObj `this` reference for the function\n     * @category Scheduling\n     */\n    forEachDate(func, thisObj) {\n        return this.dates.forEach(func.bind(thisObj));\n    }\n\n    //endregion\n\n    /**\n     * Checks if the range record has both start and end dates set and start <= end\n     *\n     * @property {Boolean}\n     * @category Scheduling\n     */\n    get isScheduled() {\n        const { startDateMS, endDateMS } = this;\n\n        return endDateMS - startDateMS >= 0;\n    }\n\n    // Simple check if end date is greater than start date\n    get isValid() {\n        const { startDate, endDate } = this;\n        return !startDate || !endDate || (endDate - startDate >= 0);\n    }\n\n    /**\n     * Shift the dates for the date range by the passed amount and unit\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}\n     * for more information on valid formats.\n     * @param {Number} amount The amount to shift\n     */\n    shift(amount, unit = this.durationUnit) {\n        // TODO REMOVE FOR 2.0\n        if (typeof amount === 'string') {\n            const u = amount;\n\n            amount = unit;\n            unit = u;\n        }\n\n        return this.setStartDate(DH.add(this.startDate, amount, unit, true), true);\n    }\n\n    /**\n     * Returns the WBS code of this model (e.g '2.1.3'). Only relevant when part of a tree store, as in the Gantt chart.\n     * @property {String}\n     * @category Parent & children\n     */\n    get wbsCode() {\n        return this._wbsCode || this.indexPath.join('.');\n    }\n\n    set wbsCode(value) {\n        // wbsCode needs to be writable to interop w/TaskModel and Baselines which copy this field value\n        this._wbsCode = value;\n    }\n\n    fullCopy() {\n        //NOT PORTED\n\n        return this.copy.apply(this, arguments);\n    }\n\n    intersects(timeSpan) {\n        return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);\n    }\n\n    intersectsRange(start, end) {\n        const\n            myStart = this.startDate,\n            myEnd   = this.endDate;\n\n        return myStart && myEnd && DH.intersectSpans(myStart, myEnd, start, end);\n    }\n\n    /**\n     * Splits this event into two pieces at the desired position.\n     *\n     * @param {Number|String} splitPoint The duration point at which to split this event.\n     *\n     * If less then `1`, this indicates the relative position at which it will be split.\n     * 0.5 means cut it in half.\n     *\n     * If greater than `1`, this indicates the new duration in the current duration units of this event before the split.\n     *\n     * If this is a string, it will be a duration description as described in\n     * {@link Core.helper.DateHelper#function-parseDuration-static}, for example `'15 min'`\n     *\n     * @returns {Scheduler.model.TimeSpan} The newly created split section of the timespan\n     * @category Scheduling\n     */\n    split(splitPoint = 0.5) {\n        const\n            me             = this,\n            clone          = me.copy(),\n            {\n                fullDuration,\n                eventStore,\n                assignmentStore\n            }              = me,\n            oldDuration    = new Duration(fullDuration),\n            cloneDuration  = new Duration(fullDuration);\n\n        let ownNewDuration,\n            unitsChanged;\n\n        if (typeof splitPoint === 'string') {\n            ownNewDuration = new Duration(splitPoint);\n\n            // New duration specified in same time units as current duration\n            if (ownNewDuration.unit === oldDuration.unit) {\n                cloneDuration.magnitude -= ownNewDuration.magnitude;\n            }\n            // New duration is in different units, so convert clone's duration to match\n            else {\n                cloneDuration.magnitude = DH.as(ownNewDuration.unit, oldDuration) - ownNewDuration.magnitude;\n                cloneDuration.unit = ownNewDuration.unit;\n                unitsChanged = true;\n            }\n        }\n        else {\n            ownNewDuration = new Duration(splitPoint > 1 ? splitPoint : me.duration * splitPoint, me.durationUnit);\n            cloneDuration.magnitude -= ownNewDuration.magnitude;\n        }\n\n        clone.startDate = DH.add(me.startDate, ownNewDuration.magnitude, ownNewDuration.unit);\n\n        if (unitsChanged) {\n            clone.fullDuration = cloneDuration;\n            me.fullDuration = ownNewDuration;\n        }\n        else {\n            clone.duration = cloneDuration.magnitude;\n            me.duration = ownNewDuration.magnitude;\n        }\n\n        if (eventStore) {\n            eventStore.add(clone);\n\n            if (assignmentStore && !eventStore.usesSingleAssignment) {\n                assignmentStore.add(\n                    me.assignments.map(assignment => {\n                        const clonedData = Object.assign({}, assignment.data, {\n                            eventId  : clone.id,\n                            // From engine\n                            event    : null,\n                            resource : null\n                        });\n                        delete clonedData.id;\n\n                        return clonedData;\n                    })\n                );\n            }\n        }\n\n        return clone;\n    }\n\n    toICSString(icsEventConfig = {}) {\n        if (!this.isScheduled) {\n            return '';\n        }\n\n        const\n            {\n                startDate,\n                endDate\n            }         = this,\n            // To allow testing using a fixed timestamp value\n            timestamp = icsEventConfig.DTSTAMP || DH.format(new Date(), 'uu');\n\n        delete icsEventConfig.DTSTAMP;\n\n        let startEnd = {};\n\n        if (this.allDay) {\n            startEnd = {\n                'DTSTART;VALUE=DATE' : DH.format(startDate, 'u'),\n                'DTEND;VALUE=DATE'   : DH.format(endDate, 'u')\n            };\n        }\n        else {\n            startEnd = {\n                DTSTART : DH.format(startDate, 'uu'),\n                DTEND   : DH.format(endDate, 'uu')\n            };\n        }\n\n        const\n            version       = (VersionHelper.scheduler && VersionHelper.getVersion('scheduler')) || (VersionHelper.calendar && VersionHelper.getVersion('calendar')) || '',\n            icsWrapConfig = {\n                BEGIN    : 'VCALENDAR',\n                VERSION  : '2.0',\n                CALSCALE : 'GREGORIAN',\n                PRODID   : `-//Bryntum AB//Bryntum Scheduler ${version} //EN`,\n                END      : 'VCALENDAR'\n            },\n            eventConfig   = {\n                BEGIN   : 'VEVENT',\n                UID     : this.id + '@bryntum.com',\n                CLASS   : 'PUBLIC',\n                SUMMARY : this.name,\n                DTSTAMP : timestamp,\n                ...startEnd,\n                ...(this.recurrenceRule ? { RRULE : this.recurrenceRule } : {}),\n                ...icsEventConfig,\n                END     : 'VEVENT'\n            },\n            icsItems      = Object.keys(icsWrapConfig).map(key => `${key}:${icsWrapConfig[key]}`),\n            eventItems    = Object.keys(eventConfig).map(key => `${key}:${eventConfig[key]}`);\n\n        // Inject event details before the closing VCALENDAR entry\n        icsItems.splice(icsItems.length - 1, 0, ...eventItems);\n\n        return icsItems.join('\\n');\n    }\n\n    /**\n     * Triggers a download of this time span in ICS format (for import in Outlook etc.)\n     *\n     * ```javascript\n     * timeSpan.downloadAsICS({\n     *      LOCATION : timeSpan.location\n     *  });\n     * ```\n     * @param {Object<String,String>} [icsEventConfig] A config object with properties to be added in to `BEGIN:VEVENT`\n     * section of the exported event.\n     * @category Misc\n     */\n    exportToICS(icsEventConfig) {\n        if (this.isScheduled) {\n            const blob = new Blob([this.toICSString(icsEventConfig)], { type : 'text/calendar' });\n\n            BrowserHelper.downloadBlob(blob, (this.name || 'Event') + '.ics');\n        }\n    }\n\n    /**\n     * Defines if the given event field should be manually editable in UI.\n     * You can override this method to provide your own logic.\n     *\n     * By default the method defines all the event fields as editable.\n     *\n     * @param {String} fieldName Name of the field\n     * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the model has no such field.\n     */\n    isEditable(fieldName) {\n        // return undefined for unknown fields\n        return this.getFieldDefinition(fieldName) ? true : undefined;\n    }\n\n    isFieldModified(fieldName) {\n        if (fieldName === 'fullDuration') {\n            return super.isFieldModified('duration') || super.isFieldModified('durationUnit');\n        }\n        return super.isFieldModified(fieldName);\n    }\n}\n","import Base from '../../../../Core/Base.js';\n\nconst dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;\n\nconst days = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n\nexport default class RecurrenceDayRuleEncoder extends Base {\n\n    static decodeDay(rawDay) {\n        let parsedDay,\n            result;\n\n        if ((parsedDay = dayParseRegExp.exec(rawDay))) {\n\n            result = [days.indexOf(parsedDay[2])];\n\n            // optional position number\n            if (parsedDay[1]) {\n                parsedDay[1] = parseInt(parsedDay[1], 10);\n                result.push(parsedDay[1]);\n            }\n        }\n\n        return result;\n    }\n\n    static encodeDay(day) {\n        let position;\n\n        // support decodeDay() result format\n        if (Array.isArray(day)) {\n            [day, position] = day;\n        }\n\n        return (position ? position.toString() : '') + days[day];\n    }\n\n    // Turns days values provided as an array of strings (like [`-1MO`, `SU`, `+3FR`])\n    // into an array of [ dayIndex, position ] elements, where:\n    //\n    // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)\n    // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))\n    static decode(rawDays) {\n        const result = [];\n        let parsedDay;\n\n        if (rawDays) {\n            for (let i = 0; i < rawDays.length; i++) {\n                if ((parsedDay = this.decodeDay(rawDays[i]))) {\n                    result.push(parsedDay);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    static encode(days) {\n        const result = [];\n        let day;\n\n        if (days) {\n            for (let i = 0; i < days.length; i++) {\n                if ((day = this.encodeDay(days[i]))) {\n                    result.push(day);\n                }\n            }\n        }\n\n        return result;\n    }\n};\n","import Base from '../../../../Core/Base.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n\n/**\n * @module Scheduler/data/util/recurrence/AbstractRecurrenceIterator\n * @private\n */\n\nconst\n    frequencyToUnitRe = /ly$/i,\n    frequencyToUnit = frequency => {\n        const result = frequency.replace(frequencyToUnitRe, '');\n\n        return result === 'DAI' ? 'DAY' : result;\n    },\n    fn = (date, counter, isFirst, timeSpan) => timeSpan.buildOccurrence(date, isFirst),\n    captureLastOccurrence = date => lastOccurrenceDate = date;\n\nlet lastOccurrenceDate;\n\nexport default class AbstractRecurrenceIterator extends Base {\n\n    static frequency = 'NONE'\n\n    static MAX_OCCURRENCES_COUNT = 1000000\n\n    static processIterationConfig(config) {\n        const\n            { recurrence } = config,\n            {\n                frequency,\n                interval,\n                timeSpan,\n                endDate : until,\n                count\n            } = recurrence;\n\n        // Force the correction of the event to be in sync with its recurrence rule\n        // before performing iteration. For example, if the event's configured startDate\n        // is 1st January 2020, and the rule dictates that the event will take place\n        // monthly, every Monday, then the first event is not until Monday 6th January, 2020.\n        if (!config.syncingStartDate && !timeSpan.meta.isSyncedWithRule) {\n            // Do not generate occurrences outside of the specified range\n            const\n                intervalEndDate = DateHelper.add(timeSpan.startDate, interval, frequencyToUnit(frequency)),\n                endDate = DateHelper.min(\n                    intervalEndDate,\n                    config.endDate || intervalEndDate\n                );\n\n            this.forEachDate({\n                syncingStartDate : true,\n                startDate        : timeSpan.startDate,\n                endDate,\n                recurrence,\n                fn\n            });\n        }\n\n        // Capture the start after its been synced with its recurrence rule\n        const timeSpanStart = timeSpan.startDate;\n\n        // Extract the endDate from the config, defaulting to the recurrence UNTIL date\n        let {\n            startDate = timeSpanStart,\n            endDate   = until\n        } = config;\n\n        // No point in starting the iteration before the event starts\n        if (startDate < timeSpanStart) {\n            startDate = timeSpanStart;\n        }\n\n        // The recurrence's stop date overrides the configured endDate.\n        if (until) {\n            if (!endDate || endDate > until) {\n                endDate = until;\n            }\n        }\n        // If we are limiting using count and we are not starting from the\n        // first occurrence, then we have to calculate a stop date.\n        // This is because for date ranges in the future we cannot calculate how many\n        // preceding occurrences there may have been.\n        else if (count && startDate > timeSpanStart) {\n            // Iterate the occurrences from the start to capture the last one\n            this.forEachDate({\n                recurrence,\n                fn : captureLastOccurrence\n            });\n\n            // The date of the last occurrence in the count sequence overrides the configured endDate.\n            if (!endDate || endDate > lastOccurrenceDate) {\n                // since endDate of the provided interval is exclusive add 1 millisecond\n                endDate = new Date(lastOccurrenceDate.getTime() + 1);\n            }\n        }\n\n        // Preserve the requested start of requested visits.\n        const earliestVisibleDate = startDate;\n\n        // Unless we are only asked for events which *start* within the time range. we must make\n        // a best attempt to include any occurrences which span the start date.\n        // So if we are asking for events from the 1st of the month, and there's an event\n        // which runs every 2 months from the 15th to the 5th, we must include it. Start the\n        // iteration <interval> full frequency quanta before the requested start.\n        // This will only cause <interval> extra iterations.\n        // We cannot step back to before the event's starting date though.\n        if (!config.startOnly) {\n            startDate = new Date(DateHelper.max(DateHelper.add(startDate, -interval, frequencyToUnit(frequency)), timeSpanStart));\n        }\n\n        return Object.assign({\n            extraArgs : [],\n            // Only check start date for time spans with 0 duration\n            startOnly : !Boolean(timeSpan.durationMS)\n        }, config, {\n            startDate,\n            endDate,\n            timeSpan,\n            timeSpanStart,\n            earliestVisibleDate,\n            endDateMS             : endDate?.getTime(),\n            timeSpanStartMS       : timeSpanStart.getTime(),\n            earliestVisibleDateMS : earliestVisibleDate.getTime(),\n            durationMS            : timeSpan.durationMS,\n            spansStart            : startDate <= timeSpanStart && endDate > timeSpanStart\n        });\n    }\n\n    static getOccurrenceIndex(event) {\n        if (event.isOccurrence) {\n            return DateHelper.diff(event.recurringTimeSpan.startDate, event.startDate, frequencyToUnit(event.recurringTimeSpan.recurrence.frequency));\n        }\n    }\n\n    /**\n     * Returns Nth occurrence of a week day in the provided period of time.\n     * @param  {Date} startDate Period start date.\n     * @param  {Date} endDate   Period end date.\n     * @param  {Number} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)\n     * @param  {Number} index  Index to find.\n     * @returns {Date}           Returns the found date or null if there is no `index`th entry.\n     * @private\n     */\n    static getNthDayInPeriod(startDate, endDate, day, index) {\n        let result, sign, borderDate;\n\n        if (index) {\n            if (index > 0) {\n                sign = 1;\n                borderDate = startDate;\n            }\n            else {\n                sign = -1;\n                borderDate = endDate;\n            }\n\n            // delta between requested day and border day\n            const delta = day - borderDate.getDay();\n\n            // if the requested day goes after (before, depending on borderDate used (start/end))\n            // we adjust index +/-1\n            if (sign * delta < 0) {\n                index += sign;\n            }\n\n            // measure \"index\" weeks forward (or backward) ..take delta into account\n            // result = new Date(borderDate.getTime() + ((index - sign) * 7 + delta) * 24*60*60*1000);\n            // Per https://github.com/bryntum/support/issues/3413 - don't do that ^^ because DST makes days/week\n            // alternatingly shorter or longer depending on going in/out of DST:\n            result = new Date(borderDate);\n            result.setDate(borderDate.getDate() + (index - sign) * 7 + delta);\n\n            // if resulting date is outside of the provided range there is no \"index\"-th entry\n            // of the day\n            if (result < startDate || result > endDate) {\n                result = null;\n            }\n        }\n\n        return result;\n    }\n\n    static buildDate(year, month, date) {\n        const dt = new Date(year, month, date);\n\n        if (dt.getFullYear() === year && dt.getMonth() === month && dt.getDate() === date) {\n            return dt;\n        }\n    }\n\n    static isValidPosition(position) {\n        return Boolean(position);\n    }\n\n    static forEachDateAtPositions(dates, positions, fn, scope) {\n        const datesLength = dates.length,\n            processed     = {};\n\n        for (let i = 0; i < positions.length; i++) {\n\n            const index = positions[i];\n\n            if (this.isValidPosition(index)) {\n                const date = index > 0 ? dates[index - 1] : dates[datesLength + index];\n\n                if (date && !processed[date.getTime()]) {\n\n                    // remember that we've returned the date\n                    processed[date.getTime()] = true;\n\n                    // return false if it's time to stop recurring\n                    if (fn.call(scope, date) === false) {\n                        return false;\n                    }\n                }\n            }\n        }\n    }\n\n    static isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan) {\n        return (\n            startOnly\n                ? occurrenceDate >= earliestVisibleDate\n                : occurrenceDate.valueOf() + durationMS > earliestVisibleDate\n        ) && !timeSpan.hasException(occurrenceDate);\n    }\n\n    // Slightly faster version of ^, used by Daily & Weekly iterators\n    static isInViewMS(startOnly, occurenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan) {\n        return (\n            startOnly\n                ? occurrenceDateMS >= earliestVisibleDateMS\n                : occurrenceDateMS + durationMS > earliestVisibleDateMS\n        ) && !timeSpan.hasException(occurenceDate);\n    }\n}\n","/**\n * @module Scheduler/data/util/recurrence/DailyRecurrenceIterator\n */\n\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class DailyRecurrenceIterator extends AbstractRecurrenceIterator {\n\n    static frequency = 'DAILY'\n\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts a recurring event which matches the passed recurrence rule and overlaps the start and end dates\n     * and is not an {@link Scheduler.model.mixin.RecurringTimeSpan#field-exceptionDates exceptionDate}\n     * in the recurring event.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                endDateMS,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDateMS,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }                = this.processIterationConfig(config),\n            { interval }     = recurrence,\n            delay            = startDate - timeSpanStart,\n            // recurrence interval duration in ms (86400000 is a single day duration in ms)\n            intervalDuration = interval * 86400000,\n            delayInIntervals = Math.floor(delay / intervalDuration);\n\n        let { count }       = recurrence,\n            counter         = 0,\n            occurrenceDate  = DateHelper.add(timeSpanStart, delayInIntervals * interval, 'day'),\n            occurrenceDateMS = occurrenceDate.getTime();\n\n        if (!endDate && !count) {\n            count = this.MAX_OCCURRENCES_COUNT;\n        }\n\n        while (!endDateMS || occurrenceDateMS < endDateMS) {\n            const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);\n\n            counter++;\n\n            if (inView &&\n                ((endDateMS && occurrenceDateMS > endDateMS) || fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count))\n            ) {\n                break;\n            }\n\n            // shift to the next day\n            occurrenceDate = DateHelper.add(occurrenceDate, interval, 'day');\n            occurrenceDateMS = occurrenceDate.getTime();\n        }\n    }\n}\n","/**\n * @module Scheduler/data/util/recurrence/WeeklyRecurrenceIterator\n */\n\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class WeeklyRecurrenceIterator extends AbstractRecurrenceIterator {\n\n    static frequency = 'WEEKLY'\n\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDateMS,\n                timeSpan,\n                timeSpanStart,\n                timeSpanStartMS,\n                earliestVisibleDateMS,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }                     = this.processIterationConfig(config),\n            {\n                interval,\n                days\n            }                     = recurrence,\n            { weekStartDay }      = DateHelper,\n            startHours            = timeSpanStart.getHours(),\n            startMinutes          = timeSpanStart.getMinutes(),\n            startSeconds          = timeSpanStart.getSeconds(),\n            startMS               = timeSpanStart.getMilliseconds();\n\n        let counter    = 0,\n            { count }  = recurrence,\n            weekDays   = DayRuleEncoder.decode(days),\n            weekStartDate, occurrenceDate;\n\n        // \"Days\" might be skipped then we use the event start day\n        if (!weekDays?.length) {\n            weekDays = [[timeSpanStart.getDay()]];\n        }\n\n        // If week start day is not zero (Sunday)\n        // we need to normalize weekDays array since its values are used\n        // to calculate real dates as: date = week_start_date + weekDay_entry\n        // which does not work when week starts on non-Sunday\n        if (weekStartDay > 0) {\n            for (let i = 0; i < weekDays.length; i++) {\n                if (weekStartDay > weekDays[i][0]) {\n                    weekDays[i][0] = 7 - weekStartDay - weekDays[i][0];\n                }\n                else {\n                    weekDays[i][0] -= weekStartDay;\n                }\n            }\n        }\n\n        // days could be provided in any order so it's important to sort them\n        weekDays.sort((a, b) => a[0] - b[0]);\n\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        weekStartDate = DateHelper.getNext(count || interval > 1 ? timeSpanStart : startDate, 'week', 0);\n\n        if (!endDateMS && !count) {\n            count = this.MAX_OCCURRENCES_COUNT;\n        }\n\n        while (!endDateMS || weekStartDate.getTime() < endDateMS) {\n\n            for (let i = 0; i < weekDays.length; i++) {\n                // Faster than chaining multiple DateHelper calls\n                occurrenceDate = new Date(\n                    weekStartDate.getFullYear(),\n                    weekStartDate.getMonth(),\n                    weekStartDate.getDate() + weekDays[i][0],\n                    startHours,\n                    startMinutes,\n                    startSeconds,\n                    startMS\n                );\n\n                const occurrenceDateMS = occurrenceDate.getTime();\n\n                if (occurrenceDateMS >= timeSpanStartMS) {\n                    const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);\n\n                    counter++;\n\n                    if (inView &&\n                        ((endDateMS && occurrenceDateMS >= endDateMS) ||\n                        (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                        (count && counter >= count))\n                    ) {\n                        return;\n                    }\n                }\n            }\n\n            // get next week start\n            weekStartDate = DateHelper.getNext(weekStartDate, 'week', interval);\n        }\n    }\n\n}\n","/**\n * @module Scheduler/data/util/recurrence/MonthlyRecurrenceIterator\n */\n\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class MonthlyRecurrenceIterator extends AbstractRecurrenceIterator {\n\n    static frequency = 'MONTHLY'\n\n    static getNthDayOfMonth(date, dayNum) {\n        const daysInMonth = DateHelper.daysInMonth(date);\n        let result = null;\n\n        if (dayNum && Math.abs(dayNum) <= daysInMonth) {\n            result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);\n        }\n\n        return result;\n    }\n\n    static isValidPosition(position) {\n        return position && Math.abs(position) > 0 && Math.abs(position) <= 31;\n    }\n\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDate,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }              = this.processIterationConfig(config),\n            {\n                interval,\n                days,\n                count,\n                positions\n            } = recurrence,\n            weekDays       = DayRuleEncoder.decode(days),\n            hasPositions   = positions && positions.length,\n            processedDate  = {};\n\n        let\n            { monthDays }  = recurrence,\n            counter        = 0,\n            weekDayPosition,\n            monthStartDate, monthEndDate,\n            dates, occurrenceDate, i;\n\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        monthStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, 'month');\n        monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);\n\n        // If no month days nor week days are provided let's use event start date month day\n        if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {\n            monthDays = [timeSpanStart.getDate()];\n        }\n\n        if (weekDays && weekDays.length) {\n            // Collect hash of positions indexed by week days\n            weekDays.forEach(day => {\n                if (day[1]) {\n                    weekDayPosition         = weekDayPosition || {};\n                    weekDayPosition[day[0]] = day[1];\n                }\n            });\n        }\n\n        while ((!endDate || endDate > monthStartDate) && (!count || counter < count)) {\n\n            dates = [];\n\n            if (weekDays && weekDays.length) {\n\n                weekDays.forEach(day => {\n                    const weekDay = day[0];\n\n                    let from    = 1,\n                        till    = 53;\n\n                    // if position provided\n                    if (day[1]) {\n                        from = till = day[1];\n                    }\n\n                    for (i = from; i <= till; i++) {\n                        if ((occurrenceDate = this.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i))) {\n                            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n\n                            if (!processedDate[occurrenceDate.getTime()]) {\n                                // remember we processed the date\n                                processedDate[occurrenceDate.getTime()] = true;\n\n                                dates.push(occurrenceDate);\n                            }\n                        }\n                    }\n                });\n\n                dates.sort((a, b) => a - b);\n\n                if (!hasPositions) {\n                    for (i = 0; i < dates.length; i++) {\n                        occurrenceDate = dates[i];\n\n                        if (occurrenceDate >= timeSpanStart) {\n                            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n\n                            counter++;\n\n                            if (inView &&\n                                ((endDate && occurrenceDate >= endDate) || (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) || (count && counter >= count))\n                            ) {\n                                return false;\n                            }\n                        }\n                    }\n                }\n\n            }\n            else {\n                const sortedMonthDates = [];\n\n                for (i = 0; i < monthDays.length; i++) {\n                    // check if the date wasn't iterated over yet\n                    if ((occurrenceDate = this.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[occurrenceDate.getTime()]) {\n                        processedDate[occurrenceDate.getTime()] = true;\n                        sortedMonthDates.push(occurrenceDate);\n                    }\n                }\n\n                // it's important to sort the dates to iterate over them in the proper order\n                sortedMonthDates.sort((a, b) => a - b);\n\n                for (i = 0; i < sortedMonthDates.length; i++) {\n                    occurrenceDate = DateHelper.copyTimeValues(sortedMonthDates[i], timeSpanStart);\n\n                    if (hasPositions) {\n                        dates.push(occurrenceDate);\n                    }\n                    else if (occurrenceDate >= timeSpanStart) {\n                        const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n\n                        counter++;\n\n                        if (inView &&\n                            // eslint-disable-next-line no-labels\n                            ((endDate && occurrenceDate > endDate) || (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) || (count && counter >= count))\n                        ) {\n                            return;\n                        }\n                    }\n                }\n            }\n\n            if (hasPositions && dates.length) {\n                this.forEachDateAtPositions(dates, positions, occurrenceDate => {\n                    if (occurrenceDate >= timeSpanStart) {\n                        const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n\n                        counter++;\n\n                        // Ignore dates outside of the [startDate, endDate] range\n                        if (inView && (!endDate || occurrenceDate <= endDate) &&\n                            // return false if it's time to stop recurring\n                            (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count))\n                        ) {\n                            return false;\n                        }\n                    }\n                });\n            }\n\n            // get next month start\n            monthStartDate = DateHelper.getNext(monthStartDate, 'month', interval);\n            monthEndDate   = new Date(DateHelper.getNext(monthStartDate, 'month', 1) - 1);\n        }\n\n    }\n\n}\n","/**\n * @module Scheduler/data/util/recurrence/YearlyRecurrenceIterator\n */\n\nimport AbstractRecurrenceIterator from './AbstractRecurrenceIterator.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\n\n/**\n * A class which provides iteration to call a function for dates specified by a\n * {@link Scheduler.model.RecurrenceModel RecurrenceModel} over a specified date range.\n * @private\n */\nexport default class YearlyRecurrenceIterator extends AbstractRecurrenceIterator {\n\n    static frequency = 'YEARLY'\n\n    /**\n     * Iterates over the passed date range, calling the passed callback on each date on which\n     * starts an event which matches the passed recurrence rule and overlaps the start and end dates.\n     * @param {Object} config An object which describes how to iterate.\n     * @param {Date} config.startDate The point in time to begin iteration.\n     * @param {Date} config.endDate The point in time to end iteration.\n     * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range\n     * will be visited. Pass `true` to only visit occurrences which *start* in the date range.\n     * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.\n     * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.\n     * @param {Date} config.fn.date The occurrence date.\n     * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.\n     * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.\n     */\n    static forEachDate(config) {\n        const\n            {\n                startOnly,\n                startDate,\n                endDate,\n                timeSpan,\n                timeSpanStart,\n                earliestVisibleDate,\n                durationMS,\n                spansStart,\n                recurrence,\n                fn,\n                extraArgs,\n                scope = this\n            }              = this.processIterationConfig(config),\n            {\n                interval,\n                days,\n                count,\n                positions\n            } = recurrence,\n            weekDays       = DayRuleEncoder.decode(days),\n            hasPositions   = positions && positions.length,\n            processedDate  = {};\n\n        let\n            { months }     = recurrence,\n            counter        = 0,\n            i, occurrenceDate, dates, yearStartDate, yearEndDate, weekDayPosition;\n\n        // if the recurrence is limited w/ \"Count\" or not every interval should match\n        // we need to 1st count passed occurrences so we always start iteration from the event start date\n        yearStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, 'year');\n        yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);\n\n        months && months.sort((a, b) => a - b);\n\n        // if no months provided let's use the event month\n        if (!(months && months.length) && !(weekDays && weekDays.length)) {\n            months = [timeSpanStart.getMonth() + 1];\n        }\n\n        if (weekDays && weekDays.length) {\n            // Collect hash of positions indexed by week days\n            weekDays.forEach(day => {\n                if (day[1]) {\n                    weekDayPosition         = weekDayPosition || {};\n                    weekDayPosition[day[0]] = day[1];\n                }\n            });\n        }\n\n        while ((!endDate || endDate > yearStartDate) && (!count || counter < count)) {\n\n            dates = [];\n\n            if (weekDays && weekDays.length) {\n\n                weekDays.forEach(day => {\n                    const weekDay = day[0];\n\n                    let\n                        from = 1,\n                        till = 53;\n\n                    // if position provided\n                    if (day[1]) {\n                        from = till = day[1];\n                    }\n\n                    for (i = from; i <= till; i++) {\n                        if ((occurrenceDate = this.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i))) {\n                            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n\n                            if (!processedDate[occurrenceDate.getTime()]) {\n                                // remember we processed the date\n                                processedDate[occurrenceDate.getTime()] = true;\n\n                                dates.push(occurrenceDate);\n                            }\n                        }\n                    }\n                });\n\n                dates.sort((a, b) => a - b);\n\n                if (!hasPositions) {\n                    for (i = 0; i < dates.length; i++) {\n                        occurrenceDate = dates[i];\n\n                        if (occurrenceDate >= timeSpanStart) {\n                            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);\n\n                            counter++;\n\n                            if (inView &&\n                                ((endDate && occurrenceDate >= endDate) ||\n                                (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                                (count && counter >= count))\n                            ) {\n                                return;\n                            }\n                        }\n                    }\n                }\n\n            }\n            else {\n                for (i = 0; i < months.length; i++) {\n\n                    if ((occurrenceDate = this.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate()))) {\n                        occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);\n\n                        // check if the date wasn't iterated over yet\n                        if (!processedDate[occurrenceDate.getTime()]) {\n                            processedDate[occurrenceDate.getTime()] = true;\n\n                            if (hasPositions) {\n                                dates.push(occurrenceDate);\n                            }\n                            else if (occurrenceDate >= timeSpanStart) {\n                                const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n\n                                counter++;\n\n                                if (inView &&\n                                    ((endDate && occurrenceDate >= endDate) ||\n                                    (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false) ||\n                                    (count && counter >= count))\n                                ) {\n                                    return;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n\n            if (hasPositions && dates.length) {\n                this.forEachDateAtPositions(dates, positions, occurrenceDate => {\n                    if (occurrenceDate >= timeSpanStart) {\n                        const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);\n\n                        counter++;\n\n                        // Ignore dates outside of the [startDate, endDate] range\n                        if (inView && (!endDate || occurrenceDate < endDate)) {\n                            // return false if it's time to stop recurring\n                            if (fn.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || (count && counter >= count)) {\n                                return false;\n                            }\n                        }\n                    }\n                });\n            }\n\n            // get next month start\n            yearStartDate = DateHelper.getNext(yearStartDate, 'year', interval);\n            yearEndDate   = new Date(DateHelper.getNext(yearStartDate, 'year', 1) - 1);\n        }\n\n    }\n}\n","import Model from '../../Core/data/Model.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport RecurrenceDayRuleEncoder from '../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport DailyRecurrenceIterator from '../data/util/recurrence/DailyRecurrenceIterator.js';\nimport WeeklyRecurrenceIterator from '../data/util/recurrence/WeeklyRecurrenceIterator.js';\nimport MonthlyRecurrenceIterator from '../data/util/recurrence/MonthlyRecurrenceIterator.js';\nimport YearlyRecurrenceIterator from '../data/util/recurrence/YearlyRecurrenceIterator.js';\n\n/**\n * @module Scheduler/model/RecurrenceModel\n */\n\nconst recurrenceIterators = {};\n\n[DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator].forEach(it => {\n    recurrenceIterators[it.frequency] = it;\n});\n\nfunction convertStringOfIntegerItemsValue(value) {\n    if (value) {\n        if (typeof value == 'string') {\n            value = value.split(',').map(item => parseInt(item, 10));\n        }\n    }\n    else {\n        value = null;\n    }\n\n    return value;\n}\n\nfunction convertStringOfItemsValue(value) {\n    if (value) {\n        if (typeof value == 'string') {\n            value = value.split(',');\n        }\n    }\n    else {\n        value = null;\n    }\n\n    return value;\n}\n\nfunction isEqualAsString(value1, value2) {\n    return String(value1) === String(value2);\n}\n\nfunction convertInteger(value) {\n    if (this.defaultValue && value === undefined) {\n        return this.defaultValue;\n    }\n\n    if (this.allowNull && value == null) {\n        return null;\n    }\n\n    value = parseInt(value);\n\n    return isNaN(value) ? undefined : value;\n}\n\n/**\n * This class represents a timespan recurrence settings.\n * It is a subclass of {@link Core.data.Model} class.\n * Please refer to the documentation for that class to become familiar with the base interface of this class.\n *\n * The data source for these fields can be customized by subclassing this class.\n *\n * @extends Core/data/Model\n */\nexport default class RecurrenceModel extends Model {\n\n    static get $name() {\n        return 'RecurrenceModel';\n    }\n\n    /**\n     * Indicates that this is a `RecurrenceModel` class instance\n     * (allows to avoid using `instanceof`).\n     * @property {Boolean}\n     * @readonly\n     */\n    get isRecurrenceModel() {\n        return true;\n    }\n\n    //region Fields\n    static get fields() {\n        return [\n            /**\n             * Field defines the recurrence frequency. Supported values are: `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.\n             * @field {'DAILY'|'WEEKLY'|'MONTHLY'|'YEARLY'} frequency\n             */\n            { name : 'frequency', defaultValue : 'DAILY' },\n            /**\n             * Field defines how often the recurrence repeats.\n             * For example, if the recurrence is weekly its interval is 2, then the timespan repeats every two weeks.\n             * @field {Number} interval\n             */\n            { name : 'interval', defaultValue : 1, convert : convertInteger },\n            /**\n             * End date of the recurrence. Specifies when the recurrence ends.\n             * The value is optional, the recurrence can as well be stopped using {@link #field-count} field value.\n             * @field {Date} endDate\n             */\n            { name : 'endDate', type : 'date' },\n            /**\n             * Specifies the number of occurrences after which the recurrence ends.\n             * The value includes the associated timespan itself so values less than 2 make no sense.\n             * The field is optional, the recurrence as well can be stopped using {@link #field-endDate} field value.\n             * @field {Number} count\n             */\n            { name : 'count', allowNull : true, convert : convertInteger },\n            /**\n             * Specifies days of the week on which the timespan should occur.\n             * An array of string values `SU`, `MO`, `TU`, `WE`, `TH`, `FR`, `SA`\n             * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.\n             * Each value can also be preceded by a positive (+n) or negative (-n) integer.\n             * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.\n             *\n             * **Not applicable** for daily {@link #field-frequency}.\n             * @field {String[]} days\n             */\n            {\n                name    : 'days',\n                convert : convertStringOfItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * Specifies days of the month on which the timespan should occur.\n             * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).\n             * **Applicable only** for monthly {@link #field-frequency}.\n             * @field {Number[]} monthDays\n             */\n            {\n                name    : 'monthDays',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * Specifies months of the year on which the timespan should occur.\n             * An array of integer values (1 - 12).\n             * **Applicable only** for yearly {@link #field-frequency}.\n             * @field {Number[]} months\n             */\n            {\n                name    : 'months',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            },\n            /**\n             * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.\n             * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).\n             * **Not applicable** for daily {@link #field-frequency}.\n             * @field {Number} positions\n             */\n            {\n                name    : 'positions',\n                convert : convertStringOfIntegerItemsValue,\n                isEqual : isEqualAsString\n            }\n        ];\n    }\n\n    get dateFormat() {\n        return this._dateFormat || 'YYYYMMDDTHHmmss';\n    }\n\n    set dateFormat(format) {\n        this._dateFormat = format;\n    }\n\n    get recurrenceIterator() {\n        //<debug>\n        if (!recurrenceIterators[this.frequency]) {\n            throw new Error(`Can't find iterator for ${this.frequency} frequency`);\n        }\n        //</debug>\n\n        return recurrenceIterators[this.frequency];\n    }\n\n    /**\n     * The timespan this recurrence is associated with.\n     * @property {Scheduler.model.TimeSpan}\n     */\n    get timeSpan() {\n        return this._timeSpan;\n    }\n\n    set timeSpan(value) {\n        this._timeSpan = value;\n    }\n\n    /**\n     * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format\n     * (\"RRULE\" expression).\n     * @property {String}\n     */\n    get rule() {\n        const\n            me     = this,\n            result = [];\n\n        if (me.frequency) {\n            result.push(`FREQ=${me.frequency}`);\n\n            if (me.interval > 1) {\n                result.push(`INTERVAL=${me.interval}`);\n            }\n            if (me.days && me.days.length) {\n                result.push('BYDAY=' + me.days.join(','));\n            }\n            if (me.monthDays && me.monthDays.length) {\n                result.push('BYMONTHDAY=' + me.monthDays.join(','));\n            }\n            if (me.months && me.months.length) {\n                result.push('BYMONTH=' + me.months.join(','));\n            }\n            if (me.count) {\n                result.push(`COUNT=${me.count}`);\n            }\n            if (me.endDate) {\n                result.push('UNTIL=' + DateHelper.format(me.endDate, me.dateFormat));\n            }\n            if (me.positions && me.positions.length) {\n                result.push('BYSETPOS=' + me.positions.join(','));\n            }\n        }\n\n        return result.join(';');\n    }\n\n    set rule(rule) {\n        const\n            me     = this,\n            values = {\n                frequency : null,\n                interval  : null,\n                count     : null,\n                endDate   : null,\n                days      : null,\n                monthDays : null,\n                months    : null,\n                positions : null\n            };\n\n        me.beginBatch();\n\n        if (rule) {\n            const parts = rule.split(';');\n\n            for (let i = 0, len = parts.length; i < len; i++) {\n                const\n                    part = parts[i].split('='),\n                    value  = part[1];\n\n                switch (part[0]) {\n                    case 'FREQ':\n                        values.frequency = value;\n                        break;\n                    case 'INTERVAL':\n                        values.interval = value;\n                        break;\n                    case 'COUNT':\n                        values.count = value;\n                        values.until = null;\n                        break;\n                    case 'UNTIL':\n                        if (value) {\n                            values.endDate = DateHelper.parse(value, me.dateFormat);\n                        }\n                        else {\n                            values.endDate = null;\n                        }\n                        values.count = null;\n                        break;\n                    case 'BYDAY':\n                        values.days = value;\n                        break;\n                    case 'BYMONTHDAY':\n                        values.monthDays = value;\n                        break;\n                    case 'BYMONTH':\n                        values.months = value;\n                        break;\n                    case 'BYSETPOS':\n                        values.positions = value;\n                        break;\n                }\n            }\n        }\n\n        me.set(values);\n\n        if (rule) {\n            me.sanitize();\n        }\n\n        me.endBatch();\n    }\n\n    construct(data = {}) {\n        const\n            me                 = this,\n            { rule, timeSpan } = data;\n\n        me._suspendedTimeSpanNotifying = 0;\n\n        delete data.timeSpan;\n        delete data.rule;\n\n        super.construct(...arguments);\n\n        if (rule) {\n            me.suspendTimeSpanNotifying();\n            me.rule = rule;\n            me.resumeTimeSpanNotifying();\n        }\n\n        me.timeSpan = timeSpan;\n    }\n\n    /**\n     * Iterate occurrences for the owning timespan across the specified date range. This method can be called even\n     * if the timespan is not yet a member of a store, however, the occurrences returned will not be cached across\n     * subsequent calls to this method.\n     * @param {Date} startDate The start date of the iteration.\n     * @param {Date} endDate The end date of the iteration.\n     * @param {Function} fn The function to call for each occurrence.\n     * @param {Scheduler.model.TimeSpan} fn.occurrence The occurrence.\n     * @param {Boolean} fn.first A flag which is `true` for the first occurrence of this recurrence.\n     * @param {Number} fn.counter A counter of how many dates have been visited in this iteration.\n     * @param {Date} fn.date The occurrence date.\n     * @internal\n     */\n    forEachOccurrence(startDate, endDate, fn) {\n        if (this.timeSpan.startDate) {\n            this.recurrenceIterator.forEachDate({\n                recurrence : this,\n                startDate,\n                endDate,\n\n                fn(date, counter, first, timeSpan) {\n                    return fn(timeSpan.buildOccurrence(date, first), first, counter, date);\n                }\n            });\n        }\n    }\n\n    /**\n     * Cleans up fields that do not makes sense for the current {@link #field-frequency} value.\n     * @private\n     */\n    sanitize() {\n        const\n            me                = this,\n            timeSpanStartDate = me.timeSpan?.startDate,\n            values            = {};\n\n        me.isSanitizing = true;\n\n        switch (me.frequency) {\n            case 'DAILY' :\n                values.positions    = null;\n                values.days         = null;\n                values.monthDays    = null;\n                values.months       = null;\n                break;\n\n            case 'WEEKLY' : {\n                values.positions = null;\n                values.monthDays = null;\n                values.months = null;\n\n                const { days } = me;\n\n                if (timeSpanStartDate && days?.length === 1 && days[0] === RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {\n                    values.days = null;\n                }\n                break;\n            }\n\n            case 'MONTHLY' : {\n                if (me.monthDays?.length) {\n                    values.positions = null;\n                    values.days = null;\n                }\n\n                values.months = null;\n\n                const { monthDays } = me;\n\n                if (timeSpanStartDate && monthDays?.length === 1 && monthDays[0] === timeSpanStartDate.getDate()) {\n                    values.monthDays = null;\n                }\n                break;\n            }\n\n            case 'YEARLY' : {\n                values.monthDays = null;\n\n                const { months } = me;\n\n                if (timeSpanStartDate && months?.length === 1 && months[0] === timeSpanStartDate.getMonth() + 1) {\n                    values.months = null;\n                }\n                break;\n            }\n        }\n\n        me.set(values);\n\n        me.isSanitizing = false;\n    }\n\n    copy(...args) {\n        const result = super.copy(...args);\n\n        result.dateFormat = this.dateFormat;\n        result.timeSpan   = this.timeSpan;\n\n        return result;\n    }\n\n    afterChange(toSet, wasSet, silent) {\n        const\n            result       = super.afterChange(toSet, wasSet, silent),\n            { timeSpan } = this;\n\n        if (!this.isSanitizing) {\n            // cleanup data to match the chosen frequency\n            this.sanitize();\n        }\n\n        if (timeSpan) {\n            timeSpan.sanitizeRecurrenceData(this);\n\n            if (!this.isTimeSpanNotifyingSuspended) {\n                timeSpan.onRecurrenceChanged();\n            }\n        }\n\n        return result;\n    }\n\n    set(field, value, ...args) {\n        const values = typeof field === 'object' ? field : { [field] : value };\n\n        // reset \"endDate\" field if \"count\" is being set\n        if (values.count) {\n            values.endDate = null;\n        }\n        // reset \"count\" field if \"endDate\" is being set\n        else if (values.endDate) {\n            values.count = null;\n        }\n\n        super.set(values, undefined, ...args);\n    }\n\n    get isTimeSpanNotifyingSuspended() {\n        return Boolean(this._suspendedTimeSpanNotifying);\n    }\n\n    suspendTimeSpanNotifying() {\n        this._suspendedTimeSpanNotifying++;\n    }\n\n    resumeTimeSpanNotifying() {\n        if (this._suspendedTimeSpanNotifying) this._suspendedTimeSpanNotifying--;\n    }\n}\n","import TimeSpan from '../TimeSpan.js';\nimport RecurrenceModel from '../RecurrenceModel.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AbstractRecurrenceIterator from '../../data/util/recurrence/AbstractRecurrenceIterator.js';\n\nfunction convertExceptionDatesValue(value) {\n    const\n        result         = {},\n        { dateFormat } = this;\n\n    if (value) {\n        value = typeof value == 'string' ? value.split(',') : ArrayHelper.asArray(value);\n\n        value.forEach(item => {\n            if (typeof item == 'string') {\n                item = DateHelper.parse(item, dateFormat);\n            }\n\n            // If we've got a valid date out of the incoming item, add an exception key\n            if (!isNaN(item)) {\n                result[DateHelper.makeKey(item)] = 1;\n            }\n        });\n    }\n\n    return result;\n}\n\nfunction serializeExceptionDatesValue(value) {\n    const\n        result         = [],\n        { dateFormat } = this;\n\n    for (const date in value) {\n        if (value[date]) {\n            result.push(DateHelper.format(DateHelper.parseKey(date), dateFormat));\n        }\n    }\n\n    return result;\n}\n\nconst emptyArray = [];\n\n/**\n * @module Scheduler/model/mixin/RecurringTimeSpan\n */\n\n/**\n * This mixin class provides recurrence related fields and methods to a {@link Scheduler.model.TimeSpan timespan model}.\n *\n * The mixin introduces two types of timespans: __recurring timespan__ and its __occurrences__.\n * __Recurring timespan__ is a timespan having {@link #field-recurrenceRule recurrence rule} specified and its __occurrences__ are \"fake\" dynamically generated timespans.\n * Their set depends on the scheduler visible timespan and changes upon the timespan change.\n *\n * There are few methods allowing to distinguish a recurring event and an occurrence: {@link #property-isRecurring}, {@link #property-isOccurrence}\n * and {@link #property-recurringTimeSpan} (returns the event this record is an occurrence of).\n *\n * The {@link #field-recurrenceRule recurrence rule} defined for the event is parsed and\n * represented with {@link Scheduler.model.RecurrenceModel RecurrenceModel} class (can be changed by setting {@link #property-recurrenceModel} property) instance.\n * See: {@link #property-recurrence} property.\n * @mixin\n * @mixinbase TimeSpan\n */\nexport default Target => class RecurringTimeSpan extends (Target || TimeSpan) {\n    static get $name() {\n        return 'RecurringTimeSpan';\n    }\n\n    /**\n     * Returns `true` if this timespan supports recurring.\n     * @property {Boolean}\n     * @category Recurrence\n     */\n    get supportsRecurring() {\n        return true;\n    }\n\n    static get fields() {\n        return [\n            /**\n             * The timespan recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10)\n             * described format (\"RRULE\" expression).\n             * @field {String} recurrenceRule\n             * @category Scheduling\n             */\n            {\n                name     : 'recurrenceRule',\n                internal : true\n            },\n            /**\n             * A string (either a single date or multiple dates separated by comma) or an array of strings containing\n             * the timespan exception dates. The dates that must be skipped when generating occurrences for a repeating\n             * timespan. This is used to modify only individual occurrences of the timespan so the further regenerations\n             * won't create another copy of this occurrence again.\n             *\n             * ```javascript\n             * {\n             *     id: 7,\n             *     startDate: '2021-10-12T14:00:00',\n             *     endDate: '2021-10-12T15:00:00',\n             *     name: 'Lunch',\n             *     resourceId: 'hotel',\n             *     recurrenceRule: 'FREQ=DAILY;COUNT=5',\n             *     exceptionDates: ['2021-10-14']\n             * }\n             * ```\n             *\n             * Use {@link #function-addExceptionDate} method to add an individual entry to the dates array:\n             *\n             * ```javascript\n             * // Break the link between the occurrence and its base.\n             * // This also adds the occurrence date as an exception date\n             * // so that the base timespan knows that this date should be skipped when regenerating its occurrences.\n             * occurrence.recurringTimeSpan = null;\n             *\n             * // now the occurrence is an individual record that can be changed & persisted freely\n             * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));\n             * ```\n             * **Note:** The dates in this field get automatically removed when the event changes its {@link Scheduler.model.TimeSpan#field-startDate start date}.\n             *\n             * @field {String|String[]} exceptionDates\n             * @category Scheduling\n             */\n            {\n                name      : 'exceptionDates',\n                convert   : convertExceptionDatesValue,\n                serialize : serializeExceptionDatesValue,\n                internal  : true\n            }\n        ];\n    }\n\n    /**\n     * Override of {@link Core/data/Model}'s method. If an {@link #property-isOccurrence}\n     * is passed, it is detached from its parent recurring event. If it still has a recurrence\n     * then the recurring event is changed to stop at the occurrence date. If it has no recurrence\n     * an exception is added at the occurrence date.\n     * @category Recurrence\n     */\n    remove() {\n        if (this.isOccurrence) {\n            const\n                me = this,\n                { recurringTimeSpan } = me;\n\n            me.cancelBatch();\n            recurringTimeSpan.beginBatch();\n            me.detachFromRecurringEvent();\n            recurringTimeSpan.endBatch();\n        }\n        else {\n            return super.remove(...arguments);\n        }\n    }\n\n    get eventStore() {\n        let result = this.isOccurrence ? this.recurringEvent.eventStore : super.eventStore;\n\n        // Recurrence methods are called on `eventStore`, but in case we have a regular\n        // store with recurrence mixin, we won't event store and should return own\n        // store instead\n        if (!result && this.firstStore?.isRecurringTimeSpansMixin) {\n            result = this.firstStore;\n        }\n\n        return result;\n    }\n\n    /**\n     * Name of the class representing the recurrence model, defaults to {@link Scheduler.model.RecurrenceModel}\n     * @property {String}\n     * @category Recurrence\n     */\n    get recurrenceModel() {\n        return this._recurrenceModel || RecurrenceModel;\n    }\n\n    set recurrenceModel(model) {\n        this._recurrenceModel = model;\n    }\n\n    /**\n     * Sets a recurrence for the timespan with a given frequency, interval, and end.\n     * @param {RecurrenceModelConfig|String|Scheduler.model.RecurrenceModel} recurrence A data object for an instance of\n     * {@link Scheduler.model.RecurrenceModel}. May also be the frequency string: `DAILY`, `WEEKLY`, `MONTHLY`, or\n     * `YEARLY`.\n     *\n     * ```javascript\n     * // repeat the event every other week till Jan 2 2039\n     * event.setRecurrence({\n     *     frequency : \"WEEKLY\",\n     *     interval  : 2,\n     *     endDate   : new Date(2039, 0, 2)\n     * });\n     * ```\n     *\n     * Also a {@link Scheduler.model.RecurrenceModel recurrence model} can be provided as the only argument for this\n     * method:\n     *\n     * ```javascript\n     * const recurrence = new RecurrenceModel({ frequency : 'DAILY', interval : 5 });\n     *\n     * event.setRecurrence(recurrence);\n     * ```\n     *\n     * or\n     *\n     * ```javascript\n     * event.setRecurrence(\"WEEKLY\", 2, new Date(2039, 0, 2));\n     * ```\n     * @param {Number} [interval] The interval between occurrences (instances of this recurrence). For example, a daily\n     * recurrence with an interval of 2 occurs every other day. Must be greater than 0.\n     * @param {Number|Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a\n     * maximum count of occurrences (has to greater than 1, since 1 means the event itself).\n     * @category Recurrence\n     */\n    setRecurrence(recurrence, interval, recurrenceEnd) {\n        const me = this;\n\n        let recurrenceRule;\n\n        if (recurrence) {\n            if (!recurrence.isRecurrenceModel) {\n                if (typeof recurrence === 'string') {\n                    recurrence = {\n                        frequency : recurrence\n                    };\n\n                    if (interval) {\n                        recurrence.interval = interval;\n                    }\n\n                    // If the recurrence is limited\n                    if (recurrenceEnd) {\n                        if (recurrenceEnd instanceof Date) {\n                            recurrence.endDate = recurrenceEnd;\n                        }\n                        else {\n                            recurrence.count = recurrenceEnd;\n                        }\n                    }\n                }\n                recurrence = new me.recurrenceModel(recurrence);\n            }\n\n            // The RecurrenceModel has a reference to its owning recurring event.\n            // It uses this to remove the owning event's exceptions after its new endDate\n            // whenever its endDate is changed.\n            recurrence.timeSpan = me;\n\n            recurrenceRule = recurrence.rule;\n        }\n\n        me.recurrence     = recurrence;\n        me.recurrenceRule = recurrenceRule;\n    }\n\n    /**\n     * The recurrence model used for the timespan.\n     * @property {Scheduler.model.RecurrenceModel}\n     * @category Recurrence\n     */\n    get recurrence() {\n        const\n            me = this,\n            rule = me.recurrenceRule;\n\n        if (!me._recurrence && rule) {\n            me._recurrence = new me.recurrenceModel({ rule, timeSpan : me, id : `${me.id}-recurrence` });\n        }\n\n        return me._recurrence;\n    }\n\n    set recurrence(recurrence) {\n        const me = this;\n\n        me._recurrence = recurrence;\n\n        if (recurrence) {\n            // bind recurrence instance to the model\n            recurrence.timeSpan = me;\n            me.recurrenceRule   = recurrence.rule;\n        }\n        else {\n            // If this is being done to an occurrence, it's a signal that we are being\n            // mutated into an exception. Apply the change immediately, directly to the data.\n            if (me.isOccurrence) {\n                me.setData('recurrenceRule', null);\n            }\n            else {\n                me.recurrenceRule = null;\n            }\n        }\n    }\n\n    /**\n     * Indicates if the timespan is recurring.\n     * @property {Boolean}\n     * @readonly\n     * @category Recurrence\n     */\n    get isRecurring() {\n        // MUST evaluate in this order so that if it is an occurrence,\n        // the recurrence getter does not refresh the rule\n        return Boolean(!this.isOccurrence && this.recurrence);\n    }\n\n    /**\n     * Indicates if the timespan is an occurrence of another recurring timespan.\n     * @property {Boolean}\n     * @readonly\n     * @category Recurrence\n     */\n    get isOccurrence() {\n        return Boolean(this.recurringTimeSpan);\n    }\n\n    /**\n     * The \"main\" timespan this model is an occurrence of. For non-occurrences returns `null`.\n     * @property {Scheduler.model.TimeSpan}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get recurringTimeSpan() {\n        return this._recurringTimeSpan;\n    }\n\n    get isPersistable() {\n        return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence);\n    }\n\n    set recurringTimeSpan(recurringTimeSpan) {\n        this._recurringTimeSpan = recurringTimeSpan;\n    }\n\n    /**\n     * Returns the occurrences of this event over the specified time range. If the first\n     * occurrence is in the time range `*this*` record is included in that position.\n     * @param {Date} startDate The start date of the range for which to include occurrences.\n     * @param {Date} [endDate] The end date of the range for which to include occurrences.\n     * Defaults to the startDate.\n     * @returns {Scheduler.model.TimeSpan[]} The array of occurrences which occur over the specified range.\n     * @category Recurrence\n     */\n    getOccurrencesForDateRange(startDate, endDate = startDate) {\n        return this.eventStore.getOccurrencesForTimeSpan(this, startDate, endDate);\n    }\n\n    /**\n     * Array of this recurring timespan's cached occurrences. __Not including the owning recurring\n     * event__.\n     *\n     * Empty if the timespan is not recurring.\n     *\n     * __Note that this is an internal accessor and is cleared whenever changes are made to the\n     * owning recurring event__.\n     * @property {Scheduler.model.TimeSpan[]}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get occurrences() {\n        if (this.isRecurring) {\n            const result = [];\n\n            // The occurrencesMap contains entries for each occurrence date.\n            this.occurrenceMap.forEach(occurrence => {\n                if (occurrence !== this) {\n                    result.push(occurrence);\n                }\n            });\n\n            return result;\n        }\n\n        return emptyArray;\n    }\n\n    /**\n     * A Map, keyed by each date an occurrence intersects, of occurrences of this event.\n     * @property {Map}\n     * @readonly\n     * @internal\n     * @category Recurrence\n     */\n    get occurrenceMap() {\n        return this._occurrencesMap || (this._occurrencesMap = new Map());\n    }\n\n    /**\n     * Removes an occurrence from this recurring timespan's cached occurrences.\n     * @param dateOrTimeSpan occurrence date or occurrence TimeSpan\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrence(dateOrTimeSpan) {\n        const date = dateOrTimeSpan.isTimeSpan ? dateOrTimeSpan.occurrenceDate : dateOrTimeSpan;\n\n        // Clear the occurrences *is* we are in an EventStore.\n        this.eventStore?.globalOccurrences.delete(this.createRecurrenceKey(date));\n        // Remove occurrence from its by-startDate cache\n        this.occurrenceMap.delete(DateHelper.makeKey(date));\n    }\n\n    /**\n     * Removes all cached occurrences on or after the passed date from this recurring timespan's cached occurrences.\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrencesFrom(date) {\n        this.occurrenceMap.forEach((occurrence, dateKey) => {\n            if (DateHelper.parseKey(dateKey) >= date) {\n                this.removeOccurrence(occurrence);\n            }\n        });\n    }\n\n    /**\n     * Removes this recurring timespan's cached occurrences.\n     * @internal\n     * @category Recurrence\n     */\n    removeOccurrences() {\n        // This recurring event must also be removed from the occurrenceMap if it's there\n        // So insert it as the first element. Can also be found from the store's global occurrence\n        // Map using [...this.eventStore.globalOccurrences.keys()].filter(e => e.startsWith(`_generated:${this.id}`))\n        [this, ...this.occurrences].forEach(occurrence => this.removeOccurrence(occurrence));\n    }\n\n    /**\n     * The method is triggered when the timespan recurrence settings get changed.\n     * It updates the {@link #field-recurrenceRule} field in this case.\n     * @internal\n     * @category Recurrence\n     */\n    onRecurrenceChanged() {\n        this.recurrenceRule = this.recurrence?.rule || null;\n    }\n\n    sanitizeRecurrenceData(recurrence = this.recurrence) {\n        // Remove all exceptionsDates that our owning timeSpan had that are\n        // now after our end date and therefore redundant.\n        if (recurrence.endDate) {\n            const\n                endDate            = DateHelper.clearTime(recurrence.endDate),\n                { exceptionDates } = this;\n\n            // Clear any now-invalid cached occurrences\n            this.removeOccurrencesFrom(endDate);\n\n            // If we had any exceptions on or after this date, remove them.\n            if (exceptionDates) {\n                for (const dateKey in exceptionDates) {\n                    const exceptionDate = DateHelper.parseKey(dateKey);\n\n                    if (exceptionDate >= endDate) {\n                        delete exceptionDates[dateKey];\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * The original {@lScheduler.model.TimeSpan#field-startDate startDate} of this event before any modifications\n     * took place. Used by {@link #function-removeOccurrence} and {@link #function-detachFromRecurringEvent}\n     * @internal\n     * @readonly\n     * @category Recurrence\n     */\n    get occurrenceDate() {\n        return this.meta.modified?.startDate || this.startDate;\n    }\n\n    /**\n     * If this event is an {@link #property-isOccurrence occurrence} of a recurring event, then this\n     * property yields its zero-based occurrence index in the sequence.\n     * @property {Number}\n     * @readonly\n     * @category Recurrence\n     */\n    get occurrenceIndex() {\n        return AbstractRecurrenceIterator.getOccurrenceIndex(this);\n    }\n\n    /**\n     * Builds an occurrence of this recurring event by cloning the timespan data.\n     * The method is used internally by the __RecurringTimeSpans__ mixin.\n     * Override it if you need to customize the generated occurrences.\n     *\n     * If the date requested is the start date of the event sequence, `this`\n     * record is returned. All runs of recurring events begin with the base record.\n     * @param  {Date} occurrenceDate The occurrence start date.\n     * @param  {Boolean} isFirst `true` if this is the first occurrence.\n     * @returns {Scheduler.model.TimeSpan} The occurrence.\n     * @internal\n     * @category Recurrence\n     */\n    buildOccurrence(occurrenceDate, isFirst) {\n        const\n            me                    = this,\n            {\n                occurrenceMap,\n                recurrence,\n                meta\n            }                     = me,\n            globalOccurrences     = me.eventStore?.globalOccurrences,\n            occurrenceKey         = DateHelper.makeKey(occurrenceDate),\n            id                    = me.createRecurrenceKey(occurrenceDate, occurrenceKey),\n            onStartDate           = !(occurrenceDate - me.startDate),\n            { fieldMap }          = me.constructor;\n\n        // An occurrence has a unique ID which identifies it by its base recurring event and its time.\n        let occurrence   = globalOccurrences?.get(id),\n            { duration } = me;\n\n        // If there's no duration, or it's an all day event (which makes the event ceil and floor its\n        // start and end dates, but does *NOT* as of 27/5/2020 adjust its duration) then\n        // we calculate the duration of the occurrence.\n        if (me.endDate && (me.allDay || !duration)) {\n            duration = DateHelper.as(me.durationUnit, me.endDate.getTime() - me.startDate.getTime());\n        }\n\n        // Don't let NaN in record data\n        const occurrenceEndDate = duration !== undefined ? DateHelper.add(occurrenceDate, duration, me.durationUnit) : undefined;\n\n        if (!occurrence) {\n            // If this is the first occurrence (start times may not match), or it's right on the start\n            // then this recurring event *IS* the occurrence\n            if (isFirst || onStartDate) {\n                occurrence = me;\n\n                // We are the first occurrence.\n                // But if our start time is not as the rule requires, adjust ourself *silently*\n                if (!onStartDate) {\n                    me.setStartEndDate(occurrenceDate, occurrenceEndDate, true);\n                    // Since we've changed the event start date the recurrence \"Days\"/\"MonthDays\"/\"Months\"\n                    // might get redundant in case the event start date matches the fields values\n                    // Calling recurrence sanitize() will clean the fields in this case.\n                    recurrence.suspendTimeSpanNotifying();\n                    recurrence.sanitize();\n                    recurrence.resumeTimeSpanNotifying();\n                }\n\n                // Either way, because of adjustment above, or initial correctness, we are in sync\n                // with our recurrence rule. A RecurrenceIterator is now able to calculate a correct\n                // UNTIL date from a COUNT value. See AbstractRecurrenceIterator#processIterationConfig\n                meta.isSyncedWithRule = true;\n            }\n            // Generate an occurrence which references this as its parent\n            else {\n                occurrence = me.copy(\n                    {\n                        [fieldMap.id.dataSource]        : id,\n                        [fieldMap.startDate.dataSource] : occurrenceDate,\n                        [fieldMap.endDate.dataSource]   : occurrenceEndDate,\n                        [fieldMap.duration.dataSource]  : duration,\n                        constraintDate                  : null,\n                        constraintType                  : null\n                    },\n                    { creatingOccurrence : true }\n                );\n\n                occurrence.recurringTimeSpan = me;\n            }\n\n            globalOccurrences?.set(id, occurrence);\n\n            // A recurring timespan keeps a by-startDate index of occurrences.\n            // And itself will be among those.\n            occurrenceMap.set(occurrenceKey, occurrence);\n        }\n\n        return occurrence;\n    }\n\n    createRecurrenceKey(date = this.startDate, dateKey = null) {\n        return `_generated:${this.id}:${dateKey || DateHelper.makeKey(date)}`;\n    }\n\n    // Converts this occurrence to a new \"master\" event\n    convertToRealEvent(wasSet, silent) {\n        if (!this.isOccurrence) {\n            return;\n        }\n\n        const\n            me = this,\n            {\n                recurringTimeSpan,\n                resource,\n                occurrenceIndex,\n                recurrence\n            }               = me,\n            count           = recurrence && recurringTimeSpan.recurrence.count,\n            // resourceRecords is a temporary property of occurrence events to handle cases\n            // if only resources has been updated. (change only resources won't mark record as dirty)\n            newResource     = wasSet?.resourceRecords?.value || me.data.newResource;\n\n        recurringTimeSpan.beginBatch();\n\n        me.detachFromRecurringEvent();\n\n        me.clearChanges();\n\n        // Must silently set our own ID, not be the key generated from our parent id and occurrence date.\n        // Must not result in the id field being in the modified state.\n        me.setData('id', me.generateId(recurringTimeSpan.eventStore));\n\n        if (newResource) {\n            // clear resourceId to avoid auto-adding to assignmentStore, it is handled manually bellow\n            delete me.data.resourceId;\n        }\n\n        // The impending changes to the former parent recurring event trigger a full refresh.\n        recurringTimeSpan.eventStore.add(me, silent);\n\n        // Ensure that the original count is honoured.\n        // If we are the 8th occurrence of 10, OUR repeat count must be 3.\n        if (count) {\n            me.recurrence.count = count - occurrenceIndex;\n        }\n\n        if (newResource || resource) {\n            me.assign(newResource || resource);\n        }\n\n        // remove data after apply\n        if (newResource) {\n            delete me.data.resourceRecords;\n        }\n        if (wasSet) {\n            delete wasSet.resourceRecords;\n        }\n\n        // Any change to a recurring events triggers a store refresh event.\n        recurringTimeSpan.endBatch();\n    }\n\n    afterChange(toSet, wasSet, silent, ...args) {\n        const\n            me             = this,\n            { eventStore } = me;\n\n        // reset cached recurrence instance in case \"recurrenceRule\" is changed\n        if ('recurrenceRule' in wasSet) {\n            me._recurrence = null;\n\n            // If we are a recurring event, we must be in the recurringEvents cache.\n            // If we are *not* a recurring event, we must *not* be in there.\n            // An event not yet in a store (eg dragging to create) won't have an eventStore.\n            // eslint-disable-next-line no-unused-expressions\n            eventStore?.recurringEvents[wasSet.recurrenceRule.value ? 'add' : 'delete'](me);\n        }\n\n        // Any change to an occurrence adds it to an event store, at which point\n        // it ceases to be an occurrence.\n        //\n        // If it has a recurrenceRule it becomes the start of a new recurring event series,\n        // and the old owning recurring event stops on the day before.\n        //\n        // If it has no recurrenceRule, it becomes an exception to its owning recurring event.\n        if (me.isOccurrence) {\n            me.convertToRealEvent(wasSet, silent);\n        }\n        // Setting a newException date must mark the exceptionDates as modified\n        else if ('newExceptionDate' in wasSet) {\n            me.meta.modified.exceptionDates = true;\n            delete me.meta.modified.newExceptionDate;\n\n            // Remove any occurrence on that date from our by-startDate cache\n            // and from the global occurrences cache\n            me.removeOccurrence(wasSet.newExceptionDate.value);\n        }\n\n        return super.afterChange(toSet, wasSet, silent, ...args);\n    }\n\n    /**\n     * Detaches an occurrence from its owning recurring event so that it can be added to the eventStore\n     * either as an exception, or as the start of a new recurring sequence.\n     * @internal\n     * @category Recurrence\n     */\n    detachFromRecurringEvent() {\n        const\n            me                                    = this,\n            // For access further down, breaking the link involves engine if trying to get the occurrenceDate later,\n            // resulting in the wrong date\n            { recurringTimeSpan, occurrenceDate, startDate } = me;\n\n        // Break the link\n        me.recurringTimeSpan = null;\n\n        // The occurrenceDate is injected into the data when an occurrence is created.\n        // the recurringTimeSpan's afterChange will remove any cache occurrence\n        // for this date; see above\n        recurringTimeSpan.addExceptionDate(occurrenceDate);\n\n        // If we still have a recurrenceRule, we're being promoted to be a new recurring event.\n        // The recurrence setter applies the rule immediately to occurrences, so this will\n        // always be correct.\n        if (me.recurrenceRule) {\n            // The RecurrenceModel removes occurrences and exceptions after this date\n            recurringTimeSpan.recurrence.endDate = DateHelper.add(startDate, -1, 'minute');\n        }\n    }\n\n    /**\n     * The setter used by Model#inSet when {@link #function-addExceptionDate} is called.\n     * Adding an exception must trigger change processing in a recurring event, so it must\n     * be changed through a {@link Core.data.Model#function-set} call. Also, the change must be batchable\n     * with other changes.\n     * @private\n     * @readonly\n     * @category Recurrence\n     */\n    set newExceptionDate(date) {\n        if (date) {\n            const exceptionDates = this.exceptionDates || (this.exceptionDates = {});\n\n            exceptionDates[DateHelper.makeKey(date)] = 1;\n        }\n    }\n\n    /**\n     * Adds an exception date that should be skipped when generating occurrences for the timespan.\n     * The methods adds an entry to the array kept in {@link #field-exceptionDates} field.\n     * @param {Date} date Exception date.\n     * @internal\n     * @category Recurrence\n     */\n    addExceptionDate(newExceptionDate) {\n        return this.set({\n            newExceptionDate\n        });\n    }\n\n    /**\n     * Does this recurring event have an exception on the passed date.\n     * @param {Date} date The date to find an exception for.\n     * @returns {Boolean} `true` if the event has an exception starting on the passed date.\n     * @category Recurrence\n     */\n    hasException(date) {\n        return this.exceptionDates?.[DateHelper.makeKey(date)];\n    }\n};\n","import DH from '../../../Core/helper/DateHelper.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n\nconst\n    oneDayMS = 1000 * 60 * 60 * 24;\n\n/**\n * @module Scheduler/model/mixin/EventModelMixin\n */\n\n/**\n * Mixin that holds configuration shared between events in Scheduler and Scheduler Pro.\n * @mixin\n */\nexport default Target => class EventModelMixin extends Target {\n    static get $name() {\n        return 'EventModelMixin';\n    }\n\n    // Flag checked by EventStore to make sure it uses a valid subclass\n    static get isEventModel() {\n        return true;\n    }\n\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     *\n     * ```javascript\n     * eventRecord.set('duration', 4);\n     * // eventRecord.endDate is not yet calculated\n     *\n     * await eventRecord.setAsync('duration', 4);\n     * // eventRecord.endDate is calculated\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events. If event is recurring, occurrences won't be updated\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n\n    //region Fields\n\n    static get fields() {\n        return [\n            // TODO: below startDate/endDate/duration fields docs copy-paste should be cleaned up after supporting @localdoc & @inheritdoc combination\n\n            /**\n             * The start date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}\n             * for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * Also note that modifying the `startDate` at runtime will move the event in time, without affecting its\n             * duration (with reservation for other scheduling logic affecting the duration). If you want to change the\n             * `startDate` and `duration`, use {@link Scheduler/model/TimeSpan#function-setStartDate} instead (passing\n             * `false` as the second argument).\n             *\n             * @field {Date} startDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n\n            /**\n             * The end date of a time span (or Event / Task).\n             *\n             * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a\n             * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and\n             * change the dateFormat for this field.\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable} for details.\n             *\n             * Note that the field always returns a `Date`.\n             *\n             * @field {Date} endDate\n             * @accepts {String|Date}\n             * @category Scheduling\n             */\n\n            /**\n             * The numeric part of the timespan's duration (the number of units).\n             *\n             * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable} for details.\n             *\n             * @field {Number} duration\n             * @category Scheduling\n             */\n\n            /**\n             * Property which encapsulates the duration's magnitude and units.\n             * @member {Core.data.Duration} fullDuration\n             * @category Scheduling\n             */\n\n            /**\n             * The unique identifier of a task (mandatory)\n             * @field {String|Number} id\n             * @category Common\n             */\n\n            /**\n             * Id of the resource this event is associated with (only usable for single assignments). We recommend\n             * using assignments in an AssignmentStore over this approach. Internally any Event using `resourceId`\n             * will have an assignment in AssignmentStore generated.\n             * @field {String|Number} resourceId\n             * @category Common\n             */\n            {\n                name     : 'resourceId',\n                internal : true\n            },\n\n            /**\n             * The array of {@link Scheduler.model.ResourceModel resources} which are assigned to this event.\n             * @field {String|Number} resources\n             * @category Common\n             */\n            {\n                name   : 'resources',\n                column : {\n                    type : 'resourceassignment'\n                },\n                persist  : false,\n                internal : true // TODO: remove this when resourcecolumn is in Scheduler\n            },\n\n            /**\n             * Specify false to prevent the event from being dragged (if EventDrag feature is used)\n             * @field {Boolean} draggable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'draggable',\n                type         : 'boolean',\n                persist      : false,\n                defaultValue : true,\n                internal     : true\n            },\n\n            /**\n             * Specify `false` to prevent the event from being resized (if EventResize feature is used). You can also\n             * specify `'start'` or `'end'` to only allow resizing in one direction\n             * @field {Boolean|String} resizable\n             * @default true\n             * @category Interaction\n             */\n            {\n                name         : 'resizable',\n                persist      : false,\n                defaultValue : true,\n                internal     : true\n            }, // true, false, 'start' or 'end'\n\n            /**\n             * A field marking event as all day(s) spanning event.\n             * For example, a holiday day may be represented by a `startDate`, and the `allDay` flag.\n             * @field {Boolean} allDay\n             * @category Scheduling\n             */\n            {\n                name         : 'allDay',\n                type         : 'boolean',\n                defaultValue : false\n            },\n\n            /**\n             * Controls this events appearance, see Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for\n             * available options.\n             * @field {String} eventStyle\n             * @category Styling\n             */\n            {\n                name     : 'eventStyle',\n                internal : true\n            },\n\n            /**\n             * Controls the primary color of the event, see Schedulers\n             * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for\n             * available colors.\n             * @field {String} eventColor\n             * @category Styling\n             */\n            {\n                name     : 'eventColor',\n                internal : true\n            },\n\n            /**\n             * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.\n             * @field {Number} milestoneWidth\n             * @category Styling\n             */\n            {\n                name     : 'milestoneWidth',\n                internal : true\n            },\n\n            /**\n             * Set this field to `false` to opt out of {@link Scheduler.feature.StickyEvents sticky event content}\n             * (keeping event text in view while scrolling).\n             * @field {Boolean} stickyContents\n             * @category Styling\n             */\n            {\n                name     : 'stickyContents',\n                internal : true\n            }\n        ];\n    }\n\n    //endregion\n\n    //region Id change\n\n    updateAssignmentEventIds() {\n        this.assigned.forEach(assignment => {\n            assignment.eventId = this.id;\n        });\n    }\n\n    syncId(value) {\n        super.syncId(value);\n\n        this.updateAssignmentEventIds();\n    }\n\n    //endregion\n\n    //region Resources\n\n    /**\n     * Returns all resources assigned to an event.\n     *\n     * @property {Scheduler.model.ResourceModel[]}\n     * @category Assignments & Resources\n     * @readonly\n     */\n    get resources() {\n        // Only include valid resources, to not have nulls in the result\n        return this.assignments.reduce((resources, { resource }) => {\n            resource && resources.push(resource.$original);\n            return resources;\n        }, []);\n    }\n\n    set resources(resources) {\n        resources = ArrayHelper.asArray(resources);\n\n        const\n            me             = this,\n            newResourceIds = resources.map(me.constructor.asId);\n\n        if (me.usesSingleAssignment) {\n            me.set('resourceId', newResourceIds[0]);\n        }\n        else {\n            const\n                existingResourceIds                     = me.assignments.map(a => a.resource.id),\n                { onlyInA : toAdd, onlyInB : toRemove } = ArrayHelper.delta(newResourceIds, existingResourceIds);\n            // Add first, remove after. Otherwise event might get removed with its last assignment\n            me.assignmentStore.add(toAdd.map(resourceId => ({ resource : resourceId, event : me })));\n            me.assignmentStore.remove(toRemove.map(resourceId => me.assignments.find(a => a.resource.id === resourceId)));\n        }\n    }\n\n    /**\n     * Iterate over all associated resources\n     * @private\n     * @category Assignments & Resources\n     */\n    forEachResource(fn, thisObj = this) {\n        for (const resource of this.resources) {\n            if (fn.call(thisObj, resource) === false) {\n                return;\n            }\n        }\n    }\n\n    /**\n     * Returns either the resource associated with this event (when called w/o `resourceId`) or resource\n     * with specified id.\n     *\n     * @param {String} [resourceId] To retrieve a specific resource\n     * @returns {Scheduler.model.ResourceModel}\n     * @category Assignments & Resources\n     */\n    getResource(resourceId) {\n        if (resourceId == null) {\n            return this.resource;\n        }\n\n        return this.resourceStore ? this.resourceStore.getById(resourceId) : null;\n    }\n\n    //endregion\n\n    //region Dates\n\n    get startDate() {\n        let dt;\n\n        if (this.isOccurrence) {\n            dt = this.get('startDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._startDate ?? super.startDate;\n        }\n\n        if (this.allDay) {\n            dt = this.constructor.getAllDayStartDate(dt);\n        }\n\n        return dt;\n    }\n\n    set startDate(startDate) {\n        if (this.batching) {\n            this._startDate = startDate;\n            this.set({ startDate });\n        }\n        else {\n            super.startDate = startDate;\n        }\n    }\n\n    get endDate() {\n        let dt;\n\n        if (this.isOccurrence) {\n            dt = this.get('endDate');\n        }\n        else {\n            // Micro optimization to avoid expensive super call. super will be hit in Scheduler Pro\n            dt = this._endDate ?? super.endDate;\n        }\n\n        if (this.allDay) {\n            dt = this.constructor.getAllDayEndDate(dt);\n        }\n\n        return dt;\n    }\n\n    set endDate(endDate) {\n        if (this.batching) {\n            this._endDate = endDate;\n            this.set({ endDate });\n        }\n        else {\n            super.endDate = endDate;\n        }\n    }\n\n    // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate\n    // that value\n    get wrapStartDate() {\n        return this.startDate;\n    }\n\n    set wrapStartDate(value) {}\n\n    get wrapEndDate() {\n        return this.endDate;\n    }\n\n    set wrapEndDate(value) {}\n\n    /**\n     * Shift the dates for the date range by the passed amount and unit\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}\n     * for more information on valid formats.\n     * @param {Number} amount The amount to shift\n     * @returns {Promise} A promise which is resolved when shift calculations are done\n     * @async\n     * @method shift\n     * @category Scheduling\n     */\n\n    //endregion\n\n    //region Is\n\n    // Used internally to differentiate between Event and ResourceTimeRange\n    get isEvent() {\n        return true;\n    }\n\n    /**\n     * Returns true if event can be drag and dropped\n     * @property {Boolean}\n     * @category Editing\n     */\n    get isDraggable() {\n        return !this.readOnly && this.draggable;\n    }\n\n    /**\n     * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can\n     * be resized.\n     *\n     * Milestones and parent events (that are not manuallyScheduled) cannot be resized.\n     *\n     * @property {Boolean|String}\n     * @readonly\n     * @category Editing\n     */\n    get isResizable() {\n        return !this.isMilestone && (!this.isParent || this.manuallyScheduled) && this.resizable;\n    }\n\n    /**\n     * Returns false if the event is not persistable. By default it always is, override this getter if you need\n     * custom logic.\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isPersistable() {\n        // Records not yet fully created cannot be persisted\n        return super.isPersistable && !this.isCreating;\n    }\n\n    endBatch() {\n        const { isPersistable : wasPersistable, meta : { batchChanges } } = this;\n\n        // Remove cached values\n        // https://github.com/bryntum/support/issues/3358\n        if (batchChanges) {\n            if ('endDate' in batchChanges) {\n                delete this._endDate;\n                // When project recalculates start/end date and committing changes to record it calls endBatch. In this\n                // case wrap dates become invalid and should be reset on the record. We do it by forcing `null` value.\n                // Possible scenarios include adding dependency or moving first event in a dependency chain.\n                // Covered by pro/features/BufferTimeDependencies.t\n                // wrap date is an internal field we should be fine without mapping\n                if (this.postamble) {\n                    this.wrapEndDate = null;\n                }\n            }\n\n            if ('startDate' in batchChanges) {\n                delete this._startDate;\n\n                if (this.preamble) {\n                    this.wrapStartDate = null;\n                }\n            }\n        }\n\n        super.endBatch(...arguments);\n\n        // If this event newly persistable, its assignments are eligible for syncing.\n        if (this.isPersistable && !wasPersistable) {\n            this.assignments.forEach(assignment => {\n                assignment.stores.forEach(s => {\n                    s.updateModifiedBagForRecord(assignment);\n                });\n            });\n        }\n    }\n\n    get isCreating() {\n        return super.isCreating;\n    }\n\n    set isCreating(value) {\n        super.isCreating = value;\n\n        this.assignments.forEach(record => record.isCreating = value);\n    }\n\n    //endregion\n\n    //region Single assignment compatibility\n\n    get usesSingleAssignment() {\n        return !this.eventStore || this.eventStore.usesSingleAssignment;\n    }\n\n    copy(...args) {\n        const copy = super.copy(...args);\n\n        // Dont copy resourceId when using multi assignment\n        if (!this.usesSingleAssignment) {\n            copy.resourceId = null;\n        }\n\n        return copy;\n    }\n\n    /**\n     * Override persistable getter to prevent sending resourceId when using multiple resource assignment mode\n     * https://github.com/bryntum/support/issues/1345\n     * @private\n     */\n    get persistableData() {\n        const data = super.persistableData;\n        if (!this.usesSingleAssignment) {\n            delete data.resourceId;\n        }\n        return data;\n    }\n\n    /**\n     * Returns the first assigned resource, or assigns a resource\n     * @member {Scheduler.model.ResourceModel} resource\n     * @category Assignments & Resources\n     */\n    get resource() {\n        const { resources } = this;\n        return resources.length ? resources[0] : null;\n    }\n\n    set resource(resourceRecord) {\n        // Use the resourceId setter for single assignment\n        this.resourceId = this.constructor.asId(resourceRecord);\n    }\n\n    get resourceId() {\n        return this.usesSingleAssignment ? this.get('resourceId') : this.resource?.id;\n    }\n\n    set resourceId(resourceId) {\n        this.applyResourceId(resourceId);\n    }\n\n    // Resources + any links to any of them\n    get $linkedResources() {\n        return this.resources?.flatMap(resourceRecord => ([\n            resourceRecord,\n            ...resourceRecord.$links\n        ])) ?? [];\n    }\n\n    applyResourceId(resourceId, fromApplyValue = false) {\n        const\n            me                                           = this,\n            { assignments, assignmentStore, eventStore } = me;\n\n        // When part of an EventStore, resourceIds are changed to be AssignmentModels\n        if (eventStore) {\n            if (resourceId != null) {\n                if (!me.meta.skipEnforcingSingleAssignment) {\n                    eventStore.usesSingleAssignment = true;\n                }\n\n                // Reassign if already assigned, only single assignment allowed\n                if (assignments?.length && resourceId !== assignments[0].resourceId) {\n                    //assignments[0].set('resourceId', resourceId, Boolean(me.eventStore.eventsSuspended));\n                    // Silent reassign if events are suspended on event store, wont be expecting UI update then\n                    const eventsSuspended = Boolean(eventStore.eventsSuspended);\n\n                    eventsSuspended && assignmentStore.suspendEvents();\n                    assignments[0].resource = resourceId;\n                    eventsSuspended && assignmentStore.resumeEvents();\n                }\n                // Otherwise assign\n                else {\n                    assignmentStore.assignEventToResource(me, resourceId);\n                }\n            }\n            else {\n                // Setting resourceId to null removes all assignments\n                assignmentStore.remove(me.assignments);\n            }\n        }\n        // Not part of an EventStore, edge case. Set to data unless we are in such operation already\n        else if (!fromApplyValue) {\n            me.set({ resourceId });\n        }\n    }\n\n    // Special handling of setting resourceId, creates assignment\n    applyValue(useProp, mapping, value, skipAccessors, field) {\n        if (field && field.name === 'resourceId' && !this.meta.isAssigning) {\n            const { eventStore } = this;\n\n            eventStore && (eventStore.isAssigning = true);\n\n            this.applyResourceId(value, true);\n\n            eventStore && (eventStore.isAssigning = false);\n        }\n\n        super.applyValue(useProp, mapping, value, skipAccessors, field);\n    }\n\n    //endregion\n\n    //region Assignment\n\n    /**\n     * Returns all assignments for the event. Event must be part of the store for this method to work.\n     * @property {Scheduler.model.AssignmentModel[]}\n     * @readonly\n     * @category Assignments & Resources\n     */\n    get assignments() {\n        return [...(this.assigned || [])];\n    }\n\n    /**\n     * Assigns this event to the specified resource.\n     *\n     * *Note:* The event must be part of an EventStore for this to work. If the EventStore uses single assignment\n     * (loaded using resourceId) existing assignments will always be removed.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource A new resource for this event, either as a full\n     *        Resource record or an id (or an array of such).\n     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments\n     * @category Assignments & Resources\n     */\n    assign(resource, removeExistingAssignments = false) {\n        const { eventStore } = this;\n\n        if (eventStore && !eventStore.usesSingleAssignment) {\n            eventStore.assignEventToResource(this, resource, removeExistingAssignments);\n        }\n        else {\n            // Remember what resource to assign,  directly in single assignment mode or for later when we are joined to\n            // an EventStore\n            this.resourceId = this.constructor.asId(resource);\n\n            if (!eventStore) {\n                // Prevent flagging EventStore as using single assignment when that happens, we cannot know that here\n                this.meta.skipEnforcingSingleAssignment = true;\n            }\n        }\n    }\n\n    /**\n     * Unassigns this event from the specified resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} [resource] The resource to unassign from.\n     * @category Assignments & Resources\n     */\n    unassign(resource, removingResource = false) {\n        const me = this;\n\n        resource = me.constructor.asId(resource);\n\n        // If unassigned is caused by removing the resource the UI should be able to find out to not do extra redraws etc.\n        me.meta.removingResource = removingResource;\n\n        me.eventStore?.unassignEventFromResource(me, resource);\n\n        me.meta.removingResource = null;\n    }\n\n    /**\n     * Reassigns an event from an old resource to a new resource\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id\n     * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id\n     * @category Assignments & Resources\n     */\n    reassign(oldResourceId, newResourceId) {\n        this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, oldResourceId, newResourceId);\n    }\n\n    /**\n     * Returns true if this event is assigned to a certain resource.\n     *\n     * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for\n     * @returns {Boolean}\n     * @category Assignments & Resources\n     */\n    isAssignedTo(resource) {\n        const resourceId = this.constructor.asId(resource);\n        return this.assignments.some(assignment => assignment.resourceId === resourceId);\n    }\n\n    //endregion\n\n    //region Dependencies\n\n    /**\n     * Returns all predecessor dependencies of this event\n     *\n     * @readonly\n     * @property {Scheduler.model.DependencyBaseModel[]}\n     * @category Dependencies\n     */\n    get predecessors() {\n        return [...this.incomingDeps ?? []];\n    }\n\n    /**\n     * Returns all successor dependencies of this event\n     *\n     * @readonly\n     * @property {Scheduler.model.DependencyBaseModel[]}\n     * @category Dependencies\n     *\n     */\n    get successors() {\n        return [...this.outgoingDeps ?? []];\n    }\n\n    get dependencies() {\n        // Dependency feature listens for assignment changes pre commit, thus we risk deps not being set up yet\n        return [...this.incomingDeps ?? [], ...this.outgoingDeps ?? []];\n    }\n\n    //endregion\n\n    normalize() {\n        // Normalization handled by Engine\n    }\n\n    inSetNormalize() {\n        // Normalization handled by Engine\n    }\n\n    /**\n     * The \"main\" event this model is an occurrence of.\n     * Returns `null` for non-occurrences.\n     * @property {Scheduler.model.EventModel}\n     * @alias #Scheduler.model.mixin.RecurringTimeSpan#property-recurringTimeSpan\n     * @readonly\n     * @category Scheduling\n     */\n    get recurringEvent() {\n        return this.recurringTimeSpan;\n    }\n\n    /**\n     * Flag which indicates that this event is an interday event. This means that it spans\n     * an entire day or multiple days.\n     *\n     * This is essentially used by the Calendar package to determine if an event should\n     * go into the all day zone of a DayView.\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduling\n     */\n    get isInterDay() {\n        const { durationMS } = this;\n\n        // A full day (86400000 or more) marks as it as interDay,\n        // which means it belongs in the all day row of a Calendar DayView\n        if (durationMS >= oneDayMS || (!durationMS && this.allDay)) {\n            return true;\n        }\n\n        // Working out whether it crosses midnight is a little more difficult\n        const\n            {\n                endDate,\n                startDate\n            } = this,\n            eventStartMidnight = DH.clearTime(startDate);\n\n        // If either is null or NaN, we have to answer falsy\n        if (startDate && endDate) {\n            eventStartMidnight.setDate(eventStartMidnight.getDate() + 1);\n\n            // If the endDate is past midnight, it's interDay and goes in the all day row of a Calendar DayView\n            return (endDate || DH.add(startDate, durationMS)) > eventStartMidnight;\n        }\n    }\n\n    //region All day statics\n\n    static getAllDayStartDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('startDate');\n        }\n\n        if (dt) {\n            dt = DH.clearTime(dt, true);\n        }\n\n        return dt;\n    }\n\n    static getAllDayEndDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('endDate');\n        }\n\n        if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {\n            dt = DH.getNext(dt, 'd', 1);\n        }\n\n        return dt;\n    }\n\n    static getAllDayDisplayStartDate(dt) {\n        if (dt && dt.isEvent) {\n            dt = dt.get('startDate');\n        }\n\n        return DH.clearTime(dt, true);\n    }\n\n    static getAllDayDisplayEndDate(startDate, endDate) {\n        if (startDate && startDate.isEvent) {\n            endDate   = startDate.get('endDate');\n            startDate = startDate.get('startDate');\n        }\n\n        if (endDate) {\n            startDate = this.constructor.getAllDayDisplayStartDate(startDate);\n\n            // If date falls on start of the day - subtract one day to show end date correctly\n            // e.g. event starts on 2017-01-01 00:00 and ends on 2017-01-02 00:00, editor should show\n            // 2017-01-01 for both start and end\n            if (DH.clearTime(endDate, true).valueOf() === endDate.valueOf()) {\n                endDate = DH.add(endDate, DH.DAY, -1);\n            }\n            else if (startDate.valueOf() !== endDate.valueOf()) {\n                endDate = DH.clearTime(endDate, true);\n            }\n        }\n\n        return endDate;\n    }\n\n    /**\n     * Defines if the given event field should be manually editable in UI.\n     * You can override this method to provide your own logic.\n     *\n     * By default, the method defines {@link #field-endDate}, {@link #field-duration} and {@link #property-fullDuration}\n     * fields editable for leaf events only (in case the event is part of a tree store) and all other fields as editable.\n     *\n     * @param {String} fieldName Name of the field\n     * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has\n     * no such field.\n     * @category Editing\n     */\n    isEditable(fieldName) {\n        switch (fieldName) {\n            // end/duration is allowed to edit for leafs\n            case 'endDate' :\n            case 'duration' :\n            case 'fullDuration' :\n                return this.isLeaf;\n        }\n\n        return super.isEditable(fieldName);\n    }\n\n    //endregion\n};\n","import TimeSpan from './TimeSpan.js';\nimport RecurringTimeSpan from './mixin/RecurringTimeSpan.js';\nimport EventModelMixin from './mixin/EventModelMixin.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n/* <remove-on-release> */\nimport { SchedulerBasicEvent } from '../../Engine/quark/model/scheduler_basic/SchedulerBasicEvent.js';\n/* </remove-on-release> */\nimport { SchedulerCoreEvent } from '../../Engine/quark/model/scheduler_core/SchedulerCoreEvent.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? SchedulerBasicEvent : /* </remove-on-release> */SchedulerCoreEvent;\n\n/**\n * @module Scheduler/model/EventModel\n */\n\n/**\n * This class represent a single event in your schedule, usually added to a {@link Scheduler.data.EventStore}.\n *\n * It is a subclass of the {@link Scheduler.model.TimeSpan}, which is in turn subclass of {@link Core.data.Model}.\n * Please refer to documentation of that class to become familiar with the base interface of the event.\n *\n * ## Async date calculations\n *\n * A record created from an {@link Scheduler/model/EventModel} is normally part of an {@link Scheduler.data.EventStore},\n * which in turn is part of a project. When dates or the duration of an event is changed, the project performs async calculations\n * to normalize the other fields.\n * For example if {@link #field-duration} is changed, it will calculate {@link #field-endDate}.\n *\n * As a result of this being an async operation, the values of other fields are not guaranteed to be up to date\n * immediately after a change. To ensure data is up to date, await the calculations to finish.\n *\n * For example, {@link #field-endDate} is not up to date after this operation:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * // endDate not yet calculated\n * ```\n *\n * But if calculations are awaited it is up to date:\n *\n * ```javascript\n * eventRecord.duration = 5;\n * await eventRecord.project.commitAsync();\n * // endDate is calculated\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await eventRecord.setAsync({ duration : 5});\n * // endDate is calculated\n * ```\n *\n * ## Subclassing the Event model class\n * The Event model has a few predefined fields as seen below. If you want to add new fields or change the options for the existing fields,\n * you can do that by subclassing this class (see example below).\n *\n * ```\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            // Add new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     },\n *\n *     myCheckMethod() {\n *         return this.myField > 0\n *     },\n *\n *     ...\n * });\n * ```\n * If you in your data want to use other names for the {@link #field-startDate}, {@link #field-endDate}, {@link #field-resourceId} and name fields you can configure\n * them as seen below:\n * ```\n * class MyEvent extends EventModel {\n *\n *     static get fields() {\n *         return [\n *            { name: 'startDate', dataSource : 'taskStart' },\n *            { name: 'endDate', dataSource : 'taskEnd', format: 'YYYY-MM-DD' },\n *            { name: 'resourceId', dataSource : 'userId' },\n *            { name: 'name', dataSource : 'taskTitle' },\n *         ];\n *     },\n *     ...\n * });\n * ```\n *\n * Please refer to {@link Core.data.Model} for additional details.\n *\n * @extends Scheduler/model/TimeSpan\n * @mixes Scheduler/model/mixin/RecurringTimeSpan\n * @mixes Scheduler/model/mixin/EventModelMixin\n */\nexport default class EventModel extends EngineMixin.derive(TimeSpan).mixin(\n    RecurringTimeSpan,\n    PartOfProject,\n    EventModelMixin\n) {\n    static get $name() {\n        return 'EventModel';\n    }\n}\n\nEventModel.exposeProperties();\n","import AjaxStore from '../../Core/data/AjaxStore.js';\nimport EventStoreMixin from './mixin/EventStoreMixin.js';\nimport GetEventsMixin from './mixin/GetEventsMixin.js';\nimport DayIndexMixin from './mixin/DayIndexMixin.js';\nimport SharedEventStoreMixin from './mixin/SharedEventStoreMixin.js';\nimport RecurringEventsMixin from './mixin/RecurringEventsMixin.js';\nimport EventModel from '../model/EventModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\n/* <remove-on-release> */\nimport { ChronoEventStoreMixin } from '../../Engine/quark/store/ChronoEventStoreMixin.js';\n/* </remove-on-release> */\nimport { CoreEventStoreMixin } from '../../Engine/quark/store/CoreEventStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? PartOfBaseProject(ChronoEventStoreMixin.derive(AjaxStore)) : /* </remove-on-release> */PartOfProject(CoreEventStoreMixin.derive(AjaxStore));\n\n/**\n * @module Scheduler/data/EventStore\n */\n\n/**\n * A store holding all the {@link Scheduler.model.EventModel events} to be rendered into a {@link Scheduler.view.Scheduler Scheduler}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.EventModel}.\n *\n * An EventStore is usually connected to a project, which binds it to other related stores (AssignmentStore,\n * ResourceStore and DependencyStore). The project also handles normalization/calculation of the data on the records in\n * the store. For example if a record is added with a `startDate` and an `endDate`, it will calculate the `duration`.\n *\n * The calculations happens async, records are not guaranteed to have up to date data until they are finished. To be\n * certain that calculations have finished, call `await project.commitAsync()` after store actions. Or use one of the\n * `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * eventStore.data = [{ startDate, endDate }, ...];\n *\n * // duration of the record is not yet calculated\n *\n * await eventStore.project.commitAsync();\n *\n * // now it is\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await eventStore.loadDataAsync([{ startDate, endDate }, ...]);\n *\n * // duration is calculated\n * ```\n *\n * ## Using recurring events\n * When recurring events are in the database, **all recurring event definitions** which started before\n * the requested start date, and have not yet finished recurring MUST be loaded into the EventStore.\n *\n * Only the **base** recurring event **definitions** are stored in the EventStore. You do not\n * need to calculate the future occurrence dates of these events. This is all handled by the EventStore.\n *\n * When asked to yield a set of events for a certain date range for creating a UI through\n * {@link #function-getEvents}, the EventStore *automatically* interpolates any occurrences of\n * recurring events into the results. They do not occupy slots in the EventStore for every date\n * in their repetition range (that would be very inefficient, and *might* be infinite).\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/SharedEventStoreMixin\n * @mixes Scheduler/data/mixin/EventStoreMixin\n * @mixes Scheduler/data/mixin/RecurringEventsMixin\n * @mixes Scheduler/data/mixin/GetEventsMixin\n * @extends Core/data/AjaxStore\n */\nexport default class EventStore extends EngineMixin.mixin(\n    SharedEventStoreMixin,\n    RecurringEventsMixin,\n    EventStoreMixin,\n    DayIndexMixin,\n    GetEventsMixin\n) {\n\n    static $name = 'EventStore';\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Class used to represent records\n             * @config {Scheduler.model.EventModel}\n             * @typings {typeof EventModel}\n             * @default\n             * @category Common\n             */\n            modelClass : EventModel\n        };\n    }\n}\n","import DateHelper from '../../Core/helper/DateHelper.js';\nimport Model from '../../Core/data/Model.js';\nimport Duration from '../../Core/data/Duration.js';\n\n/**\n * @module Scheduler/model/DependencyBaseModel\n */\n\nconst canonicalDependencyTypes = [\n    'SS',\n    'SF',\n    'FS',\n    'FF'\n];\n\n/**\n * Base class used for both Scheduler and Gantt. Not intended to be used directly\n *\n * @extends Core/data/Model\n */\nexport default class DependencyBaseModel extends Model {\n    static get $name() {\n        return 'DependencyBaseModel';\n    }\n\n    /**\n     * Set value for the specified field(s), triggering engine calculations immediately. See\n     * {@link Core.data.Model#function-set Model#set()} for arguments.\n     **\n     * ```javascript\n     * dependency.set('from', 2);\n     * // dependency.fromEvent is not yet up to date\n     *\n     * await dependency.setAsync('from', 2);\n     * // dependency.fromEvent is up to date\n     * ```\n     *\n     * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call\n     * @param {*} value Value to set\n     * @param {Boolean} [silent=false] Set to true to not trigger events\n     * automatically.\n     * @function setAsync\n     * @category Editing\n     * @async\n     */\n\n    //region Fields\n\n    /**\n     * An enumerable object, containing names for the dependency types integer constants.\n     * - 0 StartToStart\n     * - 1 StartToEnd\n     * - 2 EndToStart\n     * - 3 EndToEnd\n     * @property {Object}\n     * @readonly\n     * @category Dependency\n     */\n    static get Type() {\n        return {\n            StartToStart : 0,\n            StartToEnd   : 1,\n            EndToStart   : 2,\n            EndToEnd     : 3\n        };\n    }\n\n    static get fields() {\n        return [\n            // 3 mandatory fields\n\n            /**\n             * From event, id of source event\n             * @field {String|Number} from\n             * @category Dependency\n             */\n            { name : 'from' },\n\n            /**\n             * To event, id of target event\n             * @field {String|Number} to\n             * @category Dependency\n             */\n            { name : 'to' },\n\n            /**\n             * Dependency type, see static property {@link #property-Type-static}\n             * @field {Number} type=2\n             * @category Dependency\n             */\n            { name : 'type', type : 'int', defaultValue : 2 },\n\n            /**\n             * CSS class to apply to lines drawn for the dependency\n             * @field {String} cls\n             * @category Styling\n             */\n            { name : 'cls', defaultValue : '' },\n\n            /**\n             * Bidirectional, drawn with arrows in both directions\n             * @field {Boolean} bidirectional\n             * @category Dependency\n             */\n            { name : 'bidirectional', type : 'boolean' },\n\n            /**\n             * Start side on source (top, left, bottom, right)\n             * @field {'top'|'left'|'bottom'|'right'} fromSide\n             * @category Dependency\n             */\n            { name : 'fromSide', type : 'string' },\n\n            /**\n             * End side on target (top, left, bottom, right)\n             * @field {'top'|'left'|'bottom'|'right'} toSide\n             * @category Dependency\n             */\n            { name : 'toSide', type : 'string' },\n\n            /**\n             * The magnitude of this dependency's lag (the number of units).\n             * @field {Number} lag\n             * @category Dependency\n             */\n            { name : 'lag', type : 'number', allowNull : true, defaultValue : 0 },\n\n            /**\n             * The units of this dependency's lag, defaults to \"d\" (days). Valid values are:\n             *\n             * - \"ms\" (milliseconds)\n             * - \"s\" (seconds)\n             * - \"m\" (minutes)\n             * - \"h\" (hours)\n             * - \"d\" (days)\n             * - \"w\" (weeks)\n             * - \"M\" (months)\n             * - \"y\" (years)\n             *\n             * This field is readonly after creation, to change `lagUnit` use {@link #function-setLag setLag()}.\n             * @field {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} lagUnit\n             * @category Dependency\n             * @readonly\n             */\n            {\n                name         : 'lagUnit',\n                type         : 'string',\n                defaultValue : 'd'\n            },\n\n            { name : 'highlighted', persist : false, internal : true }\n        ];\n    }\n\n    // fromEvent/toEvent defined in CoreDependencyMixin in engine\n\n    /**\n     * Gets/sets the source event of the dependency.\n     *\n     * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.\n     *\n     * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you\n     * need to remap, consider using {@link #field-from} instead.\n     *\n     * @field {Scheduler.model.EventModel} fromEvent\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Dependency\n     */\n\n    /**\n     * Gets/sets the target event of the dependency.\n     *\n     * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.\n     *\n     * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you\n     * need to remap, consider using {@link #field-to} instead.\n     *\n     * @field {Scheduler.model.EventModel} toEvent\n     * @accepts {String|Number|Scheduler.model.EventModel}\n     * @category Dependency\n     */\n\n    //endregion\n\n    //region Init\n\n    construct(data) {\n        const\n            from = data[this.fieldMap.from.dataSource],\n            to   = data[this.fieldMap.to.dataSource];\n\n        // Engine expects fromEvent and toEvent, not from and to. We need to support both\n        if (from != null) {\n            data.fromEvent = from;\n        }\n\n        if (to != null) {\n            data.toEvent = to;\n        }\n\n        super.construct(...arguments);\n    }\n\n    //endregion\n\n    get eventStore() {\n        return this.eventStore || this.unjoinedStores[0]?.eventStore;\n    }\n\n    set from(value) {\n        const { fromEvent } = this;\n\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (fromEvent?.isModel && fromEvent.id === value) {\n            this.set('from', value);\n        }\n        else {\n            this.fromEvent = value;\n        }\n    }\n\n    get from() {\n        return this.get('from');\n    }\n\n    set to(value) {\n        const { toEvent } = this;\n\n        // When assigning a new id to an event, it will update the eventId of the assignment. But the assignments\n        // event is still the same so we need to announce here\n        if (toEvent?.isModel && toEvent.id === value) {\n            this.set('to', value);\n        }\n        else {\n            this.toEvent = value;\n        }\n    }\n\n    get to() {\n        return this.get('to');\n    }\n\n    /**\n     * Alias to dependency type, but when set resets {@link #field-fromSide} & {@link #field-toSide} to null as well.\n     *\n     * @property {Number}\n     * @category Dependency\n     */\n    get hardType() {\n        return this.getHardType();\n    }\n\n    set hardType(type) {\n        this.setHardType(type);\n    }\n\n    /**\n     * Returns dependency hard type, see {@link #property-hardType}.\n     *\n     * @returns {Number}\n     * @category Dependency\n     */\n    getHardType() {\n        return this.get('type');\n    }\n\n    /**\n     * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.\n     *\n     * @param {Number} type\n     * @category Dependency\n     */\n    setHardType(type) {\n        let result;\n\n        if (type !== this.hardType) {\n            result = this.set({\n                type,\n                fromSide : null,\n                toSide   : null\n            });\n        }\n\n        return result;\n    }\n\n    get lag() {\n        return this.get('lag');\n    }\n\n    set lag(lag) {\n        this.setLag(lag);\n    }\n\n    /**\n     * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is readonly after creation\n     * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [lagUnit] Unit for numeric lag value, see\n     * {@link #field-lagUnit} for valid values\n     * @category Dependency\n     */\n    setLag(lag, lagUnit = this.lagUnit) {\n        // Either they're only setting the magnitude\n        // or, if it's a string, parse the full duration.\n        if (arguments.length === 1) {\n            if (typeof lag === 'number') {\n                this.lag = lag;\n            }\n            else {\n                //<debug>\n                if (typeof lag !== 'string') {\n                    throw new Error('Depenedency#setLag accepts either numeric magnitude, or a duration string');\n                }\n                //</debug>\n                lag = DateHelper.parseDuration(lag);\n                this.set({\n                    lag     : lag.magnitude,\n                    lagUnit : lag.unit\n                });\n            }\n            return;\n        }\n\n        // Must be a number\n        lag = parseFloat(lag);\n\n        this.set({\n            lag,\n            lagUnit\n        });\n    }\n\n    getLag() {\n        if (this.lag) {\n            return `${this.lag < 0 ? '-' : '+'}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;\n        }\n        return '';\n    }\n\n    /**\n     * Property which encapsulates the lag's magnitude and units. An object which contains two properties:\n     * @property {Core.data.Duration}\n     * @property {Number} fullLag.magnitude The magnitude of the duration\n     * @property {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} fullLag.unit The unit in which the duration is measured, eg\n     * `'d'` for days\n     * @category Dependency\n     */\n    get fullLag() {\n        return new Duration({\n            unit      : this.lagUnit,\n            magnitude : this.lag\n        });\n    }\n\n    set fullLag(lag) {\n        if (typeof lag === 'string') {\n            this.setLag(lag);\n        }\n        else {\n            this.setLag(lag.magnitude, lag.unit);\n        }\n    }\n\n    /**\n     * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')\n     *\n     * @property {Boolean}\n     * @readonly\n     * @category Editing\n     */\n    get isPersistable() {\n        const\n            me = this,\n            { stores, unjoinedStores } = me,\n            store = stores[0];\n\n        let result;\n\n        if (store) {\n            const\n                { fromEvent, toEvent } = me,\n                crudManager            = store.crudManager;\n\n            // if crud manager is used it can deal with phantom source/target since it persists all records in one batch\n            // if no crud manager used we have to wait till source/target are persisted\n            result = fromEvent && (crudManager || !fromEvent.hasGeneratedId) && toEvent && (crudManager || !toEvent.hasGeneratedId);\n        }\n        else {\n            result = Boolean(unjoinedStores[0]);\n        }\n\n        return result && super.isPersistable;\n    }\n\n    getDateRange() {\n        const { fromEvent, toEvent } = this;\n\n        if (fromEvent?.isScheduled && toEvent?.isScheduled) {\n            const Type = DependencyBaseModel.Type;\n\n            let sourceDate,\n                targetDate;\n\n            switch (this.type) {\n                case Type.StartToStart:\n                    sourceDate = fromEvent.startDateMS;\n                    targetDate = toEvent.startDateMS;\n                    break;\n\n                case Type.StartToEnd:\n                    sourceDate = fromEvent.startDateMS;\n                    targetDate = toEvent.endDateMS;\n                    break;\n\n                case Type.EndToEnd:\n                    sourceDate = fromEvent.endDateMS;\n                    targetDate = toEvent.endDateMS;\n                    break;\n\n                case Type.EndToStart:\n                    sourceDate = fromEvent.endDateMS;\n                    targetDate = toEvent.startDateMS;\n                    break;\n\n                default:\n                    throw new Error('Invalid dependency type: ' + this.type);\n            }\n\n            return {\n                start : Math.min(sourceDate, targetDate),\n                end   : Math.max(sourceDate, targetDate)\n            };\n        }\n\n        return null;\n    }\n\n    /**\n     * Applies given CSS class to dependency, the value doesn't persist\n     *\n     * @param {String} cls\n     * @category Dependency\n     */\n    highlight(cls) {\n        const classes = this.highlighted?.split(' ') ?? [];\n\n        if (!classes.includes(cls)) {\n            this.highlighted = classes.concat(cls).join(' ');\n        }\n    }\n\n    /**\n     * Removes given CSS class from dependency if applied, the value doesn't persist\n     *\n     * @param {String} cls\n     * @category Dependency\n     */\n    unhighlight(cls) {\n        const { highlighted } = this;\n\n        if (highlighted) {\n            const\n                classes = highlighted.split(' '),\n                index   = classes.indexOf(cls);\n\n            if (index >= 0) {\n                classes.splice(index, 1);\n                this.highlighted = classes.join(' ');\n            }\n        }\n    }\n\n    /**\n     * Checks if the given CSS class is applied to dependency.\n     *\n     * @param {String} cls\n     * @returns {Boolean}\n     * @category Dependency\n     */\n    isHighlightedWith(cls) {\n        return this.highlighted && this.highlighted.split(' ').includes(cls);\n    }\n\n    getConnectorString(raw) {\n        const rawValue = canonicalDependencyTypes[this.type];\n\n        if (raw) {\n            return rawValue;\n        }\n\n        // FS => empty string; it's the default\n        if (this.type === DependencyBaseModel.Type.EndToStart) {\n            return '';\n        }\n\n        return rawValue;\n    }\n\n    // getConnectorStringFromType(type, raw) {\n    //     const rawValue = canonicalDependencyTypes[type];\n    //\n    //     if (raw) {\n    //         return rawValue;\n    //     }\n    //\n    //     // FS => empty string; it's the default\n    //     if (type === DependencyBaseModel.Type.EndToStart) {\n    //         return '';\n    //     }\n    //\n    //     const locale = LocaleManager.locale;\n    //\n    //     // See if there is a local version of SS, SF or FF\n    //     if (locale) {\n    //         const localized = locale.Scheduler && locale.Scheduler[rawValue];\n    //         if (localized) {\n    //             return localized;\n    //         }\n    //     }\n    //\n    //     return rawValue;\n    // }\n\n    // getConnectorString(raw) {\n    //     return this.getConnectorStringFromType(this.type);\n    // }\n\n    // * getConnectorStringGenerator(raw) {\n    //     return this.getConnectorStringFromType(yield this.$.type);\n    // }\n\n    toString() {\n        return `${this.from}${this.getConnectorString()}${this.getLag()}`;\n    }\n\n    /**\n     * Returns `true` if the dependency is valid. It is considered valid if it has a valid type and both from and to\n     * events are set and pointing to different events.\n     *\n     * @property {Boolean}\n     * @typings ignore\n     * @category Editing\n     */\n    get isValid() {\n        const { fromEvent, toEvent, type } = this;\n\n        return typeof type === 'number' && fromEvent && toEvent && fromEvent !== toEvent;\n    }\n\n    get fromEventName() {\n        return this.fromEvent?.name || '';\n    }\n\n    get toEventName() {\n        return this.toEvent?.name || '';\n    }\n\n    //region STM hooks\n\n    shouldRecordFieldChange(fieldName, oldValue, newValue) {\n        if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {\n            return false;\n        }\n\n        if (fieldName === 'from' || fieldName === 'to' || fieldName === 'fromEvent' || fieldName === 'toEvent') {\n\n            const eventStore = this.project?.eventStore;\n\n            if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    //endregion\n}\n\nDependencyBaseModel.exposeProperties();\n","import DependencyBaseModel from './DependencyBaseModel.js';\nimport PartOfProject from '../data/mixin/PartOfProject.js';\n/* <remove-on-release> */\nimport { BaseDependencyMixin } from '../../Engine/quark/model/scheduler_basic/BaseDependencyMixin.js';\n/* </remove-on-release> */\nimport { CoreDependencyMixin } from '../../Engine/quark/model/scheduler_core/CoreDependencyMixin.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? BaseDependencyMixin : /* </remove-on-release> */CoreDependencyMixin;\n\n/**\n * @module Scheduler/model/DependencyModel\n */\n\n/**\n * This model represents a dependency between two events, usually added to a {@link Scheduler.data.DependencyStore}.\n *\n * It is a subclass of the {@link Scheduler.model.DependencyBaseModel} class, which in its turn subclasses\n * {@link Core.data.Model}. Please refer to documentation of those classes to become familiar with the base interface of\n * this class.\n *\n * ## Fields and references\n *\n * A Dependency has a few predefined fields, see Fields below.  The name of any fields data source can be customized in\n * the subclass, see the example below. Please also refer to {@link Core.data.Model} for details.\n *\n * ```javascript\n * class MyDependency extends DependencyModel {\n *   static get fields() {\n *     return [\n *       { name: 'to', dataSource: 'targetId' },\n *       { name: 'from', dataSource: 'sourceId' }\n *     ]);\n *   }\n * }\n * ```\n *\n * After load and project normalization, these references are accessible (assuming their respective stores are loaded):\n * - `fromEvent` - The event on the start side of the dependency\n * - `toEvent` - The event on the end side of the dependency\n *\n * ## Async resolving of references\n *\n * As described above, a dependency has links to events. These references are populated async, using the calculation\n * engine of the project that the resource via its store is a part of. Because of this asyncness, references cannot be\n * used immediately after modifications:\n *\n * ```javascript\n * dependency.from = 2;\n * // dependency.fromEvent is not yet up to date\n * ```\n *\n * To make sure references are updated, wait for calculations to finish:\n *\n * ```javascript\n * dependency.from = 2;\n * await dependency.project.commitAsync();\n * // dependency.fromEvent is up to date\n * ```\n *\n * As an alternative, you can also use `setAsync()` to trigger calculations directly after the change:\n *\n * ```javascript\n * await dependency.setAsync({ from : 2});\n * // dependency.fromEvent is up to date\n * ```\n *\n * @extends Scheduler/model/DependencyBaseModel\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class DependencyModel extends PartOfProject(EngineMixin.derive(DependencyBaseModel)) {\n    static get $name() {\n        return 'DependencyModel';\n    }\n\n    // Determines the type of dependency based on fromSide and toSide\n    getTypeFromSides(fromSide, toSide, rtl) {\n        const\n            types     = DependencyBaseModel.Type,\n            startSide = rtl ? 'right' : 'left',\n            endSide   = rtl ? 'left' : 'right';\n\n        if (fromSide === startSide) {\n            return (toSide === startSide) ? types.StartToStart : types.StartToEnd;\n        }\n\n        return (toSide === endSide) ? types.EndToEnd : types.EndToStart;\n    }\n}\n\nDependencyModel.exposeProperties();\n","import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Model from '../../../Core/data/Model.js';\n\n/**\n * @module Scheduler/data/mixin/DependencyStoreMixin\n */\n\n/**\n * This is a mixin, containing functionality related to managing dependencies.\n *\n * It is consumed by the regular {@link Scheduler.data.DependencyStore} class and Scheduler Pros counterpart.\n *\n * @mixin\n */\nexport default Target => class DependencyStoreMixin extends Target {\n    static get $name() {\n        return 'DependencyStoreMixin';\n    }\n\n    /**\n     * Add dependencies to the store.\n     *\n     * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus they\n     * cannot be directly accessed after using this function.\n     *\n     * For example:\n     *\n     * ```javascript\n     * const [dependency] = dependencyStore.add({ from, to });\n     * // dependency.fromEvent is not yet available\n     * ```\n     *\n     * To guarantee references are set up, wait for calculations for finish:\n     *\n     * ```javascript\n     * const [dependency] = dependencyStore.add({ from, to });\n     * await dependencyStore.project.commitAsync();\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * Alternatively use `addAsync()` instead:\n     *\n     * ```javascript\n     * const [dependency] = await dependencyStore.addAsync({ from, to });\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.DependencyModel[]} Added records\n     * @function add\n     * @category CRUD\n     */\n\n    /**\n     * Add dependencies to the store and triggers calculations directly after. Await this function to have up to date\n     * references on the added dependencies.\n     *\n     * ```javascript\n     * const [dependency] = await dependencyStore.addAsync({ from, to });\n     * // dependency.fromEvent is available (assuming EventStore is loaded and so on)\n     * ```\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records\n     * Array of records/data or a single record/data to add to store\n     * @param {Boolean} [silent] Specify `true` to suppress events\n     * @returns {Scheduler.model.DependencyModel[]} Added records\n     * @function addAsync\n     * @category CRUD\n     * @async\n     */\n\n    /**\n     * Applies a new dataset to the DependencyStore. Use it to plug externally fetched data into the store.\n     *\n     * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus\n     * they cannot be directly accessed after assigning the new dataset.\n     *\n     * For example:\n     *\n     * ```javascript\n     * dependencyStore.data = [{ from, to }];\n     * // dependencyStore.first.fromEvent is not yet available\n     * ```\n     *\n     * To guarantee references are available, wait for calculations for finish:\n     *\n     * ```javascript\n     * dependencyStore.data = [{ from, to }];\n     * await dependencyStore.project.commitAsync();\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * Alternatively use `loadDataAsync()` instead:\n     *\n     * ```javascript\n     * await dependencyStore.loadDataAsync([{ from, to }]);\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * @member {DependencyModelConfig[]} data\n     * @category Records\n     */\n\n    /**\n     * Applies a new dataset to the DependencyStore and triggers calculations directly after. Use it to plug externally\n     * fetched data into the store.\n     *\n     * ```javascript\n     * await dependencyStore.loadDataAsync([{ from, to }]);\n     * // dependencyStore.first.fromEvent is available\n     * ```\n     *\n     * @param {DependencyModelConfig[]} data Array of DependencyModel data objects\n     * @function loadDataAsync\n     * @category CRUD\n     * @async\n     */\n\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 400,\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 400,\n\n            storeId : 'dependencies'\n        };\n    }\n\n    // TODO: document\n    reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {\n        depsGetterFn = depsGetterFn || (event => this.getEventDependencies(event));\n\n        event = ArrayHelper.asArray(event);\n\n        event.reduce((result, event) => {\n            if (event.children && !flat) {\n                event.traverse(evt => {\n                    result = depsGetterFn(evt).reduce(reduceFn, result);\n                });\n            }\n            else {\n                result = depsGetterFn(event).reduce(reduceFn, result);\n            }\n        }, result);\n\n        return result;\n    }\n\n    // TODO: document\n    mapEventDependencies(event, fn, filterFn, flat, depsGetterFn) {\n        return this.reduceEventDependencies(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat, depsGetterFn);\n    }\n\n    // TODO: document\n    mapEventPredecessors(event, fn, filterFn, flat) {\n        return this.reduceEventPredecessors(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat);\n    }\n\n    // TODO: document\n    mapEventSuccessors(event, fn, filterFn, flat) {\n        return this.reduceEventSuccessors(event, (result, dependency) => {\n            filterFn(dependency) && result.push(dependency);\n            return result;\n        }, [], flat);\n    }\n\n    /**\n     * Returns all dependencies for a certain event (both incoming and outgoing)\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Scheduler.model.DependencyModel[]}\n     */\n    getEventDependencies(event) {\n        return [].concat(event.predecessors || [], event.successors || []);\n    }\n\n    // TODO: document\n    removeEventDependencies(event) {\n        this.remove(this.getEventDependencies(event));\n    }\n\n    // TODO: document\n    removeEventPredecessors(event) {\n        this.remove(event.predecessors);\n    }\n\n    // TODO: document\n    removeEventSuccessors(event, flat) {\n        this.remove(event.successors);\n    }\n\n    getBySourceTargetId(key) {\n        //TODO: in original code this uses a keymap\n        return this.records.find(r =>\n            key == this.constructor.makeDependencySourceTargetCompositeKey(r.from, r.to)\n        );\n    }\n\n    /**\n     * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st\n     * task to 2nd) or backward (from 2nd to 1st).\n     *\n     * @param {Scheduler.model.EventModel|String} sourceEvent 1st event\n     * @param {Scheduler.model.EventModel|String} targetEvent 2nd event\n     * @returns {Scheduler.model.DependencyModel}\n     */\n    getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {\n        sourceEvent = Model.asId(sourceEvent);\n        targetEvent = Model.asId(targetEvent);\n\n        return this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));\n    }\n\n    /**\n     * Returns a dependency model instance linking given events if such dependency exists in the store.\n     * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).\n     *\n     * @param {Scheduler.model.EventModel|String} sourceEvent\n     * @param {Scheduler.model.EventModel|String} targetEvent\n     * @returns {Scheduler.model.DependencyModel}\n     */\n    getEventsLinkingDependency(sourceEvent, targetEvent) {\n        return this.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) ||\n            this.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);\n    }\n\n    /**\n     * Validation method used to validate a dependency. Override and return `true` to indicate that an\n     * existing dependency between two tasks is valid. For a new dependency being created please see\n     * {@link #function-isValidDependencyToCreate}.\n     *\n     * @param {Scheduler.model.DependencyModel|Scheduler.model.TimeSpan|Number|String} dependencyOrFromId The dependency\n     * model, the from task/event or the id of the from task/event\n     * @param {Scheduler.model.TimeSpan|Number|String} [toId] To task/event or id thereof if the first parameter is not\n     * a dependency record\n     * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static} if the first\n     * parameter is not a dependency model instance.\n     * @returns {Boolean}\n     */\n    async isValidDependency(dependencyOrFromId, toId, type) {\n        let fromEvent = dependencyOrFromId, toEvent = toId;\n\n        if (dependencyOrFromId == null) {\n            return false;\n        }\n\n        // Accept dependency model\n        if (dependencyOrFromId.isDependencyModel) {\n            ({ fromEvent, toEvent } = dependencyOrFromId);\n        }\n\n        // Accept from as id\n        fromEvent = this.eventStore.getById(fromEvent);\n\n        // Accept to as id\n        toEvent = this.eventStore.getById(toEvent);\n\n        // This condition is supposed to map all model instances to be validated by project. Lowest common ancestor\n        // for scheduler event, scheduler pro event and gantt task is TimeSpan\n        if (fromEvent && toEvent) {\n            // Block creating dependencies to display only tasks in Gantt\n            if (!fromEvent.project || !toEvent.project) {\n                return false;\n            }\n\n            // Not asserting dependency type here. Default value should normally suffice.\n            return this.project.isValidDependency(fromEvent, toEvent, type);\n        }\n\n        return dependencyOrFromId !== toId;\n    }\n\n    /**\n     * Validation method used to validate a dependency while creating. Override and return `true` to indicate that\n     * a new dependency is valid to be created.\n     *\n     * @param {Scheduler.model.TimeSpan|Number|String} fromId From event/task or id\n     * @param {Scheduler.model.TimeSpan|Number|String} toId To event/task or id\n     * @param {Number} type Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n     * @returns {Boolean}\n     */\n    isValidDependencyToCreate(fromId, toId, type) {\n        return this.isValidDependency(fromId, toId, type);\n    }\n\n    /**\n     * Returns all dependencies highlighted with the given CSS class\n     *\n     * @param {String} cls\n     * @returns {Scheduler.model.DependencyBaseModel[]}\n     */\n    getHighlightedDependencies(cls) {\n        return this.records.reduce((result, dep) => {\n            if (dep.isHighlightedWith(cls)) result.push(dep);\n            return result;\n        }, []);\n    }\n\n    static makeDependencySourceTargetCompositeKey(from, to) {\n        return `source(${from})-target(${to})`;\n    }\n\n    //region Product neutral\n\n    getTimeSpanDependencies(record) {\n        return this.getEventDependencies(record);\n    }\n\n    //endregion\n};\n","import AjaxStore from '../../Core/data/AjaxStore.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport PartOfProject from './mixin/PartOfProject.js';\nimport DependencyStoreMixin from './mixin/DependencyStoreMixin.js';\n/* <remove-on-release> */\nimport { ChronoDependencyStoreMixin } from '../../Engine/quark/store/ChronoDependencyStoreMixin.js';\n/* </remove-on-release> */\nimport { CoreDependencyStoreMixin } from '../../Engine/quark/store/CoreDependencyStoreMixin.js';\nimport PartOfBaseProject from './mixin/PartOfBaseProject.js';\n\nconst EngineMixin = /* <remove-on-release> */ globalThis.bryntum?.useBasicEngine ? PartOfBaseProject(ChronoDependencyStoreMixin.derive(AjaxStore)) : /* </remove-on-release> */PartOfProject(CoreDependencyStoreMixin.derive(AjaxStore));\n\n/**\n * @module Scheduler/data/DependencyStore\n */\n\n/**\n * A store representing a collection of dependencies between events in the {@link Scheduler.data.EventStore}.\n *\n * This store only accepts a model class inheriting from {@link Scheduler.model.DependencyModel}.\n *\n * A DependencyStore is usually connected to a project, which binds it to other related stores (EventStore,\n * AssignmentStore and ResourceStore). The project also handles references (fromEvent, toEvent) to related records\n * for the records in the store.\n *\n * Resolving the references happens async, records are not guaranteed to have up to date references until calculations\n * are finished. To be certain that references are resolved, call `await project.commitAsync()` after store actions. Or\n * use one of the `xxAsync` functions, such as `loadDataAsync()`.\n *\n * Using `commitAsync()`:\n *\n * ```javascript\n * dependencyStore.data = [{ from, to }, ...];\n *\n * // references (fromEvent, toEvent) not resolved yet\n *\n * await dependencyStore.project.commitAsync();\n *\n * // now they are\n * ```\n *\n * Using `loadDataAsync()`:\n *\n * ```javascript\n * await dependencyStore.loadDataAsync([{ from, to }, ...]);\n *\n * // references (fromEvent, toEvent) are resolved\n * ```\n *\n * @mixes Scheduler/data/mixin/PartOfProject\n * @mixes Scheduler/data/mixin/DependencyStoreMixin\n * @extends Core/data/AjaxStore\n */\nexport default class DependencyStore extends DependencyStoreMixin(EngineMixin.derive(AjaxStore)) {\n\n    static get defaultConfig() {\n        return {\n            modelClass : DependencyModel\n        };\n    }\n\n}\n","import AbstractCrudManagerMixin from '../../../Scheduler/crud/AbstractCrudManagerMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport Base from '../../../Core/Base.js';\nimport AjaxTransport from '../../crud/transport/AjaxTransport.js';\nimport JsonEncoder from '../../crud/encoder/JsonEncoder.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/data/mixin/ProjectCrudManager\n */\n\n/**\n * This mixin provides Crud Manager functionality supporting loading of scheduling engine projects.\n *\n * @mixin\n * @mixes Scheduler/crud/AbstractCrudManagerMixin\n * @mixes Scheduler/crud/transport/AjaxTransport\n * @mixes Scheduler/crud/encoder/JsonEncoder\n */\nexport default Target => class ProjectCrudManager extends (Target || Base).mixin(AbstractCrudManagerMixin, AjaxTransport, JsonEncoder) {\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            project : null\n        };\n    }\n\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n\n        super.startConfigure(config);\n\n        this._changesToClear = new Map();\n    }\n\n    async doAutoLoad() {\n        const { project } = this;\n\n        // Delay autoLoad to after projects initial commit if configured with a project\n        if (project) {\n            await project.commitAsync();\n        }\n\n        return super.doAutoLoad();\n    }\n\n    applyProjectResponse(response) {\n        const\n            me = this,\n            { project } = me;\n\n        me.applyingProjectResponse = true;\n\n        const\n            startDateField = project.fieldMap.startDate,\n            endDateField   = project.fieldMap.endDate,\n            startDate      = ObjectHelper.getPath(response, startDateField.dataSource),\n            endDate        = ObjectHelper.getPath(response, endDateField.dataSource);\n\n        // With early rendering engine won't convert project dates in time, do it manually first\n        if (typeof startDate === 'string') {\n            ObjectHelper.setPath(response, startDateField.dataSource, startDateField.convert(startDate));\n        }\n        if (typeof endDate === 'string') {\n            ObjectHelper.setPath(response, endDateField.dataSource, endDateField.convert(endDate));\n        }\n\n        Object.assign(project, response);\n\n        me._changesToClear.set(me, response);\n\n        me.applyingProjectResponse = false;\n    }\n\n    loadCrudManagerData(response, options = {}) {\n        const\n            me = this,\n            { project } = me;\n\n        // We don't want to react on store changes while loading them\n        me.suspendChangesTracking();\n\n        super.loadCrudManagerData(...arguments);\n\n        // If there is project data provided\n        if (response?.project) {\n            // If the project is delaying its linking to a new graph instance\n            // wait till it detaches all records from the old graph\n            // and then apply the project data.\n            // Otherwise the project changes we apply here will be overridden when detaching from the old graph.\n            // Since the code copies last identifier values from the graph when detaching.\n            if (project.delayEnteringReplica) {\n                project.ion({\n                    recordsUnlinked : () => {\n                        me.suspendChangesTracking();\n                        me.applyProjectResponse(response.project);\n                        me.resumeChangesTracking();\n                    },\n                    once : true\n                });\n            }\n            else {\n                me.applyProjectResponse(response.project);\n            }\n        }\n\n        me.resumeChangesTracking();\n    }\n\n    async sync() {\n        const { project } = this;\n\n        // Suspend Crud Manager autoSync to not react on changes during commitAsync() call\n        this.suspendAutoSync();\n\n        // Make sure data is in a calculated state before syncing\n        if (project) {\n            await project.commitAsync();\n        }\n\n        if (this.isDestroying) {\n            return;\n        }\n\n        // resume autoSync silently\n        this.resumeAutoSync(false);\n\n        return super.sync();\n    }\n\n    async applyResponse(request, response, options) {\n        const me = this;\n\n        if (me.isDestroyed || me.project?.isDestroyed) {\n            return;\n        }\n\n        me.trigger('startApplyResponse');\n\n        await super.applyResponse(request, response, options);\n\n        // If there is the project data provided or it's not provided but short responses are enabled\n        // in such cases we treat a successful response covering all sent changes as much as that's possible\n        // so responding `project : { ... }` should not be really needed\n        if (response?.project || (me.supportShortSyncResponse && request?.pack?.project)) {\n            // apply the responded changes (or accept the requested ones)\n            me.applyProjectResponse(response.project || request?.pack?.project);\n        }\n\n        // if we have a project\n        if (me.project) {\n            let requestType = request.type;\n\n            // response can force its type\n            if (me.trackResponseType) {\n                requestType = response.type || requestType;\n            }\n\n            // Make a boolean flag indicating what has triggered the propagation (\"propagatingLoadChanges\" or  \"propagatingSyncChanges\")\n            const propagationFlag = `propagating${StringHelper.capitalize(requestType)}Changes`;\n\n            me.suspendAutoSync();\n            me[propagationFlag] = true;\n\n            const loud = me.project.isInitialCommit && !me.project.silenceInitialCommit;\n\n            // Wait till calculation gets done\n            await me.project.commitAsync();\n\n            me[propagationFlag] = false;\n\n            // for initial commit we still trigger the sync, but not for following\n            me.resumeAutoSync?.(loud);\n\n            // Accept changes came from the server (might have been destroyed while waiting above)\n            me.commitRespondedChanges?.();\n        }\n    }\n\n    applySyncResponse(...args) {\n        const\n            me          = this,\n            stmDisabled = me.project?.stm.disabled;\n\n        if (stmDisabled === false && me.ignoreRemoteChangesInSTM) {\n            me.project.stm.disable();\n        }\n\n        super.applySyncResponse(...args);\n\n        if (stmDisabled === false) {\n            me.project.stm.enable();\n        }\n    }\n\n    shouldClearRecordFieldChange(record, field, value) {\n        const oldValue = record[field];\n\n        field = record.getFieldDefinition(field);\n\n        // If the field value matches the one responded from the server\n        // we silently accept it\n        return field?.isEqual ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);\n    }\n\n    commitRespondedChanges() {\n        // We silently accept changes came from the server\n        this._changesToClear.forEach((changes, record) => {\n            Object.entries(changes).forEach(([key, value]) => {\n                // If the field value matches the one responded from the server\n                // we silently accept it\n                if (this.shouldClearRecordFieldChange(record, key, value)) {\n                    delete record.meta.modified[key];\n                }\n            });\n        });\n\n        this._changesToClear.clear();\n    }\n\n    applyChangesToStore(storeDesc, storeResponse, storePack, ...rest) {\n        const changesMap = super.applyChangesToStore(storeDesc, storeResponse, storePack, ...rest);\n\n        // The changes enter graph first but not store until later, clearing changes in StoreChanges might still leave\n        // records modified. We need to clean up after the next propagation, so we store record changes in a map for now\n        if (changesMap.size && this.project) {\n            for (const [id, changes] of changesMap) {\n                const record = storeDesc.store.getById(id);\n                record && this._changesToClear.set(record, changes);\n            }\n        }\n\n        return changesMap;\n    }\n};\n","import Model from '../../../Core/data/Model.js';\n\n/**\n * @module Scheduler/model/mixin/ProjectModelCommon\n */\n\n/**\n * Mixin that provides helpful methods and properties for a `ProjectModel`. This mixin applies to all Bryntum products.\n * @mixin\n * @internal\n */\nexport default Target => class ProjectModelCommon extends (Target || Model) {\n    static $name = 'ProjectModelCommon';\n\n    static get configurable() {\n        return {\n            // TODO json : null,\n\n            // Documented in Gantt/Scheduler/SchedulerPro version of ./model/ProjectModel since types differ\n            assignments  : null,\n            dependencies : null,\n            resources    : null,\n            timeRanges   : null\n        };\n    }\n\n    //region Inline data\n\n    get assignments() {\n        return this.assignmentStore.records;\n    }\n\n    updateAssignments(assignments) {\n        this.assignmentStore.data = assignments;\n    }\n\n    get dependencies() {\n        return this.dependencyStore.records;\n    }\n\n    updateDependencies(dependencies) {\n        this.dependencyStore.data = dependencies;\n    }\n\n    get resources() {\n        return this.resourceStore.records;\n    }\n\n    updateResources(resources) {\n        this.resourceStore.data = resources;\n    }\n\n    get timeRanges() {\n        return this.timeRangeStore.records;\n    }\n\n    getTimeRanges(startDate, endDate) {\n        const\n            store = this.timeRangeStore,\n            ret = [];\n\n        for (const timeSpan of store) {\n            // Collect occurrences for the recurring events in the record set\n            if (timeSpan.isRecurring) {\n                ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));\n            }\n            else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {\n                ret.push(timeSpan);\n            }\n        }\n\n        return ret;\n    }\n\n    updateTimeRanges(timeRanges) {\n        this.timeRangeStore.data = timeRanges;\n    }\n\n    getResourceTimeRanges(startDate, endDate) {\n        const\n            store = this.resourceTimeRangeStore,\n            ret = [];\n\n        for (const timeSpan of store) {\n            // Collect occurrences for the recurring events in the record set\n            if (timeSpan.isRecurring) {\n                ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));\n            }\n            else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {\n                ret.push(timeSpan);\n            }\n        }\n\n        return ret;\n    }\n\n    //endregion\n};\n","import TimeSpan from './TimeSpan.js';\n/**\n * @module Scheduler/model/ResourceTimeRangeModel\n */\n\n/**\n * This class represent a single resource time range in your schedule.\n * To style the rendered elements, use {@link Scheduler.model.TimeSpan#field-cls} or {@link #field-timeRangeColor} field.\n * The class is used by the {@link Scheduler.feature.ResourceTimeRanges} feature.\n *\n * ## Recurring ranges support\n *\n * By default the class doesn't support recurrence.\n * In order to add its support please use {@link Scheduler/model/mixin/RecurringTimeSpan} mixin\n * (the store containing the model should in turn be mixed with {@link Scheduler.data.mixin.RecurringTimeSpansMixin} class):\n *\n * ```js\n * // Mix RecurringTimeSpan (which adds recurrence support) to ResourceTimeRangeModel\n * class MyResourceTimeRange extends RecurringTimeSpan(ResourceTimeRangeModel) {};\n *\n * // Mix RecurringTimeSpansMixin (which adds recurrence support) to ResourceTimeRangeStore\n * class MyResourceTimeRangeStore extends RecurringTimeSpansMixin(ResourceTimeRangeStore) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyResourceTimeRange\n *         };\n *     }\n * };\n *\n * // Make new store that supports time ranges recurrence\n * const store = new MyResourceTimeRangeStore({\n *     data : [{        {\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Coffee break',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n * ```\n *\n * @extends Scheduler/model/TimeSpan\n */\nexport default class ResourceTimeRangeModel extends TimeSpan {\n    static $name = 'ResourceTimeRangeModel';\n\n    //region Fields\n\n    static fields = [\n        /**\n         * Id of the resource this time range is associated with\n         * @field {String|Number} resourceId\n         */\n        'resourceId',\n\n        /**\n         * Controls this time ranges primary color, defaults to using current themes default time range color.\n         * @field {String} timeRangeColor\n         */\n        'timeRangeColor'\n    ];\n\n    static relations = {\n        /**\n         * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned\n         * to `resourceId`. The relation also lets you access all time ranges on a resource through\n         * `ResourceModel#timeRanges`.\n         * @member {Scheduler.model.ResourceModel} resource\n         */\n        resource : {\n            foreignKey            : 'resourceId',\n            foreignStore          : 'resourceStore',\n            relatedCollectionName : 'timeRanges',\n            nullFieldOnRemove     : true\n        }\n    }\n\n    static domIdPrefix = 'resourcetimerange';\n\n    get domId() {\n        return `${this.constructor.domIdPrefix}-${this.id}`;\n    }\n\n    //endregion\n\n    // Used internally to differentiate between Event and ResourceTimeRange\n    get isResourceTimeRange() {\n        return true;\n    }\n\n    // To match EventModel API\n    get resources() {\n        return this.resource ? [this.resource] : [];\n    }\n\n    // To match EventModel API\n    get $linkedResources() {\n        return this.resources;\n    }\n}\n","import AjaxStore from '../../Core/data/AjaxStore.js';\nimport ResourceTimeRangeModel from '../model/ResourceTimeRangeModel.js';\n\n/**\n * @module Scheduler/data/ResourceTimeRangeStore\n */\n\n/**\n * A class representing a collection of resource time ranges.\n * Contains a collection of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} records.\n * The class is used by the {@link Scheduler.feature.ResourceTimeRanges ResourceTimeRanges} feature.\n *\n * ## Recurring ranges support\n *\n * By default, the class doesn't support recurrence. In order to add its support\n * please use {@link Scheduler.data.mixin.RecurringTimeSpansMixin RecurringTimeSpansMixin} mixin\n * (the store model in turn should be mixed with {@link Scheduler/model/mixin/RecurringTimeSpan RecurringTimeSpan} class):\n *\n * ```js\n * // Mix RecurringTimeSpan (which adds recurrence support) to ResourceTimeRangeModel\n * class MyResourceTimeRange extends RecurringTimeSpan(ResourceTimeRangeModel) {};\n *\n * // Mix RecurringTimeSpansMixin (which adds recurrence support) to ResourceTimeRangeStore\n * class MyResourceTimeRangeStore extends RecurringTimeSpansMixin(ResourceTimeRangeStore) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyResourceTimeRange\n *         };\n *     }\n * };\n *\n * // Make new store that supports time ranges recurrence\n * const store = new MyResourceTimeRangeStore({\n *     data : [{        {\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Coffee break',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n * ```\n *\n * @extends Core/data/AjaxStore\n */\nexport default class ResourceTimeRangeStore extends AjaxStore {\n\n    static $name = 'ResourceTimeRangeStore';\n\n    static get defaultConfig() {\n        return {\n            /**\n             * CrudManager must load stores in the correct order. Lowest first.\n             * @private\n             */\n            loadPriority : 500,\n\n            /**\n             * CrudManager must sync stores in the correct order. Lowest first.\n             * @private\n             */\n            syncPriority : 500,\n\n            /**\n             * This store should be linked to a ResourceStore to link the time ranges to resources\n             * @config {Scheduler.data.ResourceStore}\n             */\n            resourceStore : null,\n\n            modelClass : ResourceTimeRangeModel,\n            storeId    : 'resourceTimeRanges'\n        };\n    }\n\n    set resourceStore(store) {\n        this._resourceStore = store;\n\n        // If store is assigned after configuration we need to init relations\n        if (!this.isConfiguring) {\n            this.initRelations(true);\n        }\n    }\n\n    get resourceStore() {\n        return this._resourceStore;\n    }\n\n    // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()\n    getResourcesForEvent(resourceTimeRange) {\n        return [resourceTimeRange.resource];\n    }\n\n    /**\n     * Get resource time ranges intersecting the specified date range for a resource.\n     *\n     * The result is sorted by `startDate`.\n     *\n     * @param {Object} options Options\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord Resource record\n     * @param {Date} options.startDate Start date of the range\n     * @param {Date} options.endDate End date of the range\n     * @returns {Scheduler.model.ResourceTimeRangeModel[]}\n     */\n    getRanges({ resourceRecord, startDate, endDate }) {\n        const rangesInDateRange = resourceRecord.timeRanges.flatMap(range => {\n            if (range.supportsRecurring) {\n                return range.getOccurrencesForDateRange(startDate, endDate);\n            }\n\n            if (range.intersectsRange(startDate, endDate)) {\n                return range;\n            }\n\n            return [];\n        });\n\n        return rangesInDateRange.sort((span1, span2) => span1.startDate - span2.startDate);\n    }\n}\n","import Model from '../../../Core/data/Model.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\n\n/**\n * @module Scheduler/model/mixin/ProjectModelTimeZoneMixin\n */\n\n/**\n * Mixin that holds TimeZone functionality shared between projects in Scheduler, Scheduler Pro, Gantt and Calendar\n * @mixin\n */\nexport default Target => class ProjectModelTimeZoneMixin extends (Target || Model) {\n    static $name = 'ProjectModelTimeZoneMixin';\n\n    static configurable = {\n        /**\n         * Set to a IANA time zone (i.e. `Europe/Stockholm`) or a UTC offset in minutes (i.e. `-120`). This will\n         * convert all events, tasks and time ranges to the specified time zone or offset. It will also affect the\n         * displayed timeline's headers as well at the start and end date of it.\n         *\n         * There is currently no built-in time zone support in JavaScript which means that the converted dates\n         * technically still are in the local system time zone, but adjusted to match the configured time zone.\n         *\n         * ### DST\n         * If a IANA time zone is provided, there will be support for DST. But if local system time zone has DST that\n         * will affect the time zone conversion at the exact hour when the local system time zone switches DST on and\n         * off.\n         *\n         * *For example:*\n         * 1. The local system time zone is `Europe/Stockholm` (which is UTC+1 or UTC+2 when DST).\n         * 2. The date `2022-03-27T07:00:00Z` (which is UTC) is converted to `America/Chicago` (which is UTC-6 or UTC-5\n         *    when DST).\n         * 3. The converted JS date will be created from `2022-03-27T02:00:00` which is exactly the hour when\n         *    `Europe/Stockholm` adds an DST hour. This has the effect that the converted date shows up incorrectly as\n         *    `2022-03-27T03:00` instead.\n         *\n         * If a UTC offset is provided, there is no DST support at all.\n         *\n         * ### Editing\n         * If creating new records or editing existing record dates, the dates will be interpreted as in the selected\n         * time zone.\n         *\n         * ### Saving\n         * When saving or syncing data, the dates will be restored to local system time and converted to JSON\n         * ISO formatted.\n         *\n         * @prp {String|Number} [timeZone]\n         * @category Advanced\n         */\n        timeZone : {\n            // Don't ingest the config eagerly because it relies on project being present.\n            // Lazy means it waits for ingestion until timeZone property is referenced.\n            $config : 'lazy',\n            value   : null\n        }\n    }\n\n    afterConstruct() {\n        super.afterConstruct(...arguments);\n\n        this._storesWithDates =  [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore];\n    }\n\n    relayStoreChange({ source, action, records, replaced }) {\n        const me = this;\n\n        if (me.timeZone && me._storesWithDates.includes(source)) {\n            // When loading or changing dataset, de data is treated as local dates and need to be converted\n            if (action === 'dataset') {\n                me.convertStoresToTimeZone([source]);\n                me.ignoreRecordChanges = true;\n                me.commitAsync();\n            }\n            // New added records are treated as in current timezone\n            else if (['add', 'replace'].includes(action)) {\n                if (!records?.length && replaced?.length) {\n                    records = replaced;\n                }\n                if (records.length) {\n                    records.forEach(record => record._inTimeZone = me.timeZone);\n                }\n            }\n        }\n    }\n\n    convertStoresToTimeZone(stores) {\n        const\n            me            = this,\n            { timeZone }  = me,\n            stmAutoRecord = me.stm?.autoRecord;\n\n        // Disable STM while updating timezone values\n        if (stmAutoRecord) {\n            me.stm.autoRecord = false;\n        }\n\n        for (const store of stores) {\n            if (store) {\n\n                store.forEach(r => {\n                    r.$ignoreChange = true; // Used to ignore changes in NestedEvents feature\n                    // Convert baselines if exists\n                    if (r.baselines?.count) {\n                        for (const bl of r.baselines) {\n                            // The baseline records is not marked with a timezone when they are created\n                            if (r._inTimeZone !== bl._inTimeZone) {\n                                bl._inTimeZone = r._inTimeZone;\n                            }\n                            bl.convertToTimeZone(timeZone);\n                        }\n                    }\n\n                    r.convertToTimeZone(timeZone);\n\n                    delete r.$ignoreChange;\n                });\n            }\n        }\n\n        if (stmAutoRecord) {\n            // Restore original value\n            me.stmAutoRecord = stmAutoRecord;\n        }\n    }\n\n    updateTimeZone(timeZone, oldTimeZone) {\n        const\n            me            = this,\n            isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;\n\n        me.calendarManagerStore.forEach(calendar => calendar.bumpVersion());\n\n        // Convert data to time zone\n        me.convertStoresToTimeZone(me._storesWithDates);\n\n        // Convert project startdate\n        if (me.startDate) {\n            const startDate = oldTimeZone ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n        }\n\n        me.ignoreRecordChanges = true;\n        me.commitAsync().then(() => {\n            if (!me.isDestroyed) {\n                me.trigger('timeZoneChange', {\n                    timeZone,\n                    oldTimeZone,\n                    isConfiguring\n                });\n            }\n            delete me._isConfiguringTimeZone;\n        });\n    }\n\n};\n","import Model from '../../../Core/data/Model.js';\nimport ProjectModelCommon from './ProjectModelCommon.js';\nimport ResourceTimeRangeModel from '../ResourceTimeRangeModel.js';\nimport TimeSpan from '../TimeSpan.js';\nimport Store from '../../../Core/data/Store.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ResourceTimeRangeStore from '../../data/ResourceTimeRangeStore.js';\nimport ProjectModelTimeZoneMixin from './ProjectModelTimeZoneMixin.js';\n\n/**\n * @module Scheduler/model/mixin/ProjectModelMixin\n */\n\n/**\n * Mixin that holds configuration shared between projects in Scheduler and Scheduler Pro.\n * @mixes Scheduler/model/mixin/ProjectModelTimeZoneMixin\n * @mixin\n */\nexport default Target => class ProjectModelMixin extends (Target || Model).mixin(\n    ProjectModelCommon,\n    ProjectModelTimeZoneMixin\n) {\n    static get $name() {\n        return 'ProjectModelMixin';\n    }\n\n    //region Config\n\n    static get defaultConfig() {\n        return {\n            /**\n             * State tracking manager instance the project relies on\n             * @member {Core.data.stm.StateTrackingManager} stm\n             * @category Advanced\n             */\n            /**\n             * Configuration options to provide to the STM manager\n             *\n             * @config {StateTrackingManagerConfig|Core.data.stm.StateTrackingManager}\n             * @category Advanced\n             */\n            stm : {},\n\n            timeRangeModelClass         : TimeSpan,\n            resourceTimeRangeModelClass : ResourceTimeRangeModel,\n\n            /**\n             * The constructor to create a time range store instance with. Should be a class subclassing the\n             * {@link Core.data.Store}\n             * @config {Core.data.Store|Object}\n             * @typings {typeof Store|object}\n             * @category Models & Stores\n             */\n            timeRangeStoreClass : Store,\n\n            /**\n             * The constructor to create a resource time range store instance with. Should be a class subclassing the\n             * {@link Scheduler.data.ResourceTimeRangeStore}\n             * @config {Scheduler.data.ResourceTimeRangeStore|Object}\n             * @typings {typeof ResourceTimeRangeStore|object}\n             * @category Models & Stores\n             */\n            resourceTimeRangeStoreClass : ResourceTimeRangeStore,\n\n            /**\n             * The initial data, to fill the {@link #property-timeRangeStore timeRangeStore} with.\n             * Should be an array of {@link Scheduler.model.TimeSpan TimeSpan} or its configuration objects.\n             *\n             * @config {Scheduler.model.TimeSpan[]} [timeRangesData]\n             * @category Legacy inline data\n             */\n\n            /**\n             * The initial data, to fill the {@link #property-resourceTimeRangeStore resourceTimeRangeStore} with.\n             * Should be an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} or it's\n             * configuration objects.\n             *\n             * @config {Scheduler.model.ResourceTimeRangeModel[]} [resourceTimeRangesData]\n             * @category Legacy inline data\n             */\n\n            eventStore      : {},\n            assignmentStore : {},\n            dependencyStore : {},\n            resourceStore   : {},\n            timeRangesData  : null\n        };\n    }\n\n    static configurable = {\n        /**\n         * Project data as a JSON string, used to populate its stores.\n         *\n         * ```javascript\n         * const project = new ProjectModel({\n         *     json : '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n         * }\n         * ```\n         *\n         * @config {String}\n         * @category Inline data\n         */\n        json : null,\n\n        /**\n         * The {@link Core.data.Store store} holding the time ranges information.\n         *\n         * See also {@link Scheduler.model.TimeSpan}\n         *\n         * @member {Core.data.Store} timeRangeStore\n         * @category Models & Stores\n         */\n        /**\n         * A {@link Core.data.Store} instance or a config object.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Models & Stores\n         */\n        timeRangeStore : {\n            value : {\n                id         : 'timeRanges', // no-sanity\n                modelClass : TimeSpan\n            },\n            $config : 'nullify'\n        },\n\n        /**\n         * The {@link Scheduler.data.ResourceTimeRangeStore store} holding the resource time ranges information.\n         *\n         * See also {@link Scheduler.model.ResourceTimeRangeModel}\n         *\n         * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n         * @category Models & Stores\n         */\n        /**\n         * A {@link Scheduler.data.ResourceTimeRangeStore} instance or a config object.\n         * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n         * @category Models & Stores\n         */\n        resourceTimeRangeStore : {\n            value   : {},\n            $config : 'nullify'\n        },\n\n        // Documented in Scheduler/SchedulerPro versions of model/ProjectModel since types differ\n        events             : null,\n        resourceTimeRanges : null\n    }\n\n    //endregion\n\n    //region Properties\n\n    /**\n     * Returns current Project changes as an object consisting of added/modified/removed arrays of records for every\n     * managed store. Returns `null` if no changes exist. Format:\n     *\n     * ```javascript\n     * {\n     *     resources : {\n     *         added    : [{ name : 'New guy' }],\n     *         modified : [{ id : 2, name : 'Mike' }],\n     *         removed  : [{ id : 3 }]\n     *     },\n     *     events : {\n     *         modified : [{  id : 12, name : 'Cool task' }]\n     *     },\n     *     ...\n     * }\n     * ```\n     *\n     * @member {Object} changes\n     * @readonly\n     * @category Models & Stores\n     */\n\n    /**\n     * Get or set data of project stores. The returned data is identical to what\n     * {@link #function-toJSON} returns:\n     *\n     * ```javascript\n     *\n     * const data = scheduler.project.inlineData;\n     *\n     * // data:\n     * {\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     dependenciesData       : [...],\n     *     assignmentsData        : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * }\n     *\n     *\n     * // Plug it back in later\n     * scheduler.project.inlineData = data;\n     * ```\n     *\n     * @property {Object}\n     * @category Inline data\n     */\n    get inlineData() {\n        return StringHelper.safeJsonParse(super.json);\n    }\n\n    set inlineData(inlineData) {\n        this.json = inlineData;\n    }\n\n    //endregion\n\n    //region Functions\n\n    /**\n     * Accepts a \"data package\" consisting of data for the projects stores, which is then loaded into the stores.\n     *\n     * The package can hold data for `EventStore`, `AssignmentStore`, `ResourceStore`, `DependencyStore`,\n     * `TimeRangeStore` and `ResourceTimeRangeStore`. It uses the same format as when creating a project with inline\n     * data:\n     *\n     * ```javascript\n     * await project.loadInlineData({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     * ```\n     *\n     * After populating the stores it commits the project, starting its calculations. By awaiting `loadInlineData()` you\n     * can be sure that project calculations are finished.\n     *\n     * @function loadInlineData\n     * @param {Object} dataPackage A data package as described above\n     * @fires load\n     * @async\n     * @category Inline data\n     */\n\n    /**\n     * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the\n     * underlying graph based calculation engine. The engine performs it calculations async.\n     *\n     * By calling this function, the commit happens right away. And by awaiting it you are sure that project\n     * calculations are finished and that references between records are up to date.\n     *\n     * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.\n     *\n     * ```javascript\n     * // Move an event in time\n     * eventStore.first.shift(1);\n     *\n     * // Trigger calculations directly and wait for them to finish\n     * const result = await project.commitAsync();\n     *\n     * if (result.rejectedWith) {\n     *     // there was a conflict during the scheduling\n     * }\n     * ```\n     *\n     * @async\n     * @function commitAsync\n     * @category Common\n     */\n\n    //endregion\n\n    //region Init\n\n    construct(config = {}) {\n        super.construct(...arguments);\n\n        // These stores are not handled by engine, but still held on project\n\n        if (config.timeRangesData) {\n            this.timeRangeStore.data = config.timeRangesData;\n        }\n\n        if (config.resourceTimeRangesData) {\n            this.resourceTimeRangeStore.data = config.resourceTimeRangesData;\n        }\n    }\n\n    afterConstruct() {\n        super.afterConstruct();\n\n        const me = this;\n\n        !me.timeRangeStore.stm && me.stm.addStore(me.timeRangeStore);\n        !me.resourceTimeRangeStore.stm && me.stm.addStore(me.resourceTimeRangeStore);\n    }\n\n    //endregion\n\n    //region Attaching stores\n\n    // Attach to a store, relaying its change events\n    attachStore(store) {\n        store?.ion({\n            name    : store.$$name,\n            change  : 'relayStoreChange',\n            thisObj : this\n        });\n    }\n\n    // Detach a store, stop relaying its change events\n    detachStore(store) {\n        store && this.detachListeners(store.$$name);\n    }\n\n    relayStoreChange(event) {\n        super.relayStoreChange(event);\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each stores own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event change\n         * @param {Scheduler.model.ProjectModel} source This project\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('change', { store : event.source, ...event, source : this });\n    }\n\n    updateTimeRangeStore(store, oldStore) {\n        this.detachStore(oldStore);\n        this.attachStore(store);\n    }\n\n    setTimeRangeStore(store) {\n        this.timeRangeStore = store;\n    }\n\n    changeTimeRangeStore(store) {\n        // If it's not being nullified, upgrade a config object to be a full store\n        if (store && !store.isStore) {\n            store = this.timeRangeStoreClass.new({\n                modelClass : this.timeRangeModelClass\n            }, store);\n        }\n        return store;\n    }\n\n    updateResourceTimeRangeStore(store, oldStore) {\n        this.detachStore(oldStore);\n        this.attachStore(store);\n    }\n\n    changeResourceTimeRangeStore(store) {\n        // If it's not being nullified, upgrade a config object to be a full store\n        if (store && !store.isStore) {\n            store = this.resourceTimeRangeStoreClass.new({\n                modelClass : this.resourceTimeRangeModelClass\n            }, store);\n        }\n        return store;\n    }\n\n    setResourceTimeRangeStore(store) {\n        this.resourceTimeRangeStore = store;\n    }\n\n    //endregion\n\n    //region Inline data\n\n    get events() {\n        return this.eventStore.records;\n    }\n\n    updateEvents(events) {\n        this.eventStore.data = events;\n    }\n\n    get resourceTimeRanges() {\n        return this.resourceTimeRangeStore.records;\n    }\n\n    updateResourceTimeRanges(resourceTimeRanges) {\n        this.resourceTimeRangeStore.data = resourceTimeRanges;\n    }\n\n    async loadInlineData(data) {\n        // Flag reset in super\n        this.isLoadingInlineData = true;\n\n        // Stores not handled by engine\n        if (data.resourceTimeRangesData) {\n            this.resourceTimeRangeStore.data = data.resourceTimeRangesData;\n        }\n\n        if (data.timeRangesData) {\n            this.timeRangeStore.data = data.timeRangesData;\n        }\n\n        return super.loadInlineData(data);\n    }\n\n    //endregion\n\n    //region JSON\n\n    /**\n     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.\n     *\n     * Used by JSON.stringify to correctly convert this record to json.\n     *\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     *\n     * const json = project.toJSON();\n     *\n     * // json:\n     * {\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     dependenciesData       : [...],\n     *     assignmentsData        : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * }\n     * ```\n     *\n     * Output can be consumed by `loadInlineData()`:\n     *\n     * ```javascript\n     * const json = project.toJSON();\n     *\n     * // Plug it back in later\n     * project.loadInlineData(json);\n     * ```\n     *\n     * @returns {Object}\n     * @category Inline data\n     */\n    toJSON() {\n        const\n            me = this,\n            result = {\n                eventsData             : me.eventStore.toJSON(),\n                resourcesData          : me.resourceStore.toJSON(),\n                dependenciesData       : me.dependencyStore.toJSON(),\n                timeRangesData         : me.timeRangeStore.toJSON(),\n                resourceTimeRangesData : me.resourceTimeRangeStore.toJSON()\n            };\n\n        if (!me.eventStore.usesSingleAssignment) {\n            result.assignmentsData = me.assignmentStore.toJSON();\n        }\n\n        return result;\n    }\n\n    /**\n     * Get or set project data (records from its stores) as a JSON string.\n     *\n     * Get a JSON string:\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     eventsData             : [...],\n     *     resourcesData          : [...],\n     *     assignmentsData        : [...],\n     *     dependenciesData       : [...],\n     *     resourceTimeRangesData : [...],\n     *     timeRangesData         : [...]\n     * });\n     *\n     * const jsonString = project.json;\n     *\n     * // jsonString:\n     * '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     * ```\n     *\n     * Set a JSON string (to populate the project stores):\n     *\n     * ```javascript\n     * project.json = '{\"eventsData\":[...],\"resourcesData\":[...],...}'\n     * ```\n     *\n     * @property {String}\n     * @category Inline data\n     */\n    get json() {\n        return super.json;\n    }\n\n    changeJson(json) {\n        if (typeof json === 'string') {\n            json = StringHelper.safeJsonParse(json);\n        }\n\n        return json;\n    }\n\n    updateJson(json) {\n        json && this.loadInlineData(json);\n    }\n\n    //endregion\n\n    afterChange(toSet, wasSet) {\n        super.afterChange(...arguments);\n\n        if (wasSet.calendar) {\n            this.trigger('calendarChange');\n        }\n    }\n\n    doDestroy() {\n        this.timeRangeStore.destroy();\n        this.resourceTimeRangeStore.destroy();\n\n        super.doDestroy();\n    }\n};\n","/**\n * @module Scheduler/model/mixin/ProjectCurrentConfig\n */\n\n/**\n * Mixin that makes sure current config for a project includes store data and is cleaned up properly.\n *\n * @mixin\n * @private\n */\nexport default Target => class ProjectCurrentConfig extends Target {\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs/fields for the project, with special handling for inline data\n    getCurrentConfig(options) {\n        const\n            me     = this,\n            result = super.getCurrentConfig(options);\n\n        if (result) {\n            for (const storeName of ['eventStore', 'resourceStore', 'assignmentStore', 'dependencyStore', 'timeRangeStore', 'resourceTimeRangeStore']) {\n                const store = me[storeName];\n\n                if (store) {\n                    if (store.count) {\n                        result[store.id + 'Data'] = store.getInlineData(options);\n                    }\n\n                    // Get stores current state, in case it has filters etc added at runtime\n                    const storeState = store.getCurrentConfig(options);\n                    if (storeState && Object.keys(storeState).length > 0) {\n                        result[storeName] = Object.assign(result[storeName] || {}, storeState);\n                    }\n                    // Remove empty store configs\n                    else if (result[storeName] && Object.keys(result[storeName]).length === 0) {\n                        delete result[storeName];\n                    }\n                }\n            }\n\n            if (result.timeRangeStore) {\n                // Exclude default time range modelClass (it is a plain store), spam\n                if (me.timeRangeStore.originalModelClass === me.timeRangeModelClass || me.timeRangeStore.originalModelClass.$name === 'TimeSpan') {\n                    delete result.timeRangeStore.modelClass;\n                }\n\n                // Same for default storeId\n                if (result.timeRangeStore.storeId === 'timeRanges') {\n                    delete result.timeRangeStore.storeId;\n                }\n\n                // Since timeRangeStore is a plain store it is always configured with id, spam\n                if (Object.keys(result.timeRangeStore).length === 1) {\n                    delete result.timeRangeStore;\n                }\n            }\n\n            // Gantt specifics\n            if (me.taskStore.isTaskStore) {\n                delete result.eventModelClass;\n                delete result.eventStoreClass;\n                delete result.children;\n            }\n\n            return result;\n        }\n    }\n};\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/data/util/ModelPersistencyManager\n */\n\n/**\n * This class manages model persistency, it listens to model stores' beforesync event and removes all non persistable\n * records from sync operation. The logic has meaning only for CRUD-less sync operations.\n *\n * @private\n */\nexport default class ModelPersistencyManager extends Base {\n    // region Event attachers\n\n    set eventStore(newEventStore) {\n        const me = this;\n\n        me.eventStoreDetacher && me.eventStoreDetacher();\n        me._eventStore = newEventStore;\n        if (newEventStore && newEventStore.autoCommit) {\n            me.eventStoreDetacher = newEventStore.ion({\n                beforecommit : me.onEventStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n\n    get eventStore() {\n        return this._eventStore;\n    }\n\n    set resourceStore(newResourceStore) {\n        const me = this;\n\n        me.resourceStoreDetacher && me.resourceStoreDetacher();\n        me._resourceStore = newResourceStore;\n\n        if (newResourceStore && newResourceStore.autoCommit) {\n            me.resourceStoreDetacher = newResourceStore.ion({\n                beforecommit : me.onResourceStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n\n    get resourceStore() {\n        return this._resourceStore;\n    }\n\n    set assignmentStore(newAssignmentStore) {\n        const me = this;\n\n        me.assignmentStoreDetacher && me.assignmentStoreDetacher();\n        me._assignmentStore = newAssignmentStore;\n\n        if (newAssignmentStore && newAssignmentStore.autoSync) {\n            me.assignmentStoreDetacher = newAssignmentStore.ion({\n                beforecommit : me.onAssignmentStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n\n    get assignmentStore() {\n        return this._assignmentStore;\n    }\n\n    set dependencyStore(newDependencyStore) {\n        const me = this;\n\n        me.dependencyStoreDetacher && me.dependencyStoreDetacher();\n        me._dependencyStore = newDependencyStore;\n\n        if (newDependencyStore && newDependencyStore.autoSync) {\n            me.dependencyStoreDetacher = newDependencyStore.ion({\n                beforecommit : me.onDependencyStoreBeforeSync,\n                thisObj      : me,\n                detachable   : true,\n                // Just in case\n                prio         : 100\n            });\n        }\n    }\n\n    get dependencyStore() {\n        return this._dependencyStore;\n    }\n\n    // endregion\n\n    // region Event handlers\n\n    onEventStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n\n    onResourceStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n\n    onAssignmentStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n\n    onDependencyStoreBeforeSync({ changes }) {\n        const me = this;\n        me.removeNonPersistableRecordsToCreate(changes);\n        return me.shallContinueSync(changes);\n    }\n\n    // endregion\n\n    // region Management rules\n\n    removeNonPersistableRecordsToCreate(changes) {\n        const recordsToCreate = changes.added || [];\n        let r, i;\n\n        // We remove from the array we iterate thus we iterate from end to start\n        for (i = recordsToCreate.length - 1; i >= 0; --i) {\n            r = recordsToCreate[i];\n            if (!r.isPersistable) {\n                recordsToCreate.splice(recordsToCreate.indexOf(r), 1);\n            }\n        }\n\n        // Prevent empty create request\n        if (recordsToCreate.length === 0) {\n            changes.added.length = 0;\n        }\n    }\n\n    shallContinueSync(options) {\n        return Boolean((options.added && options.added.length > 0) ||\n            (options.modified && options.modified.length > 0) ||\n            (options.removed && options.removed.length > 0));\n    }\n\n    // endregion\n}\n","import VersionHelper from '../../Core/helper/VersionHelper.js';\nimport ProjectModelMixin from './mixin/ProjectModelMixin.js';\nimport ProjectCurrentConfig from './mixin/ProjectCurrentConfig.js';\nimport ModelPersistencyManager from '../data/util/ModelPersistencyManager.js';\n/* <remove-on-release> */\nimport { SchedulerBasicProjectMixin } from '../../Engine/quark/model/scheduler_basic/SchedulerBasicProjectMixin.js';\n/* </remove-on-release> */\nimport { SchedulerCoreProjectMixin } from '../../Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js';\nimport EventModel from './EventModel.js';\nimport DependencyModel from './DependencyModel.js';\nimport ResourceModel from './ResourceModel.js';\nimport AssignmentModel from './AssignmentModel.js';\nimport EventStore from '../data/EventStore.js';\nimport DependencyStore from '../data/DependencyStore.js';\nimport ResourceStore from '../data/ResourceStore.js';\nimport AssignmentStore from '../data/AssignmentStore.js';\n\nconst EngineMixin = /* <remove-on-release> */globalThis.bryntum?.useBasicEngine ? SchedulerBasicProjectMixin : /* </remove-on-release> */SchedulerCoreProjectMixin;\n\n/**\n * @module Scheduler/model/ProjectModel\n */\n\n/**\n * This class represents a global project of your Scheduler - a central place for all data.\n *\n * It holds and links the stores usually used by Scheduler:\n *\n * - {@link Scheduler.data.EventStore}\n * - {@link Scheduler.data.ResourceStore}\n * - {@link Scheduler.data.AssignmentStore}\n * - {@link Scheduler.data.DependencyStore}\n * - {@link #config-timeRangeStore TimeRangeStore}\n * - {@link Scheduler.data.ResourceTimeRangeStore}\n *\n * The project uses a calculation engine to normalize dates and durations. It is also responsible for\n * handling references between models, for example to link an event via an assignment to a resource. These operations\n * are asynchronous, a fact that is hidden when working in the Scheduler UI but which you must know about when performing\n * more advanced operations on the data level.\n *\n * When there is a change to data that requires something else to be recalculated, the project schedules a calculation (a\n * commit) which happens moments later. It is also possible to trigger these calculations directly. This snippet illustrate\n * the process:\n *\n 1. Something changes which requires the project to recalculate, for example adding a new task:\n *\n * ```javascript\n * const [event] = project.eventStore.add({ startDate, endDate });\n * ```\n *\n * 2. A recalculation is scheduled, thus:\n *\n * ```javascript\n * event.duration; // <- Not yet calculated\n * ```\n *\n * 3. Calculate now instead of waiting for the scheduled calculation\n *\n * ```javascript\n * await project.commitAsync();\n *\n * event.duration; // <- Now available\n * ```\n *\n * ## Using inline data\n *\n * The project provides settable property {@link Scheduler.crud.AbstractCrudManager#property-inlineData} that can\n * be used to get data from all its stores at once and to set this data as well. Populating the stores this way can\n * be useful if you cannot or you do not want to use CrudManager for server requests but you pull the data by other\n * means and have it ready outside of ProjectModel. Also, the data from all stores is available in a single\n * assignment statement.\n *\n * ### Getting data\n * ```javascript\n * const data = scheduler.project.inlineData;\n *\n * // use the data in your application\n * ```\n *\n * ### Setting data\n * ```javascript\n * const data = // your function to pull server data\n *\n * scheduler.project.inlineData = data;\n * ```\n *\n * ## Monitoring data changes\n *\n * While it is possible to listen for data changes on the projects individual stores, it is sometimes more convenient\n * to have a centralized place to handle all data changes. By listening for the {@link #event-change change event} your\n * code gets notified when data in any of the stores changes. Useful for example to keep an external data model up to\n * date:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     project: {\n *         listeners : {\n *             change({ store, action, records }) {\n *                 const { $name } = store.constructor;\n *\n *                 if (action === 'add') {\n *                     externalDataModel.add($name, records);\n *                 }\n *\n *                 if (action === 'remove') {\n *                     externalDataModel.remove($name, records);\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Built in StateTrackingManager\n *\n * The project also has a built in {@link Core.data.stm.StateTrackingManager StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). You can enable it to track all\n * project store changes:\n *\n * ```javascript\n * // Turn on auto recording when you create your Scheduler:\n * const scheduler = new Scheduler({\n *    project : {\n *        stm : {\n *            autoRecord : true\n *        }\n *    }\n * });\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * Check out the `undoredo` demo to see it in action.\n *\n * @extends Core/data/Model\n * @mixes Scheduler/model/mixin/ProjectModelMixin\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class ProjectModel extends ProjectCurrentConfig(ProjectModelMixin(EngineMixin)) {\n    static get $name() {\n        return 'ProjectModel';\n    }\n\n    //region Inline data configs & properties\n\n    /**\n     * @hidefields id, readOnly, children, parentId, parentIndex\n     */\n\n    /**\n     * Get/set {@link #property-eventStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.EventModel EventModels} but also accepts an array of\n     * its configuration objects as input.\n     *\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-eventStore}. Should be an array of\n     * {@link Scheduler.model.EventModel EventModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events\n     * @category Inline data\n     */\n\n    /**\n     * Get/set {@link #property-resourceStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.ResourceModel ResourceModels} but also accepts an array\n     * of its configuration objects as input.\n     *\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-resourceStore}. Should be an array of\n     * {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources\n     * @category Inline data\n     */\n\n    /**\n     * Get/set {@link #property-assignmentStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.AssignmentModel AssignmentModels} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-assignmentStore}. Should be an array of\n     * {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} assignments\n     * @category Inline data\n     */\n\n    /**\n     * Get/set {@link #property-dependencyStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.DependencyModel DependencyModels} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-dependencyStore}. Should be an array of\n     * {@link Scheduler.model.DependencyModel DependencyModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies\n     * @category Inline data\n     */\n\n    /**\n     * Get/set {@link #property-timeRangeStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.TimeSpan TimeSpans} but also accepts an\n     * array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-timeRangeStore}. Should be an array of\n     * {@link Scheduler.model.TimeSpan TimeSpans} or its configuration objects.\n     *\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Inline data\n     */\n\n    /**\n     * Get/set {@link #property-resourceTimeRangeStore} data.\n     *\n     * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but\n     * also accepts an array of its configuration objects as input.\n     *\n     * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Inline data\n     */\n    /**\n     * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array\n     * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges\n     * @category Inline data\n     */\n\n    //endregion\n\n    //region Legacy inline data configs & properties\n\n    /**\n     * The initial data, to fill the {@link #property-eventStore} with.\n     * Should be an array of {@link Scheduler.model.EventModel EventModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} eventsData\n     * @category Legacy inline data\n     */\n\n    /**\n     * The initial data, to fill the {@link #property-dependencyStore} with.\n     * Should be an array of {@link Scheduler.model.DependencyModel DependencyModels} or its configuration\n     * objects.\n     *\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} [dependenciesData]\n     * @category Legacy inline data\n     */\n\n    /**\n     * The initial data, to fill the {@link #property-resourceStore} with.\n     * Should be an array of {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.\n     *\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} [resourcesData]\n     * @category Legacy inline data\n     */\n\n    /**\n     * The initial data, to fill the {@link #property-assignmentStore} with.\n     * Should be an array of {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration\n     * objects.\n     *\n     * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} [assignmentsData]\n     * @category Legacy inline data\n     */\n\n    //endregion\n\n    //region Store configs & properties\n\n    /**\n     * The {@link Scheduler.data.EventStore store} holding the events information.\n     *\n     * See also {@link Scheduler.model.EventModel}\n     *\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Models & Stores\n     */\n    /**\n     * An {@link Scheduler.data.EventStore} instance or a config object.\n     * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore\n     * @category Models & Stores\n     */\n\n    /**\n     * The {@link Scheduler.data.DependencyStore store} holding the dependencies information.\n     *\n     * See also {@link Scheduler.model.DependencyModel}\n     *\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Models & Stores\n     */\n    /**\n     * A {@link Scheduler.data.DependencyStore} instance or a config object.\n     * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore\n     * @category Models & Stores\n     */\n\n    /**\n     * The {@link Scheduler.data.ResourceStore store} holding the resources that can be assigned to the events in the event store.\n     *\n     * See also {@link Scheduler.model.ResourceModel}\n     *\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Models & Stores\n     */\n    /**\n     * A {@link Scheduler.data.ResourceStore} instance or a config object.\n     * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore\n     * @category Models & Stores\n     */\n\n    /**\n     * The {@link Scheduler.data.AssignmentStore store} holding the assignments information.\n     *\n     * See also {@link Scheduler.model.AssignmentModel}\n     *\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Models & Stores\n     */\n    /**\n     * An {@link Scheduler.data.AssignmentStore} instance or a config object.\n     * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore\n     * @category Models & Stores\n     */\n\n    //endregion\n\n    //region Configs\n\n    static get defaultConfig() {\n        return {\n            /**\n             * The constructor of the event model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}\n             *\n             * @config {Scheduler.model.EventModel}\n             * @typings {typeof EventModel}\n             * @category Models & Stores\n             */\n            eventModelClass : EventModel,\n\n            /**\n             * The constructor of the dependency model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}\n             *\n             * @config {Scheduler.model.DependencyModel}\n             * @typings {typeof DependencyModel}\n             * @category Models & Stores\n             */\n            dependencyModelClass : DependencyModel,\n\n            /**\n             * The constructor of the resource model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}\n             *\n             * @config {Scheduler.model.ResourceModel}\n             * @typings {typeof ResourceModel}\n             * @category Models & Stores\n             */\n            resourceModelClass : ResourceModel,\n\n            /**\n             * The constructor of the assignment model class, to be used in the project. Will be set as the\n             * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}\n             *\n             * @config {Scheduler.model.AssignmentModel}\n             * @typings {typeof AssignmentModel}\n             * @category Models & Stores\n             */\n            assignmentModelClass : AssignmentModel,\n\n            /**\n             * The constructor to create an event store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.EventStore}\n             * @config {Scheduler.data.EventStore|Object}\n             * @typings {typeof EventStore|object}\n             * @category Models & Stores\n             */\n            eventStoreClass : EventStore,\n\n            /**\n             * The constructor to create a dependency store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.DependencyStore}\n             * @config {Scheduler.data.DependencyStore|Object}\n             * @typings {typeof DependencyStore|object}\n             * @category Models & Stores\n             */\n            dependencyStoreClass : DependencyStore,\n\n            /**\n             * The constructor to create a resource store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.ResourceStore}\n             * @config {Scheduler.data.ResourceStore|Object}\n             * @typings {typeof ResourceStore|object}\n             * @category Models & Stores\n             */\n            resourceStoreClass : ResourceStore,\n\n            /**\n             * The constructor to create an assignment store instance with. Should be a class, subclassing the\n             * {@link Scheduler.data.AssignmentStore}\n             * @config {Scheduler.data.AssignmentStore|Object}\n             * @typings {typeof AssignmentStore|object}\n             * @category Models & Stores\n             */\n            assignmentStoreClass : AssignmentStore\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired when the engine has finished its calculations and the results has been written back to the records.\n     *\n     * ```javascript\n     * scheduler.project.on({\n     *     dataReady() {\n     *        console.log('Calculations finished');\n     *     }\n     * });\n     *\n     * scheduler.eventStore.first.duration = 10;\n     *\n     * // At some point a bit later it will log 'Calculations finished'\n     * ```\n     *\n     * @event dataReady\n     * @param {Scheduler.model.ProjectModel} source The project\n     */\n\n    //endregion\n\n    /**\n     * Silences propagations caused by the project loading.\n     *\n     * Applying the loaded data to the project occurs in two basic stages:\n     *\n     * 1. Data gets into the engine graph which triggers changes propagation\n     * 2. The changes caused by the propagation get written to related stores\n     *\n     * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes\n     * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.\n     *\n     * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.\n     * By default the system treats the data as consistent so this option is `true`.\n     *\n     * ```js\n     * new Scheduler({\n     *     project : {\n     *         // We want scheduling engine to recalculate the data properly\n     *         // so then we could save it back to the server\n     *         silenceInitialCommit : false\n     *     }\n     *     ...\n     * })\n     * ```\n     *\n     * @config {Boolean} silenceInitialCommit\n     * @default true\n     * @category Advanced\n     */\n\n    construct(...args) {\n        super.construct(...args);\n\n        if (VersionHelper.isTestEnv) {\n            globalThis.bryntum.testProject = this;\n        }\n\n        // Moved here from EventStore, since project is now the container instead of it\n        this.modelPersistencyManager = this.createModelPersistencyManager();\n    }\n\n    /**\n     * Creates and returns model persistency manager\n     *\n     * @returns {Scheduler.data.util.ModelPersistencyManager}\n     * @internal\n     */\n    createModelPersistencyManager() {\n        return new ModelPersistencyManager({\n            eventStore      : this,\n            resourceStore   : this.resourceStore,\n            assignmentStore : this.assignmentStore,\n            dependencyStore : this.dependencyStore\n        });\n    }\n\n    doDestroy() {\n        this.modelPersistencyManager.destroy();\n        super.doDestroy();\n    }\n\n    // To comply with TaskBoards expectations\n    get taskStore() {\n        return this.eventStore;\n    }\n}\n\nProjectModel.applyConfigs = true;\n\nProjectModel.initClass();\n"],"names":["diffSecond","date","diff","Date","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","getMilliseconds","later","version","Array","prototype","indexOf","searchElement","this","TypeError","t","Object","len","length","n","arguments","Number","Infinity","Math","floor","abs","k","max","String","trim","replace","array","sort","arr","zeroIsLast","a","b","push","shift","next","val","values","extent","cur","zeroIsLargest","nextIdx","i","nextInvalid","min","zeroVal","start","prev","prevIdx","prevInvalid","day","D","name","range","d","call","isValid","DExtent","month","M","DAYS_IN_MONTH","dy","DStart","Y","end","DEnd","nextRollover","DMax","prevRollover","dayOfWeekCount","dc","dcExtent","ceil","dcStart","dcEnd","getTime","dcMax","dayOfWeek","dw","getDay","dayOfYear","DAY","year","dyExtent","dyMax","hour","h","getHour","hStart","hEnd","isUTC","minute","m","getMin","mStart","mEnd","s","inc","MIN","SEC","MStart","MEnd","second","getSec","cache","time","weekOfMonth","wm","wmExtent","wmStart","wmEnd","wmMax","weekOfYear","wy","wThur","YThur","WEEK","wyExtent","dwFirst","dwLast","wyStart","wyEnd","wyThur","wyMax","getYear","YStart","YEnd","NEVER","fullDate","fd","modifier","after","constraint","value","startDate","before","compile","schedDef","tickConstraint","constraints","constraintsLen","key","nameParts","split","mod","vals","ra","rb","dir","done","nextVal","maxAttempts","curVal","newVal","result","compare","compareFn","undefined","tick","tickSafe","tickStart","schedule","sched","Error","schedules","schedulesLen","exceptions","exceptionsLen","j","getInstances","count","endDate","isRange","lastResult","loopCount","schedStarts","exceptStarts","results","isForward","rStart","rEnd","schedArr","startsArr","setNextStarts","rangesArr","nextStart","setRangeStarts","findNext","updateRangeStarts","calcRangeOverlap","updateNextStarts","maxEndDate","calcMaxEndDate","calcEnd","r","getStart","tickStarts","toString","cleanDate","isNaN","valueOf","newStart","minEndDate","exceptsArr","nextRange","prevRange","setTimeout","fn","scheduleTimeout","now","isDone","clear","clearTimeout","setInterval","timezone","useLocalTime","build","UTC","get","localTime","HOUR","period","parse","cron","expr","hasSeconds","NAMES","JAN","FEB","MAR","APR","MAY","JUN","JUL","AUG","SEP","OCT","NOV","DEC","SUN","MON","TUE","WED","THU","FRI","SAT","REPLACEMENTS","FIELDS","getValue","offset","add","addHash","curSched","hash","field","clone","slice","cloneSchedule","item","except1","except2","addWeekday","incSplit","rangeSplit","addRange","isHash","itemSorter","e","prepared","toUpperCase","prepareExpr","f","component","items","components","parseExpr","recur","curName","every","applyMin","applyMax","last","curArr","x","c","on","first","dayOfMonth","onWeekend","onWeekday","customModifier","id","custom","customPeriod","startingOn","between","splice","and","except","text","str","error","pos","input","TOKENTYPES","eof","rank","dayName","monthName","yearIndex","dayInstance","weekday","weekend","at","also","in","of","onthe","through","jan","feb","mar","apr","may","jun","jul","aug","sep","oct","nov","dec","sun","mon","tue","wed","thu","fri","sat","fir","sec","thi","for","type","startPos","endPos","peek","expected","token","curInput","scanToken","scanTokens","whiteSpace","substring","exec","index","scan","expectedToken","parseThroughExpr","tokenType","parseTokenValue","checkAndParse","nums","parseRanges","concat","parseEvery","num","parseTimePeriod","parseToken","parseOnThe","timePeriod","found","output","parts","parseInt","convertString","parseScheduleExpr","toLowerCase","iterable","gen1Pending","gen2Pending","iterator","Symbol","gen1","gen2","map","func","el","uniqueOnly","seen","Set","has","iterators","concatIterable","iteratorsProducer","ChainedIteratorClass","constructor","derive","copy","iter1","iter2","inBatchesBySize","batchSize","runningBatch","filter","drop","howMany","reduce","initialAcc","acc","uniqueOnlyBy","uniqueBy","some","takeWhile","toArray","from","order","toSet","toMap","Map","flush","element","memoize","MemoizedIteratorClass","CI","super","elements","$iterator","$iterable","alreadyConsumed","MI","MixinInstanceOfProperty","MixinStateProperty","MIXIN_ID","identity","ZeroBaseClass","MixinState","requirements","baseClass","identitySymbol","mixinLambda","walkDepthState","$minimalClass","new","props","me","assign","baseEl","sourceEl","$elementsByTopoLevel","$topoLevels","linearizedByTopoLevelsSource","linearizedByTopoLevels","topoLevels","buildTopoLevels","elementsByTopoLevel","keys","level1","level2","buildElementsByTopoLevel","getOrCreateLevel","topoLevel","elementsAtLevel","set","maxTopoLevel","baseElements","mixin","mixins","level","mixin1","mixin2","getMixinState","symbol","mixinLambdaWrapper","base","extendedClass","defineProperty","hasInstance","isInstanceOfStatic","minimalClass","buildMinimalClass","getBaseClassMixinId","mixinId","baseClassesIds","newId","self","baseCls","minimalClassConstructor","cls","nextHash","fromCharCode","wrapperCls","minimalClassesByLinearHash","mix","Mixin","$","bind","getPrototypeOf","required","lastRequirement","hasOwnProperty","forEach","requirement","mixinState","currentBaseClass","currentIsSub","isPrototypeOf","currentIsSuper","instance","Boolean","isInstanceOf","MixinAny","TimeUnit","ConstraintType","SchedulingMode","DependencyValidationResult","DependencyType","DependenciesCalendar","ProjectType","Direction","ConstraintIntervalSide","MIN_DATE","MAX_DATE","isDateFinite","EdgeInclusion","CalendarIteratorResult","CalendarCache","config","cacheFilledStartDate","cacheFilledEndDate","intervalsCachingChunkDuration","intervalsCachingChunkUnit","Day","maxCacheExtendCycles","maxRange","includeWrappingRangeFrom","ensureCacheFilledForInterval","intervalCache","includeWrappingRange","cacheFilledStartDateN","cacheFilledEndDateN","startDateN","endDateN","fillCache","_1","_2","forEachAvailabilityInterval","options","scope","_options$maxRange","cacheCursorDate","cursorDate","rangeStart","cycle","DateHelper","interval","getIntervalOf","Left","Right","intervalStartDate","intervalEndDate","FullRangeIterated","MaxRangeReached","countFrom","countTill","cacheInterval","StoppedByIterator","getNextInterval","getPrevInterval","MaxCacheExtendCyclesReached","stripDuplicates","CalendarCacheInterval","intervals","calendar","includeInterval","combineWith","getIsWorking","isWorking","normalizeIntervals","filtered","interval1","interval2","getPriorityField","binarySearch","comparator","left","right","mid","IndexPosition","SortedMap","search","insertAt","setValueAt","getEntryAt","getKeyAt","getValueAt","delete","deleteAt","size","indexOfKey","Exact","Next","getAllEntries","IntervalCache","points","leftInfinityKey","rightInfinityKey","emptyInterval","combineIntervalsFn","getDateAt","getPointAt","edgeInclusion","startDateIndex","getIntervalWithStartDateIndex","addInterval","extendInterval","curIndex","lastUpdatedPoint","inclusion","existingInterval","getSummary","label","CalendarCacheSingle","staticIntervalsCached","unspecifiedTimeInterval","_this$calendar$projec","cacheStaticIntervals","parentCache","timeZone","project","forEachRecurrentInterval","startSchedule","getStartDateSchedule","endSchedule","getEndDateSchedule","wrappingEndDate","wrappingStartDate","nextEndDate","getStartOfNextDay","wrappingStartDates","wrappingEndDates","startDates","endDates","recStartDate","recEndDate","TimeZoneHelper","toTimeZone","existingCacheInterval","forEachStaticInterval","_this$calendar$projec2","intervalStore","isStatic","isRecurrent","AbstractPartOfProjectGenericMixin","commitAsync","$project","calculateProject","setProject","getProject","getAssignmentStore","assignmentStore","getDependencyStore","dependencyStore","getEventStore","eventStore","getResourceStore","resourceStore","getCalendarManagerStore","calendarManagerStore","AbstractPartOfProjectStoreMixin","Store","superProto","isLoadingData","disableHasLoadedDataToCommitFlag","construct","asyncEvents","remove","removeAll","change","refresh","move","update","trigger","eventName","param","asyncEvent","action","_objectSpread","isEngineReady","isWritingData","eventsSuspended","dataReadyDetacher","queuedDataReadyEvents","ion","dataReady","once","setStoreData","data","_this$project","syncDataOnLoad","hasLoadedDataToCommit","store","doAutoCommit","suspendCount","addAsync","records","silent","insertAsync","insert","loadDataAsync","AbstractPartOfProjectModelMixin","Model","joinStore","joinedProject","isRepopulatingStores","joinProject","unjoinStore","isReplacing","isLeavingProjectStore","isDestroying","leaveProject","graph","stores","find","setAsync","fieldName","getAsync","_this$project2","isStmRestoring","isRestoringData","stm","isRestoring","CalendarIntervalMixin","fields","defaultValue","getCalendar","resetPriority","priorityField","getDepth","priority","recurrentStartDate","recurrentEndDate","parseDateSchedule","JSON","startDateSchedule","endDateSchedule","CalendarIntervalStore","defaultConfig","modelClass","UnspecifiedTimeIntervalModel","CorePartOfProjectGenericMixin","_this$project3","_this$project4","_this$project5","getEventById","_this$eventStore","getById","getDependencyById","_this$dependencyStore","getResourceById","_this$resourceStore","getAssignmentById","_this$assignmentStore","getCalendarById","_this$calendarManager","AbstractCalendarMixin","subStore","intervalStoreClass","meta","intervalsStore","initIntervalsStore","storeClass","getDefaultConfiguration","calendarIntervalModelClass","processIntervalsStoreData","bumpVersion","isDefault","defaultCalendar","childLevel","maxCalendarRange","calendarCache","accumulateWorkingTime","durationMs","finalDate","remainingDurationInMs","adjustDurationToDST","calendarCacheInterval","dstDiff","getTimezoneOffset","calculateDurationMs","allowNegative","duration","multiplier","calculateEndDate","res","calculateStartDate","skipNonWorkingTime","workingDate","addIntervals","removeInterval","removeIntervals","clearIntervals","clearCache","$calendarCache","unspecifiedTimeIsWorking","parent","isRoot","resetPriorityOfAllIntervals","traverse","insertChild","child","isArray","doDestroy","destroy","isDayHoliday","clearTime","getNext","hasWorkingTime","_intervalStartDate","_intervalEndDate","getDailyHolidaysRanges","getWorkingTimeRanges","entry","getNonWorkingTimeRanges","iconCls","isWorkingTime","fullyContained","workingTimeStart","AbstractHasAssignmentsMixin","getAssignmentFor","resource","assignment","_this$assigned","assigned","isAssignedTo","assignmentCls","addAssignment","event","unassign","removeAssignment","isInActiveTransaction","assignmentsForRemoval","afterEventRemoval","CorePartOfProjectModelMixin","$isCalculating","$changed","$beforeChange","invalidate","bufferedCommitAsync","getCurrentOrProposed","_this$get","hasCurrentOrProposed","propose","changes","_this$recurringTimeSp","recurringTimeSpan","setChanged","setData","calculateInvalidated","finalizeInvalidated","isNotNumber","CIFromSetOrArrayOrValue","delay","Promise","resolve","format","match","number","AbstractAssignmentStoreMixin","allAssignmentsForRemoval","AbstractCalendarManagerStoreMixin","_this$rootNode","rootNode","isDestroyed","record","AbstractDependencyStoreMixin","dependenciesForRemoval","allDependenciesForRemoval","dataAddRemoveActions","AbstractEventStoreMixin","onDataChange","_event$removed","isAddRemove","removed","onNodeRemoveChild","children","flags","toRemove","dependency","processRecord","eventRecord","isDataset","existingRecord","AbstractResourceStoreMixin","afterResourceRemoval","resourceRecord","CoreEventMixin","_startDate","_endDate","_duration","_ref","_this$_startDate","_ref2","_this$_endDate","_ref3","_this$_duration","proposeStartDate","proposeEndDate","proposeDuration","inSet","fromRelationUpdate","skipAccessors","getStartDate","keepDuration","_this$startDate","inSetting","setStartDate","getEndDate","_this$endDate","setEndDate","getDuration","unit","keepStart","durationUnit","setDuration","getDurationUnit","changed","_me$assignmentStore","unresolved","storage","findItem","_me$assignmentStore2","cachedAssignments","applyValue","useProp","afterChange","wasSet","changedStart","changedEnd","changedDuration","calculate","currentOrProposedStartDate","currentOrProposedEndDate","currentOrProposedDuration","currentOrProposedDurationUnit","hourDuration","targetDuration","as","CoreResourceMixin","getResourcesAssignments","query","skipAccessor","CoreAssignmentMixin","isEqual","persist","$master","isPerformingCommit","skipInvalidateIndices","invalidateIndices","resolved","_changed$resource","_changed$event","resourceId","isModel","eventId","CorePartOfProjectStoreMixin","onCommitAsync","emptySet","CoreAssignmentStoreMixin","extraKeys","property","unique","getEventsAssignments","$original","updateIndices","rebuildIndices","afterLoadData","linkAssignments","modelName","masterStore","unlinkAssignments","_assignment$modelName","_assignment$modelName2","getData","CoreCalendarMixin","CoreCalendarManagerStoreMixin","tree","CoreDependencyMixin","_this$dependencyStore2","fromEvent","toEvent","_this$eventStore2","_this$eventStore3","CoreDependencyStoreMixin","getIncomingDepsForEvent","getOutgoingDepsForEvent","CoreHasAssignmentsMixin","_this$project$assignm","$cachedAssignments","deep","ObjectHelper","isObject","skipFieldIdentifiers","CoreHasDependenciesMixin","outgoingDeps","incomingDeps","SchedulerCoreEvent","CoreEventStoreMixin","_this$assignmentStore2","CoreResourceStoreMixin","removing","_this$assignmentStore3","EventsWrapper","Events","DelayableWrapper","Delayable","AbstractProjectMixin","isInitialCommit","isInitialCommitPerformed","isLoadingInlineData","silenceInitialCommit","repopulateStore","repopulateReplica","deferUntilRepopulationIfNeeded","deferId","args","attachStore","detachStore","getStm","SchedulerCoreProjectMixin","configurable","eventModelClass","assignmentModelClass","resourceModelClass","dependencyModelClass","calendarModelClass","eventStoreClass","assignmentStoreClass","resourceStoreClass","dependencyStoreClass","calendarManagerStoreClass","assignmentsData","calendarsData","dependenciesData","eventsData","resourcesData","$invalidated","ongoing","_eventStore$assignmen","isAssignmentStore","isSharingAssignmentStore","loadInlineData","_me$eventStore","_me$dependencyStore","_me$resourceStore","_me$calendarManagerSt","_me$stm","tasksData","commitLoad","joinStoreRecords","unJoinStoreRecords","node","resolveStoreAndModelClass","setEventStore","changeEventStore","oldStore","addStore","hasStore","removeStore","oldEvent","newEvent","updateEventStore","setAssignmentStore","changeAssignmentStore","updateAssignmentStore","setResourceStore","changeResourceStore","oldResource","newResource","updateResourceStore","setDependencyStore","changeDependencyStore","updateDependencyStore","setCalendarManagerStore","changeCalendarManagerStore","_calendarManagerStore","_calendarManagerStore2","updateCalendarManagerStore","$calendar","effectiveCalendar","addEvent","addResource","addDependency","hasPendingAutoCommit","hasTimeout","unScheduleAutoCommit","doCommitAsync","silenceCommit","_store$suspendAutoCom","suspendAutoCommit","isCalculated","beginBatch","endBatch","_store$resumeAutoComm","resumeAutoCommit","propagateAsync","isValidDependency","$stm","StateTrackingManager","disabled","restoringStop","async","disable","enable","applyConfigs","Target","$name","validateResponse","skipSuccessProperty","crudLoadValidationWarningPrefix","crudSyncValidationWarningPrefix","supportShortSyncResponseNote","disableValidationNote","crudLoadValidationMandatoryStores","getStoreLoadResponseWarnings","storeInfo","responded","expectedResponse","messages","storeId","mandatoryStores","rows","includes","getLoadResponseWarnings","response","success","forEachCrudStore","stringify","validateLoadResponse","console","warn","join","getStoreSyncResponseWarnings","requested","missingRows","missingRemoved","phantomIdField","idField","respondedRows","respondedRemoved","showSupportShortSyncResponseNote","added","row","missingIds","supportShortSyncResponse","updated","missingUpdatedRows","getSyncResponseWarnings","requestDesc","request","pack","warnings","validateSyncResponse","AbstractCrudManagerError","CrudManagerRequestError","cfg","_cfg$request","_this$request","message","StringHelper","capitalize","storeSortFn","lhs","rhs","sortProperty","storeLoadSortFn","storeSyncSortFn","_class","$$meta","$meta","isEvents","isDelayable","AbstractCrudManagerValidation","Base","crudRevision","crudStores","storeIdProperty","crudFilterParam","transport","trackResponseType","phantomParentIdField","autoLoad","autoSyncTimeout","autoSync","resetIdsBeforeSync","syncApplySequence","orderedCrudStores","writeAllFields","crudIgnoreUpdates","autoSyncSuspendCounter","crudLoaded","applyingLoadResponse","applyingSyncResponse","callOnFunctions","isCrudManager","_requestId","activeRequests","crudStoresIndex","afterConstruct","_autoLoadPromise","doAutoLoad","loadUrl","_this$transport","_this$transport$load","load","url","updateLoadUrl","setPath","syncUrl","_this$transport2","_this$transport2$sync","sync","updateSyncUrl","getStoreDescriptor","storeDesc","getStore","fillStoreDescriptor","descriptor","updateCrudStoreIndex","getCrudStore","storeDescriptor","thisObj","_crudStores","addCrudStore","loadPriority","syncPriority","_orderedCrudStores","_syncApplySequence","addStoreToApplySequence","internalAddCrudStore","setCrudManager","crudManager","pageSize","autoCommit","createUrl","updateUrl","deleteUrl","readUrl","bindCrudStoreListeners","position","fromStore","_store","ArrayHelper","asArray","addPrioritizedStore","hasCrudStore","findInsertionIndex","hasApplySequenceStore","_this$crudStores","removeCrudStore","foundStore","unbindCrudStoreListeners","removeStoreFromApplySequence","addConfirmed","detachListeners","collection","sequenceKeys","findIndex","onCrudStoreDestroy","source","onCrudStoreChange","crudStoreHasChanges","scheduleAutoSync","suspendAutoSync","resumeAutoSync","doSync","isAutoSyncSuspended","catch","triggerFailedRequestEvents","responseText","fetchOptions","requestType","responseOptions","internalOnResponse","decode","revision","applyResponse","emitCrudStoreEvents","suspendChangesTracking","resumeChangesTracking","skipChangeCheck","isBatchingChanges","isCrudStoreDirty","eventParams","getLoadPackage","requestId","optionsCopy","_store$store","opts","params","page","currentPage","loadCrudStore","append","loadDataToCrudStore","__loading","loadCrudManagerData","isCrudManagerLoading","isCrudManagerSyncing","isLoadingOrSyncing","reject","_options","cancelRequest","desc","Objects","encode","onCrudRequestSuccess","failure","onCrudRequestFailure","sendRequest","cancelled","getActiveCrudManagerRequest","prepareAddedRecordData","isTree","subStoreFields","allFields","persistableData","isPhantom","deletePath","allCount","dataSource","getRange","prepareAdded","list","prepareUpdated","recordData","modificationDataToWrite","getCrudStoreChanges","isEmpty","prepareRemoved","modified","getChangesetPackage","forceSync","getRowsToApplyChangesTo","storeResponse","storePack","_rows","_removed","idDataSource","requestUpdated","requestRemoved","remote","_storeResponse$rows","_storeResponse$remove","respondedIds","responseRecord","getPath","applyChangesToStore","getFieldDataSource","_data$phantomIdField","extraLogEntries","updateData","_updateData$phantomId","_storePack$added","_storePack$updated","recordRequest","extraLogInfo","log","applyChangeset","logEntry","applySyncResponse","applyingChangeset","_request$pack","applyLoadResponse","transformFn","logChanges","storeLog","activeSyncPromise","finally","rawResponse","_request","_fetchOptions$abortCo","signal","abortController","aborted","acceptChanges","revertChanges","revertCrudStoreChanges","_defineProperty","AjaxTransport","defaultMethod","requestPromise","_requestPromise$abort","abort","shouldUseBodyForRequestData","packCfg","method","paramName","transportConfig","requestConfig","ajaxPromise","resultPromise","body","headers","performSend","queryParams","AjaxHelper","fetch","_me$trigger","then","_me$trigger2","ok","callback","beforeSendResult","isPromise","_ajaxPromise$abort","_ajaxPromise","encoder","requestData","_this$encoder","safeJsonStringify","safeJsonParse","LoadMaskable","loadMask","onCrudManagerLoadStart","applySyncMask","syncMask","masked","Mask","mergeConfigs","loadMaskDefaults","bindCrudManager","loadStart","loadCanceled","syncStart","syncCanceled","requestFail","responseReceived","_this$toggleEmptyText","applyLoadMask","toggleEmptyText","onCrudManagerSyncStart","onCrudManagerRequestFinalize","successful","_me$toggleEmptyText","applyMaskError","L","onCrudManagerLoadCanceled","onCrudManagerSyncCanceled","onCrudManagerLoad","onCrudManagerSync","onCrudManagerRequestFail","onAjaxTransportResponseReceived","clearMaskDelay","widgetClass","testConfig","fieldMap","eventResourceKey","buildEventResourceKey","eventKey","resourceKey","internalId","buildIndexKey","fieldToKeys","_toSet$resource","_toSet$event","isProAssignmentModel","_me$resource","_me$project","propagatingSyncChanges","_this$resource","_this$event","_this$event2","resourceName","_this$resource2","getResource","isAssignment","isPersistable","_this$event3","unjoinedStores","hasGeneratedId","isCreating","round","units","shouldRecordFieldChange","oldValue","newValue","oldIdMap","EngineMixin","AssignmentModel","AssignmentModelMixin","PartOfProject","asId","exposeProperties","_$name","newAssignments","_assignment$event","createRecord","isSyncingDataOnLoad","includesAssignment","addIndex","dependentOn","_storage","getOccurrence","originalAssignment","occurrence","isOccurrence","isOccurrenceAssignment","instanceMeta","instanceOrId","occurrenceInstanceMeta","occurrenceAssignment","instanceId","occurrenceMeta","mapAssignmentsForEvent","filterFn","fnSet","filterFnSet","assignments","mapResult","mapAssignmentsForResource","getAssignmentsForEvent","removeAssignmentsForEvent","getAssignmentsForResource","removeAssignmentsForResource","getResourcesForEvent","resources","getEventsForResource","_resource","events","assignEventToResource","assignmentSetupFn","removeExistingAssignments","_r$$original","usesSingleAssignment","_event$assignments","isEventAssignedToResource","existingAssignment","getAssignmentForEventAndResource","_assignmentSetupFn","unassignEventFromResource","assignmentsToRemove","_a$resource","AjaxStore","AssignmentStore","AssignmentStoreMixin","isResourceStore","autoTree","isResourceModel","onRecordIdChange","isFieldModified","isChangingId","updateAssignmentResourceIds","allResourceRecords","_allResourceRecords","getAllDataRecords","getAvailableResources","isDateRangeAvailable","syncId","getEvents","unassignAll","initials","names","_calendar$isWorkingTi","ResourceModel","ResourceModelMixin","GridRowModel","ResourceStore","ResourceStoreMixin","filtersFunction","FunctionHelper","returnTrue","getEventCounts","storeFilterFn","isFiltered","reapplyFilterOnAdd","dateMap","forEachScheduledEvent","getTotalTimeSpan","earliest","latest","lastTotalTimeSpan","isEventPersistable","excludeEvent","generatedParent","allEvents","eventToRemove","isScheduled","intersectSpans","filterEventsForResource","reassignEventFromResourceToResource","newResourceId","startOnly","includeOccurrences","allowPartial","onlyAssigned","dayTime","getDateIndex","lastDateRange","passedFilter","ignoreFilters","setDate","dateFilter","eventStartDate","hasBatchedChange","eventEndDate","betweenLesserEqual","newDateRange","processConfiguredListeners","old","getEventsAsMap","getEventsAsArray","candidateEvents","dateIndex","useDayIndex","eventSet","indexName","recurringEvents","startOfDay","coincidingEvents","isRecurring","apply","getOccurrencesForDateRange","_dateMap","baseEventFilter","_me$recurringEvents","_coincidingEvents","occurrences","lastDate","bucket","lastInteresctingDate","allDay","dateKey","indexNameMap","indexProps","emptyArray","freeze","MILLIS_PER_DAY","DayTime","EventDayIndex","MIDNIGHT","users","_this$dayTime$startOf","endDateMS","dateMS","_eventRecord$endDate$","_eventRecord$endDate","create","returnKey","initialized","initialize","ret","allValues","matches","startShift","removeEvent","_this$dayTime$startOf2","_endDate$getTime","replaced","_wasSet$startDate","_wasSet$endDate","addedCount","removedCount","replacedCount","outgoingEvent","isParent","register","unregister","proto","dayIndices","_super$afterLoadData","syncIndices","onDataReplaced","onModelChange","invalidateDayIndices","_this$dayIndices","dayIndex","registerDayIndex","_this$dayIndices2","unregisterDayIndex","removeUnassignedEvent","singleAssignment","isEventModel","_project$assignmentSt","attachToAssignmentStore","assignmentStoreChange","prio","isChained","_usesSingleAssignment","processRecords","eventRecords","_this$stm","assignmentsToAdd","reassignedFromReplace","generateId","joinRecordsToStore","skipEnforcingSingleAssignment","$processResourceIds","processResourceIds","useRawData","disableDefaultValue","disableDuplicateIdCheck","disableTypeConversion","verifyNoGeneratedIds","loadData","onBeforeRemoveAssignment","isRemoving","isSettingData","assignmentRecord","isRemoved","onProjectAssignmentStoreChange","addPreCommit","isAssigning","isEvent","beforeRemove","removePreCommit","_me$getById","removeAllPreCommit","allRecords","isAssign","globalOccurrences","refreshRecurringEventsCache","isRecurrenceRelatedFieldChange","removeOccurrences","timeSpan","getOccurrencesForTimeSpan","recurrence","forEachOccurrence","getRecurringTimeSpans","RecurringTimeSpansMixin","getRecurringEvents","supportsRecurring","dateFieldsToConvert","constraintDate","deadlineDate","TimeSpan","setLocalDate","_inTimeZone","getLocalDate","fromTimeZone","rawChanges","getFieldPersistentValue","_field$field","convertToTimeZone","metaModified","convertFields","isTask","manuallyScheduled","clearChanges","TimeZonedDatesMixin","allowNull","internal","column","normalize","_me$stores","_eventStore","isEventStore","hasDuration","DH","updateInternalCls","_cls","DomClassList","internalCls","isDomClassList","endingDate","parseFloat","getDurationInUnit","doNotRound","starDate","fullDuration","Duration","magnitude","parseDuration","calcEndDate","calcStartDate","setStartEndDate","dates","startOf","startDateMS","batching","durationMS","asMilliseconds","isMilestone","inSetNormalize","getFieldDefinition","convert","fieldOrClone","isFrozen","validOnly","forEachDate","amount","u","wbsCode","_wbsCode","indexPath","fullCopy","intersects","intersectsRange","myStart","myEnd","splitPoint","oldDuration","cloneDuration","ownNewDuration","unitsChanged","clonedData","toICSString","icsEventConfig","timestamp","DTSTAMP","startEnd","DTSTART","DTEND","icsWrapConfig","BEGIN","VERSION","CALSCALE","PRODID","VersionHelper","scheduler","getVersion","END","eventConfig","UID","CLASS","SUMMARY","recurrenceRule","RRULE","icsItems","eventItems","exportToICS","blob","Blob","BrowserHelper","downloadBlob","isEditable","dayParseRegExp","days","RecurrenceDayRuleEncoder","decodeDay","rawDay","parsedDay","encodeDay","rawDays","frequencyToUnitRe","frequencyToUnit","frequency","counter","isFirst","buildOccurrence","captureLastOccurrence","lastOccurrenceDate","AbstractRecurrenceIterator","processIterationConfig","until","syncingStartDate","isSyncedWithRule","timeSpanStart","earliestVisibleDate","extraArgs","timeSpanStartMS","earliestVisibleDateMS","spansStart","getOccurrenceIndex","getNthDayInPeriod","sign","borderDate","delta","buildDate","dt","isValidPosition","forEachDateAtPositions","positions","datesLength","processed","isInView","occurrenceDate","hasException","isInViewMS","occurenceDate","occurrenceDateMS","DailyRecurrenceIterator","intervalDuration","delayInIntervals","MAX_OCCURRENCES_COUNT","WeeklyRecurrenceIterator","_weekDays","weekStartDay","startHours","startMinutes","startSeconds","startMS","weekStartDate","weekDays","DayRuleEncoder","MonthlyRecurrenceIterator","getNthDayOfMonth","dayNum","daysInMonth","hasPositions","processedDate","weekDayPosition","monthStartDate","monthEndDate","monthDays","weekDay","till","copyTimeValues","inView","sortedMonthDates","YearlyRecurrenceIterator","yearStartDate","yearEndDate","months","recurrenceIterators","convertStringOfIntegerItemsValue","convertStringOfItemsValue","isEqualAsString","value1","value2","convertInteger","it","RecurrenceModel","isRecurrenceModel","dateFormat","_dateFormat","recurrenceIterator","_timeSpan","rule","part","sanitize","_suspendedTimeSpanNotifying","suspendTimeSpanNotifying","resumeTimeSpanNotifying","_me$timeSpan","timeSpanStartDate","isSanitizing","_me$monthDays","sanitizeRecurrenceData","isTimeSpanNotifyingSuspended","onRecurrenceChanged","convertExceptionDatesValue","makeKey","serializeExceptionDatesValue","parseKey","serialize","cancelBatch","detachFromRecurringEvent","_this$firstStore","recurringEvent","firstStore","isRecurringTimeSpansMixin","recurrenceModel","_recurrenceModel","model","setRecurrence","recurrenceEnd","_recurrence","_recurringTimeSpan","occurrenceMap","_occurrencesMap","removeOccurrence","dateOrTimeSpan","isTimeSpan","createRecurrenceKey","removeOccurrencesFrom","_this$recurrence","exceptionDates","_this$meta$modified","occurrenceIndex","occurrenceKey","onStartDate","occurrenceEndDate","constraintType","creatingOccurrence","convertToRealEvent","_wasSet$resourceRecor","resourceRecords","newExceptionDate","addExceptionDate","_this$exceptionDates","updateAssignmentEventIds","newResourceIds","existingResourceIds","onlyInA","toAdd","onlyInB","forEachResource","getAllDayStartDate","getAllDayEndDate","wrapStartDate","wrapEndDate","isDraggable","readOnly","draggable","isResizable","resizable","wasPersistable","batchChanges","postamble","preamble","updateModifiedBagForRecord","applyResourceId","$linkedResources","_this$resources$flatM","_this$resources","flatMap","$links","fromApplyValue","suspendEvents","resumeEvents","mapping","removingResource","reassign","oldResourceId","predecessors","_this$incomingDeps","successors","_this$outgoingDeps","dependencies","_this$incomingDeps2","_this$outgoingDeps2","isInterDay","eventStartMidnight","getAllDayDisplayStartDate","getAllDayDisplayEndDate","isLeaf","EventModel","RecurringTimeSpan","EventModelMixin","EventStore","SharedEventStoreMixin","RecurringEventsMixin","EventStoreMixin","DayIndexMixin","GetEventsMixin","canonicalDependencyTypes","DependencyBaseModel","Type","StartToStart","StartToEnd","EndToStart","EndToEnd","to","_this$unjoinedStores$","hardType","getHardType","setHardType","fromSide","toSide","lag","setLag","lagUnit","getLag","getShortNameOfUnit","fullLag","getDateRange","sourceDate","targetDate","highlight","_this$highlighted$spl","_this$highlighted","classes","highlighted","unhighlight","isHighlightedWith","getConnectorString","raw","rawValue","fromEventName","_this$fromEvent","toEventName","_this$toEvent","DependencyModel","getTypeFromSides","rtl","types","startSide","endSide","reduceEventDependencies","reduceFn","flat","depsGetterFn","getEventDependencies","evt","mapEventDependencies","mapEventPredecessors","reduceEventPredecessors","mapEventSuccessors","reduceEventSuccessors","removeEventDependencies","removeEventPredecessors","removeEventSuccessors","getBySourceTargetId","makeDependencySourceTargetCompositeKey","getDependencyForSourceAndTargetEvents","sourceEvent","targetEvent","getEventsLinkingDependency","dependencyOrFromId","toId","isDependencyModel","isValidDependencyToCreate","fromId","getHighlightedDependencies","dep","getTimeSpanDependencies","DependencyStore","DependencyStoreMixin","AbstractCrudManagerMixin","JsonEncoder","startConfigure","getConfig","_changesToClear","applyProjectResponse","applyingProjectResponse","startDateField","endDateField","delayEnteringReplica","recordsUnlinked","_request$pack2","_me$resumeAutoSync","_me$commitRespondedCh","propagationFlag","loud","commitRespondedChanges","_me$project2","stmDisabled","ignoreRemoteChangesInSTM","shouldClearRecordFieldChange","_field","entries","rest","changesMap","timeRanges","updateAssignments","updateDependencies","updateResources","timeRangeStore","getTimeRanges","updateTimeRanges","getResourceTimeRanges","resourceTimeRangeStore","ResourceTimeRangeModel","domId","domIdPrefix","isResourceTimeRange","foreignKey","foreignStore","relatedCollectionName","nullFieldOnRemove","ResourceTimeRangeStore","_resourceStore","isConfiguring","initRelations","resourceTimeRange","getRanges","span1","span2","_storesWithDates","taskStore","relayStoreChange","convertStoresToTimeZone","ignoreRecordChanges","_records","stmAutoRecord","autoRecord","_r$baselines","$ignoreChange","baselines","bl","updateTimeZone","oldTimeZone","_isConfiguringTimeZone","$config","ProjectModelCommon","ProjectModelTimeZoneMixin","timeRangeModelClass","resourceTimeRangeModelClass","timeRangeStoreClass","resourceTimeRangeStoreClass","timeRangesData","inlineData","json","resourceTimeRangesData","$$name","updateTimeRangeStore","setTimeRangeStore","changeTimeRangeStore","isStore","updateResourceTimeRangeStore","changeResourceTimeRangeStore","setResourceTimeRangeStore","updateEvents","resourceTimeRanges","updateResourceTimeRanges","toJSON","changeJson","updateJson","getCurrentConfig","storeName","getInlineData","storeState","originalModelClass","isTaskStore","ModelPersistencyManager","newEventStore","eventStoreDetacher","beforecommit","onEventStoreBeforeSync","detachable","newResourceStore","resourceStoreDetacher","onResourceStoreBeforeSync","newAssignmentStore","assignmentStoreDetacher","_assignmentStore","onAssignmentStoreBeforeSync","newDependencyStore","dependencyStoreDetacher","_dependencyStore","onDependencyStoreBeforeSync","removeNonPersistableRecordsToCreate","shallContinueSync","recordsToCreate","ProjectModel","ProjectCurrentConfig","ProjectModelMixin","isTestEnv","globalThis","bryntum","testProject","modelPersistencyManager","createModelPersistencyManager","initClass"],"mappings":"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"}