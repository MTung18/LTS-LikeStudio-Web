{"version":3,"file":"SchedulerBase.js","sources":["../../../../Scheduler/lib/Scheduler/view/VerticalTimeAxis.js","../../../../Scheduler/lib/Scheduler/column/VerticalTimeAxisColumn.js","../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayout.js","../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutPack.js","../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutStack.js","../../../../Scheduler/lib/Scheduler/feature/base/ResourceTimeRangesBase.js","../../../../Scheduler/lib/Scheduler/view/DependencyEditor.js","../../../../Scheduler/lib/Scheduler/feature/DependencyEdit.js","../../../../Scheduler/lib/Scheduler/feature/ScheduleContext.js","../../../../Scheduler/lib/Scheduler/feature/EventCopyPaste.js","../../../../Scheduler/lib/Scheduler/feature/EventDrag.js","../../../../Scheduler/lib/Scheduler/feature/EventDragCreate.js","../../../../Scheduler/lib/Scheduler/feature/EventTooltip.js","../../../../Scheduler/lib/Scheduler/feature/StickyEvents.js","../../../../Scheduler/lib/Scheduler/feature/TimeRanges.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDom.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDomEvents.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerEventRendering.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerStores.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerScroll.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerRegions.js","../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerState.js","../../../../Scheduler/lib/Scheduler/view/orientation/HorizontalRendering.js","../../../../Scheduler/lib/Scheduler/eventlayout/VerticalLayout.js","../../../../Scheduler/lib/Scheduler/view/orientation/VerticalRendering.js","../../../../Scheduler/lib/Scheduler/view/SchedulerBase.js"],"sourcesContent":["import TimeAxisBase from './TimeAxisBase.js';\n\n/**\n * @module Scheduler/view/VerticalTimeAxis\n */\n\n/**\n * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.\n * @extends Core/widget/Widget\n * @private\n */\nexport default class VerticalTimeAxis extends TimeAxisBase {\n\n    static get $name() {\n        return 'VerticalTimeAxis';\n    }\n\n    static get configurable() {\n        return {\n            cls : 'b-verticaltimeaxis',\n\n            sizeProperty : 'height',\n\n            positionProperty : 'top',\n\n            wrapText : true\n        };\n    }\n\n    // All cells overlayed in the same space.\n    // For future use.\n    buildHorizontalCells() {\n        const\n            me                   = this,\n            { client }           = me,\n            stickyHeaders        = client?.stickyHeaders,\n            featureHeaderConfigs = [],\n            cellConfigs          = me.levels.reduce((result, level, i) => {\n                if (level.cells) {\n                    result.push(...level.cells?.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map((cell, j, cells) => ({\n                        role      : 'presentation',\n                        className : {\n                            'b-sch-header-timeaxis-cell' : 1,\n                            [cell.headerCellCls]         : cell.headerCellCls,\n                            [`b-align-${cell.align}`]    : cell.align,\n                            'b-last'                     : j === cells.length - 1,\n                            'b-lowest'                   : i === me.levels.length - 1\n                        },\n                        dataset : {\n                            tickIndex      : cell.index,\n                            cellId         : `${i}-${cell.index}`,\n                            headerPosition : i,\n                            // Used in export tests to resolve dates from tick elements\n                            ...globalThis.DEBUG && { date : cell.start.getTime() }\n                        },\n                        style : {\n                            // DomHelper appends px to numeric dimensions\n                            top       : cell.coord,\n                            height    : cell.width,\n                            minHeight : cell.width\n                        },\n                        children : [\n                            {\n                                role      : 'presentation',\n                                className : {\n                                    'b-sch-header-text' : 1,\n                                    'b-sticky-header'   : stickyHeaders\n                                },\n                                html : cell.value\n                            }\n                        ]\n                    })));\n                }\n                return result;\n            }, []);\n\n        // When tested in isolation there is no client\n        client?.getHeaderDomConfigs(featureHeaderConfigs);\n\n        cellConfigs.push(...featureHeaderConfigs);\n\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className : me.widgetClassList,\n            dataset   : {\n                headerFeature  : `headerRow0`,\n                headerPosition : 0\n            },\n            syncOptions : {\n                // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                // wide tickSizes\n                releaseThreshold : 5,\n                syncIdField      : 'cellId'\n            },\n            children : cellConfigs\n        };\n    }\n\n    get height() {\n        return this.size;\n    }\n}\n","import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport VerticalTimeAxis from '../view/VerticalTimeAxis.js';\n\n/**\n * @module Scheduler/column/VerticalTimeAxisColumn\n */\n\n/**\n * A special column containing the time axis labels when the Scheduler is used in vertical mode. You can configure,\n * it using the {@link Scheduler.view.Scheduler#config-verticalTimeAxisColumn} config object.\n *\n * **Note**: this column is sized by flexing to consume full width of its containing {@link Grid.view.SubGrid}. To\n * change width of this column, instead size the subgrid like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     mode           : 'vertical',\n *     subGridConfigs : {\n *         locked : {\n *             width : 300\n *         }\n *     }\n * });\n * ```\n *\n * @extends Grid/column/Column\n */\nexport default class VerticalTimeAxisColumn extends Column {\n\n    static $name = 'VerticalTimeAxisColumn';\n\n    static get type() {\n        return 'verticalTimeAxis';\n    }\n\n    static get defaults() {\n        return {\n            /**\n             * @hideconfigs autoWidth, autoHeight\n             */\n\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            draggable : false,\n\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            groupable : false,\n\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            hideable : false,\n\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            showColumnPicker : false,\n\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            filterable : false,\n\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            sortable : false,\n\n            // /**\n            //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n            //  * @config {Boolean} resizable\n            //  * @default false\n            //  * @category Interaction\n            //  * @hide\n            //  */\n            // resizable : false,\n\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            searchable : false,\n\n            /**\n             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)\n             * @config {String} editor\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            editor : false,\n\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            enableCellContextMenu : false,\n\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n\n            /**\n             * Column minimal width. If value is Number then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 0\n             * @category Layout\n             */\n            minWidth : 0,\n\n            resizable : false,\n\n            cellCls : 'b-verticaltimeaxiscolumn',\n\n            flex : 1,\n\n            alwaysClearCell : false\n        };\n    }\n\n    get isFocusable() {\n        return false;\n    }\n\n    construct(data) {\n        super.construct(...arguments);\n\n        this.view = new VerticalTimeAxis({\n            model  : this.grid.timeAxisViewModel,\n            client : this.grid\n        });\n    }\n\n    renderer({ cellElement, size }) {\n        this.view.render(cellElement);\n\n        size.height = this.view.height;\n    }\n\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n\n        // Remove irrelevant configs\n        delete result.id;\n        delete result.region;\n        delete result.type;\n        delete result.field;\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n\n        return result;\n    }\n}\n\nColumnStore.registerColumnType(VerticalTimeAxisColumn);\n","import Base from '../../Core/Base.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayout\n */\n\n/**\n * Base class for horizontal layouts (HorizontalLayoutPack and HorizontalLayoutStack). Should not be used directly,\n * instead specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack,\n * pack or none):\n *\n * @example\n * let scheduler = new Scheduler({\n *   eventLayout: 'stack'\n * });\n *\n * @abstract\n * @private\n */\nexport default class HorizontalLayout extends Base {\n    static get defaultConfig() {\n        return {\n            nbrOfBandsByResource        : {},\n            bandIndexToPxConvertFn      : null,\n            bandIndexToPxConvertThisObj : null\n        };\n    }\n\n    clearCache(resource) {\n        if (resource) {\n            delete this.nbrOfBandsByResource[resource.id];\n        }\n        else {\n            this.nbrOfBandsByResource = {};\n        }\n    }\n\n    /**\n     * This method performs layout on an array of event render data and returns amount of _bands_. Band is a multiplier of a\n     * configured {@link Scheduler.view.Scheduler#config-rowHeight} to calculate total row height required to fit all\n     * events.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events\n     * @param {Scheduler.model.ResourceModel} resource\n     * @returns {Number}\n     */\n    applyLayout(events, resource) {\n        // Return number of bands required\n        return this.nbrOfBandsByResource[resource.id] = this.layoutEventsInBands(events);\n    }\n\n    /**\n     * This method iterates over events and calculates top position for each of them. Default layouts calculate\n     * positions to avoid events overlapping horizontally (except for the 'none' layout). Pack layout will squeeze events to a single\n     * row by reducing their height, Stack layout will increase the row height and keep event height intact.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events\n     */\n    layoutEventsInBands(events) {\n        throw new Error('Implement in subclass');\n    }\n}\n","import HorizontalLayout from './HorizontalLayout.js';\nimport PackMixin from './PackMixin.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutPack\n */\n\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit\n * available row height\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @mixes Scheduler/eventlayout/PackMixin\n * @private\n */\nexport default class HorizontalLayoutPack extends HorizontalLayout.mixin(PackMixin) {\n    static get $name() {\n        return 'HorizontalLayoutPack';\n    }\n\n    static get configurable() {\n        return {\n            type : 'pack'\n        };\n    }\n\n    // Packs the events to consume as little space as possible\n    layoutEventsInBands(events) {\n        const result = this.packEventsInBands(events, (event, j, slot, slotSize) => {\n            event.height = slotSize;\n            event.top    = slot.start + (j * slotSize);\n        });\n\n        events.forEach(event => {\n            Object.assign(\n                event,\n                this.bandIndexToPxConvertFn.call(\n                    this.bandIndexToPxConvertThisObj || this,\n                    event.top,\n                    event.height,\n                    event.eventRecord,\n                    event.resourceRecord\n                )\n            );\n        });\n\n        return result;\n    }\n}\n","import HorizontalLayout from './HorizontalLayout.js';\n\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutStack\n */\n\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit\n * all overlapping events.\n *\n * This layout is used by default in horizontal mode.\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @private\n */\nexport default class HorizontalLayoutStack extends HorizontalLayout {\n    static get $name() {\n        return 'HorizontalLayoutStack';\n    }\n\n    static get configurable() {\n        return {\n            type : 'stack'\n        };\n    }\n\n    // Input: Array of event layout data\n    // heightRun is used when pre-calculating row heights, taking a cheaper path\n    layoutEventsInBands(events, heightRun = false) {\n        let verticalPosition = 0;\n\n        do {\n            let eventIndex = 0,\n                event      = events[0];\n\n            while (event) {\n                if (!heightRun) {\n                    // Apply band height to the event cfg\n                    event.top = this.bandIndexToPxConvertFn.call(\n                        this.bandIndexToPxConvertThisObj || this,\n                        verticalPosition,\n                        event.eventRecord,\n                        event.resourceRecord\n                    );\n                }\n\n                // Remove it from the array and continue searching\n                events.splice(eventIndex, 1);\n\n                eventIndex = this.findClosestSuccessor(event, events);\n                event = events[eventIndex];\n            }\n\n            verticalPosition++;\n        } while (events.length > 0);\n\n        // Done!\n        return verticalPosition;\n    }\n\n    // TODO: optimize this for better performance with many events per resource\n    findClosestSuccessor(eventRenderData, events) {\n        const\n            { endMS, group } = eventRenderData,\n            isMilestone      = eventRenderData.eventRecord && eventRenderData.eventRecord.duration === 0;\n\n        let minGap      = Infinity,\n            closest,\n            gap,\n            event;\n\n        for (let i = 0, l = events.length; i < l; i++) {\n            event = events[i];\n            gap = event.startMS - endMS;\n\n            if (\n                gap >= 0 && gap < minGap &&\n                // Two milestones should not overlap\n                (gap > 0 || event.endMS - event.startMS > 0 || !isMilestone)\n            ) {\n                // Events are sorted by group, so when we find first event with a different group, we can stop iteration\n                if (this.grouped && group !== event.group) {\n                    break;\n                }\n                closest = i;\n                minGap  = gap;\n            }\n        }\n\n        return closest;\n    }\n}\n","import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/feature/base/ResourceTimeRangesBase\n */\n\n/**\n * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.\n * You should not use this class directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static configurable = {\n        /**\n         * Specify value to use for the tabIndex attribute of range elements\n         * @config {Number}\n         * @category Misc\n         */\n        tabIndex : null\n    };\n\n    static get pluginConfig()  {\n        return {\n            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],\n            override : ['resolveResourceRecord']\n        };\n    }\n\n    // Let Scheduler know if we have ResourceTimeRanges in view or not\n    noFeatureElementsInAxis() {\n        const { timeAxis } = this.client;\n        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));\n    }\n\n    //endregion\n\n    //region Init\n\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n\n        super.doDisable(disable);\n    }\n\n    updateTabIndex() {\n        if (!this.isConfiguring) {\n            this.client.refresh();\n        }\n    }\n\n    //endregion\n\n    getEventsToRender(resource, events) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges\n    // (chained function from Scheduler)\n    onEventDataGenerated(renderData) {\n        const\n            me                       = this,\n            { eventRecord, iconCls } = renderData;\n\n        if (me.shouldInclude(eventRecord)) {\n            if (me.client.isVertical) {\n                renderData.width = renderData.resourceRecord.columnWidth || me.client.resourceColumnWidth;\n            }\n            else {\n                renderData.top = 0;\n            }\n\n            // Flag that we should fill entire row/col\n            renderData.fillSize = true;\n            // Add our own cls\n            renderData.wrapperCls[me.rangeCls] = 1;\n            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;\n            // Add label\n            renderData.eventContent.text = eventRecord.name;\n            renderData.children.push(renderData.eventContent);\n\n            // Allow configuring tabIndex\n            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;\n\n            // Add icon\n            if (iconCls?.length > 0) {\n                renderData.children.unshift({\n                    tag       : 'i',\n                    className : iconCls.toString()\n                });\n            }\n\n            // Event data for DOMSync comparison\n            renderData.eventId = me.generateElementId(eventRecord);\n        }\n    }\n\n    /**\n     * Generates ID from the passed time range record\n     * @param {Scheduler.model.TimeSpan} record\n     * @returns {String} Generated ID for the DOM element\n     * @internal\n     */\n    generateElementId(record) {\n        return record.domId;\n    }\n\n    resolveResourceTimeRangeRecord(rangeElement) {\n        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;\n    }\n\n    getElementFromResourceTimeRangeRecord(record) {\n        // return this.client.foregroundCanvas.querySelector(`[data-event-id=\"${record.domId}\"]`);\n        return this.client.foregroundCanvas.syncIdMap[record.domId];\n    }\n\n    resolveResourceRecord(event) {\n        const record = this.overridden.resolveResourceRecord(...arguments);\n\n        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;\n    }\n\n    shouldInclude(eventRecord) {\n        throw new Error('Implement in subclass');\n    }\n\n    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI\n    onStoreChange(event) {\n        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges\n        if (event.action === 'removeall' || event.action === 'dataset') {\n            this.needsRefresh = true;\n        }\n\n        this.client.onInternalEventStoreChange(event);\n\n        this.needsRefresh = false;\n    }\n}\n\n// No feature based styling needed, do not add a cls to Scheduler\nResourceTimeRangesBase.featureClass = '';\n","import Popup from '../../Core/widget/Popup.js';\n\n/**\n * @module Scheduler/view/DependencyEditor\n */\n\n/**\n * A dependency editor popup.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class DependencyEditor extends Popup {\n\n    static get $name() {\n        return 'DependencyEditor';\n    }\n\n    static get defaultConfig() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n            axisLock : 'flexible'\n        };\n    }\n\n    processWidgetConfig(widget) {\n        const { dependencyEditFeature } = this;\n\n        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {\n            return false;\n        }\n        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {\n            return false;\n        }\n\n        return super.processWidgetConfig(widget);\n    }\n\n    afterShow(...args) {\n        const { deleteButton } = this.widgetMap;\n\n        // Only show delete button if the dependency record belongs to a store\n        if (deleteButton) {\n            deleteButton.hidden = !this.record.isPartOfStore();\n        }\n\n        super.afterShow(...args);\n    }\n\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n}\n","/* eslint-disable no-unused-expressions */\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../../Core/widget/DisplayField.js';\nimport '../../Core/widget/DurationField.js';\nimport DependencyEditor from '../view/DependencyEditor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport Duration from '../../Core/data/Duration.js';\n\n/**\n * @module Scheduler/feature/DependencyEdit\n */\n\n/**\n * Feature that displays a popup containing fields for editing a dependency. Requires the\n * {@link Scheduler.feature.Dependencies} feature to be enabled. Double click a line in the demo below to show the\n * editor.\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * ## Customizing the built-in widgets\n *\n * ```javascript\n *  const scheduler = new Scheduler({\n *      columns : [\n *          { field : 'name', text : 'Name', width : 100 }\n *      ],\n *      features : {\n *          dependencies   : true,\n *          dependencyEdit : {\n *              editorConfig : {\n *                  items : {\n *                      // Custom label for the type field\n *                      typeField : {\n *                          label : 'Kind'\n *                      }\n *                  },\n *\n *                  bbar : {\n *                      items : {\n *                          // Hiding save button\n *                          saveButton : {\n *                              hidden : true\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n *  });\n * ```\n *\n * ## Built in widgets\n *\n * | Widget ref             | Type                              | Weight | Description               |\n * |------------------------|-----------------------------------|--------|---------------------------|\n * | `fromNameField`        | {@link Core.widget.DisplayField}  | 100    | From task name (readonly) |\n * | `toNameField`          | {@link Core.widget.DisplayField}  | 200    | To task name (readonly)   |\n * | `typeField`            | {@link Core.widget.Combo}         | 300    | Edit type                 |\n * | `lagField`             | {@link Core.widget.DurationField} | 400    | Edit lag                  |\n *\n * The built in buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                       |\n * |------------------------|----------------------------|--------|-----------------------------------|\n * | `saveButton`           | {@link Core.widget.Button} | 100    | Save button on the bbar           |\n * | `deleteButton`         | {@link Core.widget.Button} | 200    | Delete button on the bbar         |\n * | `cancelButton`         | {@link Core.widget.Button} | 300    | Cancel editing button on the bbar |\n *\n * This feature is **off** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencyEdit\n * @feature\n */\nexport default class DependencyEdit extends InstancePlugin {\n    //region Config\n\n    static get $name() {\n        return 'DependencyEdit';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * True to hide this editor if a click is detected outside it (defaults to true)\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            autoClose : true,\n\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n\n            /**\n             * True to show a delete button in the form.\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showDeleteButton : true,\n\n            /**\n             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or\n             * `null` to disable editing of dependencies.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'dependencydblclick',\n\n            /**\n             * True to show the lag field for the dependency\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showLagField : false,\n\n            dependencyRecord : null,\n\n            /**\n             * Default editor configuration, used to configure the Popup.\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : {\n                title       : 'L{Edit dependency}',\n                localeClass : this,\n                closable    : true,\n\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the from name\n                     * @member {Core.widget.DisplayField} fromNameField\n                     * @readonly\n                     */\n                    fromNameField : {\n                        type   : 'display',\n                        weight : 100,\n                        label  : 'L{From}'\n                    },\n                    /**\n                     * Reference to the to name field\n                     * @member {Core.widget.DisplayField} toNameField\n                     * @readonly\n                     */\n                    toNameField : {\n                        type   : 'display',\n                        weight : 200,\n                        label  : 'L{To}'\n                    },\n                    /**\n                     * Reference to the type field\n                     * @member {Core.widget.Combo} typeField\n                     * @readonly\n                     */\n                    typeField : {\n                        type                  : 'combo',\n                        weight                : 300,\n                        label                 : 'L{Type}',\n                        name                  : 'type',\n                        editable              : false,\n                        valueField            : 'id',\n                        displayField          : 'name',\n                        localizeDisplayFields : true,\n                        buildItems            : function() {\n                            const dialog = this.parent;\n\n                            return Object.keys(DependencyModel.Type).map(type => {\n\n                                // Do not remove. Assertion strings for Localization sanity check.\n                                // 'L{StartToStart}'\n                                // 'L{StartToEnd}'\n                                // 'L{EndToStart}'\n                                // 'L{EndToEnd}'\n\n                                return {\n                                    id        : DependencyModel.Type[type],\n                                    name      : dialog.L(type),\n                                    localeKey : type\n                                };\n                            });\n                        }\n                    },\n\n                    /**\n                     * Reference to the lag field\n                     * @member {Core.widget.DurationField} lagField\n                     * @readonly\n                     */\n                    lagField : {\n                        type          : 'duration',\n                        weight        : 400,\n                        label         : 'L{Lag}',\n                        name          : 'lag',\n                        allowNegative : true\n                    }\n                },\n\n                bbar : {\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        foo : {\n                            type : 'widget',\n                            cls  : 'b-label-filler'\n                        },\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color : 'b-green',\n                            text  : 'L{Save}'\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            color : 'b-gray',\n                            text  : 'L{Delete}'\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            color : 'b-gray',\n                            text  : 'L{Object.Cancel}'\n                        }\n                    }\n                }\n            }\n        };\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    construct(client, config) {\n        const me = this;\n\n        client.dependencyEdit = me;\n\n        super.construct(client, config);\n\n        if (!client.features.dependencies) {\n            throw new Error('Dependencies feature required when using DependencyEdit');\n        }\n\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : me.onActivateEditor,\n            thisObj           : me\n        });\n    }\n\n    doDestroy() {\n        this.clientListenersDetacher();\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n\n    //endregion\n\n    //region Editing\n\n    changeEditorConfig(config) {\n        const\n            me                         = this,\n            { autoClose, cls, client } = me;\n\n        return ObjectHelper.assign({\n            owner        : client,\n            align        : 'b-t',\n            /* eslint-disable quote-props */\n            'id'         : `${client.id}-dependency-editor`,\n            /* eslint-enable quote-props */\n            autoShow     : false,\n            anchor       : true,\n            scrollAction : 'realign',\n            clippedBy    : [client.timeAxisSubGridElement, client.bodyContainer],\n            constrainTo  : globalThis,\n            autoClose,\n            cls\n        }, config);\n    }\n\n    //endregion\n\n    //region Save\n\n    get isValid() {\n        return Object.values(this.editor.widgetMap).every(field => {\n            if (!field.name || field.hidden) {\n                return true;\n            }\n\n            return field.isValid !== false;\n        });\n    }\n\n    get values() {\n        const values = {};\n\n        this.editor.eachWidget(widget => {\n            if (!widget.name || widget.hidden) return;\n\n            values[widget.name] = widget.value;\n        }, true);\n\n        return values;\n    }\n\n    /**\n     * Template method, intended to be overridden. Called before the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onBeforeSave(dependencyRecord) {}\n\n    /**\n     * Template method, intended to be overridden. Called after the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onAfterSave(dependencyRecord) {}\n\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(dependencyRecord) {\n        const { values } = this;\n\n        // Engine does not understand { magnitude, unit } syntax\n        if (values.lag) {\n            values.lagUnit = values.lag.unit;\n            values.lag = values.lag.magnitude;\n        }\n\n        // Type replaces fromSide/toSide, if they are used\n        if ('type' in values) {\n            dependencyRecord.fromSide != null && (values.fromSide = null);\n            dependencyRecord.toSide != null && (values.toSide = null);\n        }\n\n        // Chronograph doesn't filter out undefined fields, it nullifies them instead\n        // https://github.com/bryntum/chronograph/issues/11\n        ObjectHelper.cleanupProperties(values, true);\n\n        dependencyRecord.set(values);\n    }\n\n    //endregion\n\n    //region Events\n\n    onPopupKeyDown({ event }) {\n        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n\n            this.onSaveClick();\n        }\n    }\n\n    onSaveClick() {\n        if (this.save()) {\n            this.editor.hide();\n        }\n    }\n\n    onDeleteClick() {\n        this.deleteDependency();\n        this.editor.hide();\n    }\n\n    onCancelClick() {\n        this.editor.hide();\n    }\n\n    //region Editing\n\n    // Called from editDependency() to actually show the editor\n    internalShowEditor(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me;\n\n        let showPoint = me.lastPointerDownCoordinate;\n\n        /**\n         * Fires on the owning Scheduler before an dependency is displayed in the editor.\n         * This may be listened for to allow an application to take over dependency editing duties. Returning `false`\n         * stops the default editing UI from being shown.\n         * @event beforeDependencyEdit\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyEdit', {\n            dependencyEdit : me,\n            dependencyRecord\n        }) === false) {\n            return;\n        }\n\n        const editor = me.getEditor(dependencyRecord);\n\n        me.loadRecord(dependencyRecord);\n\n        /**\n         * Fires on the owning Scheduler when the editor for a dependency is available but before it is shown. Allows\n         * manipulating fields before the widget is shown.\n         * @event beforeDependencyEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @param {Core.widget.Popup} editor The editor popup\n         */\n        client.trigger('beforeDependencyEditShow', {\n            dependencyEdit : me,\n            dependencyRecord,\n            editor\n        });\n\n        if (!showPoint) {\n            const center = Rectangle.from(me.client.element).center;\n\n            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];\n        }\n\n        editor.showBy(showPoint);\n    }\n\n    /**\n     * Opens a popup to edit the passed dependency.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit\n     */\n    editDependency(dependencyRecord) {\n        if (this.client.readOnly || dependencyRecord.readOnly) {\n            return;\n        }\n\n        this.internalShowEditor(dependencyRecord);\n    }\n\n    //endregion\n\n    //region Save\n\n    /**\n     * Gets an editor instance. Creates on first call, reuses on consecutive\n     * @internal\n     * @returns {Scheduler.view.DependencyEditor} Editor popup\n     */\n    getEditor() {\n        const me = this;\n\n        let { editor } = me;\n\n        if (editor) {\n            return editor;\n        }\n\n        editor = me.editor = DependencyEditor.new({\n            dependencyEditFeature : me,\n            autoShow              : false,\n            anchor                : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            autoClose             : me.autoClose,\n            cls                   : me.cls,\n            rootElement           : me.client.rootElement,\n            internalListeners     : {\n                keydown : me.onPopupKeyDown,\n                thisObj : me\n            }\n        }, me.editorConfig);\n\n        if (editor.items.length === 0) {\n            console.warn('Editor configured without any `items`');\n        }\n\n        // assign widget refs\n        editor.eachWidget(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n            }\n        });\n\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n\n        return me.editor;\n    }\n\n    //endregion\n\n    //region Delete\n\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(dependency) {\n        const me = this;\n\n        me.fromNameField.value = dependency.fromEvent.name;\n        me.toNameField.value = dependency.toEvent.name;\n\n        if (me.lagField) {\n            me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);\n        }\n\n        me.editor.record = me.dependencyRecord = dependency;\n    }\n\n    //endregion\n\n    //region Stores\n\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeDependencySave\n     * @fires beforeDependencyAdd\n     * @fires afterDependencySave\n     * @returns {*}\n     */\n    async save() {\n        const\n            me                           = this,\n            { client, dependencyRecord } = me;\n\n        if (!dependencyRecord || !me.isValid) {\n            return;\n        }\n\n        const { dependencyStore, values } = me;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is saved\n         * @event beforeDependencySave\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n         * @param {Object} values The new values\n         * @preventable\n         */\n        if (client.trigger('beforeDependencySave', {\n            dependencyRecord,\n            values\n        }) !== false) {\n            me.onBeforeSave(dependencyRecord);\n\n            me.updateRecord(dependencyRecord);\n\n            // Check if this is a new record\n            if (dependencyStore && !dependencyRecord.stores.length) {\n                /**\n                 * Fires on the owning Scheduler before a dependency is added\n                 * @event beforeDependencyAdd\n                 * @on-owner\n                 * @param {Scheduler.view.Scheduler} source The scheduler\n                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature\n                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added\n                 * @preventable\n                 */\n                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) === false) {\n                    return;\n                }\n\n                dependencyStore.add(dependencyRecord);\n            }\n\n            await client.project?.commitAsync();\n\n            /**\n             * Fires on the owning Scheduler after a dependency is successfully saved\n             * @event afterDependencySave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n             */\n            client.trigger('afterDependencySave', { dependencyRecord });\n\n            me.onAfterSave(dependencyRecord);\n        }\n\n        return dependencyRecord;\n    }\n\n    /**\n     * Delete dependency being edited\n     * @private\n     * @fires beforeDependencyDelete\n     */\n    async deleteDependency() {\n        const { client, editor, dependencyRecord } = this;\n\n        /**\n         * Fires on the owning Scheduler before a dependency is deleted\n         * @event beforeDependencyDelete\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyDelete', { dependencyRecord }) !== false) {\n            if (editor.containsFocus) {\n                editor.revertFocus();\n            }\n\n            client.dependencyStore.remove(dependencyRecord);\n            await client.project?.commitAsync();\n\n            return true;\n        }\n\n        return false;\n    }\n\n    get dependencyStore() {\n        return this.client.dependencyStore;\n    }\n    //endregion\n\n    //region Events\n\n    onActivateEditor({ dependency, event }) {\n        if (!this.disabled) {\n            this.lastPointerDownCoordinate = [event.clientX, event.clientY];\n            this.editDependency(dependency);\n        }\n    }\n\n    //endregion\n\n}\n\nGridFeatureManager.registerFeature(DependencyEdit, false);\n","import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n\n/**\n * @module Scheduler/feature/ScheduleContext\n */\n\n/**\n * Allow visually selecting a schedule \"cell\" by clicking, or {@link #config-triggerEvent any other pointer gesture}.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         // Configure as a truthy value to enable the feature\n *         scheduleContext : {\n *             triggerEvent : 'hover',\n *             renderer     : (context, element) => {\n *                 element.innerText = '😎';\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * The contextual details are available in the {@link #property-context} property.\n *\n * **Note that the context is cleared upon change of {@link Scheduler.view.Scheduler#property-viewPreset}\n * such as when zooming in or out.**\n *\n * @extends Core/mixin/InstancePlugin\n * @inlineexample Scheduler/feature/ScheduleContext.js\n * @classtype scheduleContext\n * @feature\n */\nexport default class ScheduleContext extends InstancePlugin.mixin(Delayable) {\n    static get $name() {\n        return 'ScheduleContext';\n    }\n\n    static delayable = {\n        syncContextElement : 'raf'\n    }\n\n    static configurable = {\n        /**\n         * The pointer event type to use to update the context. May be `'hover'` to highlight the\n         * tick context when moving the mouse across the timeline.\n         * @config {'click'|'hover'|'contextmenu'|'mousedown'}\n         * @default\n         */\n        triggerEvent : 'click',\n\n        /**\n         * A function (or the name of a function) which may mutate the contents of the context overlay\n         * element which tracks the active resource/tick context.\n         * @config {String|Function}\n         * @param {TimelineContext} context The context being highlighted.\n         * @param {HTMLElement} element The context highlight element. This will be empty each time.\n         */\n        renderer : null,\n\n        /**\n         * The active context.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        context : {\n            $config : {\n                // Reject non-changes so that when using mousemove, we only update the context\n                // when it changes.\n                equal(c1, c2) {\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        }\n    }\n\n    /**\n     * The contextual information about which cell was clicked on and highlighted.\n     *\n     * When the {@link Scheduler.view.Scheduler#property-viewPreset} is changed (such as when zooming)\n     * the context is cleared and the highlight is removed.\n     *\n     * @member {Object} context\n     * @property {Scheduler.view.TimelineBase} context.source The owning Scheduler\n     * @property {Date} context.date Date at mouse position\n     * @property {Scheduler.model.TimeSpan} context.tick A record which encapsulates the time axis tick clicked on.\n     * @property {Number} context.tickIndex The index of the time axis tick clicked on.\n     * @property {Date} context.tickStartDate The start date of the current time axis tick\n     * @property {Date} context.tickEndDate The end date of the current time axis tick\n     * @property {Grid.row.Row} context.row Clicked row (in horizontal mode only)\n     * @property {Number} context.index Index of clicked resource\n     * @property {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n     * @property {MouseEvent} context.event Browser event\n     */\n\n    construct(client, config) {\n        super.construct(client, config);\n\n        const\n            { triggerEvent } = this,\n            listeners        = {\n                datachange              : 'syncContextElement',\n                timeaxisviewmodelupdate : 'onTimeAxisViewModelUpdate',\n                presetchange            : 'clearContext',\n                thisObj                 : this\n            };\n\n        // If mousemove is our trigger, we cab use the client's timelineContextChange event\n        if (triggerEvent === 'mouseover') {\n            listeners.timelineContextChange = 'onTimelineContextChange';\n        }\n        // Otherwise, we have to listen for the required events on Schedule and events\n        else {\n            // Context menu will be expected to update the context if click or mousedown\n            // is the triggerEvent. Context menu is a mousedown gesture.\n            if (triggerEvent === 'click' || triggerEvent === 'mousedown') {\n                listeners.schedulecontextmenu = 'onScheduleContextGesture';\n            }\n\n            Object.assign(listeners, {\n                [`schedule${triggerEvent}`] : 'onScheduleContextGesture',\n                [`event${triggerEvent}`]    : 'onScheduleContextGesture',\n                ...listeners\n            });\n        }\n\n        // required to work\n        client.useBackgroundCanvas = true;\n\n        client.ion(listeners);\n        client.rowManager.ion({\n            rowheight : 'syncContextElement',\n            thisObj   : this\n        });\n    }\n\n    changeTriggerEvent(triggerEvent) {\n        // Both these things should route through to using the client's timelineContextChange event\n        if (triggerEvent === 'hover' || triggerEvent === 'mousemove') {\n            triggerEvent = 'mouseover';\n        }\n        return triggerEvent;\n    }\n\n    get element() {\n        return this._element || (this._element = DomHelper.createElement({\n            parent    : this.client.backgroundCanvas,\n            className : 'b-schedule-selected-tick'\n        }));\n    }\n\n    // Handle the Client's own timelineContextChange event which it maintains on mousemove\n    onTimelineContextChange({ context }) {\n        this.context = context;\n    }\n\n    // Handle the scheduleclick or eventclick Scheduler events if we re not using mouseover\n    onScheduleContextGesture(context) {\n        this.context = context;\n    }\n\n    onTimeAxisViewModelUpdate({ source : timeAxisViewModel }) {\n        // Just a mutation of existing tick details, sync the element\n        if (timeAxisViewModel.timeAxis.includes(this.context?.tick)) {\n            this.syncContextElement();\n        }\n        // The tick has gone, we have moved to a new ViewPreset, so clear the context.\n        else {\n            this.clearContext();\n        }\n    }\n\n    clearContext() {\n        this.context = null;\n    }\n\n    updateContext(context, oldContext) {\n        this.syncContextElement();\n    }\n\n    syncContextElement() {\n        if (this.context && this.enabled) {\n            const\n                me  = this,\n                {\n                    client,\n                    element,\n                    context,\n                    renderer\n                }   = me,\n                {\n                    isVertical\n                }   = client,\n                {\n                    style\n                }   = element,\n                row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);\n\n            if (row) {\n                const\n                    {\n                        tickStartDate,\n                        tickEndDate,\n                        resourceRecord\n                    } = context,\n                    // get the position clicked based on dates\n                    renderData = client.currentOrientation.getTimeSpanRenderData({\n                        startDate   : tickStartDate,\n                        endDate     : tickEndDate,\n                        startDateMS : tickStartDate.getTime(),\n                        endDateMS   : tickEndDate.getTime()\n                    }, resourceRecord);\n\n                let top, width, height;\n\n                if (isVertical) {\n                    top = renderData.top;\n                    width = renderData.resourceWidth;\n                    height = renderData.height;\n                }\n                else {\n                    top = row.top;\n                    width = renderData.width;\n                    height = row.height;\n                }\n\n                // Move to current cell\n                style.display = '';\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                DomHelper.setTranslateXY(element, renderData.left, top);\n\n                // In case we updated on a datachange action : 'remove' or 'add' event.\n                context.index = row.index;\n\n                // Undo any contents added by the renderer last time round.\n                element.innerHTML = '';\n\n                // Show the context and the element to the renderer\n                renderer && me.callback(renderer, me, [context, element]);\n            }\n            // No row for resource might mean it's scrolled out of view or filtered out\n            // so just hide so that the next valid sync can restore it to visibility\n            else {\n                style.display = 'none';\n            }\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    }\n}\n\nScheduleContext.featureClass = 'b-scheduler-context';\n\nGridFeatureManager.registerFeature(ScheduleContext, false, ['Scheduler']);\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport './ScheduleContext.js';\n\n/**\n * @module Scheduler/feature/EventCopyPaste\n */\n\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste events.\n *\n * This feature also adds entries to the {@link Scheduler/feature/EventMenu} for copying & cutting (see example below\n * for how to configure) and to the {@link Scheduler/feature/ScheduleMenu} for pasting.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}.\n *\n * {@inlineexample Scheduler/feature/EventCopyPaste.js}\n *\n * If you want to highlight the paste location when clicking in the schedule, consider enabling the\n * {@link Scheduler/feature/ScheduleContext} feature.\n *\n * <div class=\"note\">When used with Scheduler Pro, pasting will bypass any constraint set on the event to allow the\n * copy to be assigned the targeted date.</div>\n *\n * This feature is **enabled** by default.\n *\n * ## Customize menu items\n *\n * See {@link Scheduler/feature/EventMenu} and {@link Scheduler/feature/ScheduleMenu} for more info on customizing the\n * menu items supplied by the feature. This snippet illustrates the concept:\n *\n * ```javascript\n * // Custom copy text + remove cut option from event menu:\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 copyEvent : {\n *                     text : 'Copy booking'\n *                 },\n *                 cutEvent  : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Keyboard shortcuts\n *\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys   | Action | Action description                                |\n * |--------|--------|---------------------------------------------------|\n * | Ctrl+C | copy   | Copies selected event(s) into the clipboard.      |\n * | Ctrl+X | cut    | Cuts out selected event(s) into the clipboard.    |\n * | Ctrl+V | paste  | Insert copied or cut event(s) from the clipboard. |\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Scheduler/guides/customization/keymap.md).\n *\n * ## Multi assigned events\n *\n * In a Scheduler that uses single assignment, copying and then pasting creates a clone of the event and assigns it\n * to the target resource. Cutting and pasting moves the original event to the target resource.\n *\n * In a Scheduler using multi assignment, the behaviour is slightly more complex. Cutting and pasting reassigns the\n * event to the target, keeping other assignments of the same event intact. The behaviour for copying and pasting is\n * configurable using the {@link #config-copyPasteAction} config. It accepts two values:\n *\n * * `'clone'` - The default, the event is cloned and the clone is assigned to the target resource. Very similar to the\n *   behaviour with single assignment (event count goes up by 1).\n * * `'assign'` - The original event is assigned to the target resource (event count is unaffected).\n *\n * This snippet shows how to reconfigure it:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventCopyPaste : {\n *             copyPasteAction : 'assign'\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">Copying multiple assignments of the same event will always result in all but the first assignment\n * being removed on paste, since paste targets a single resource and an event can only be assigned to a resource once.\n * </div>\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventCopyPaste\n * @feature\n */\n\nexport default class EventCopyPaste extends InstancePlugin {\n    static $name = 'EventCopyPaste';\n\n    static pluginConfig = {\n        assign : [\n            'copyEvents',\n            'pasteEvents'\n        ],\n        chain : [\n            'populateEventMenu',\n            'populateScheduleMenu',\n            'onEventDataGenerated'\n        ]\n    };\n\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            'Ctrl+C' : 'copy',\n            'Ctrl+X' : 'cut',\n            'Ctrl+V' : 'paste'\n        },\n\n        /**\n         * How to handle a copy paste operation when the host uses multi assignment. Either:\n         *\n         * - `'clone'`  - The default, clone the copied event, assigning the clone to the target resource.\n         * - `'assign'` - Add an assignment for the existing event to the target resource.\n         *\n         * For single assignment mode, it always uses the `'clone'` behaviour.\n         *\n         * @config {'clone'|'assign'}\n         * @default\n         */\n        copyPasteAction : 'clone'\n    };\n\n    clipboardRecords = [];\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        scheduler.ion({\n            eventclick    : this.onEventClick,\n            scheduleclick : this.onScheduleClick,\n            projectChange : () => {\n                this.clearClipboard();\n                this._cellClickedContext = null;\n            },\n            thisObj : this\n        });\n\n        this.scheduler = scheduler;\n    }\n\n    // Used in events to separate events from different features from each other\n    entityName = 'event';\n\n    onEventDataGenerated(eventData) {\n        const { assignmentRecord } = eventData;\n\n        // No assignmentRecord for resource time ranges, which we want to ignore anyway\n        if (assignmentRecord) {\n            eventData.cls['b-cut-item'] = assignmentRecord.meta.isCut;\n        }\n    }\n\n    onEventClick(context) {\n        this._cellClickedContext = null;\n    }\n\n    onScheduleClick(context) {\n        this._cellClickedContext = context;\n    }\n\n    isActionAvailable(keyCombination, action, event) {\n        const cellEdit = this.client.features.cellEdit;\n\n        // No action if\n        // 1. there is selected text on the page\n        // 2. cell editing is active\n        // 3. cursor is not in the grid (filter bar etc)\n        // 4. focus is on specialrow\n        return !this.disabled &&\n            globalThis.getSelection().toString().length === 0 &&\n            !cellEdit?.isEditing &&\n            Boolean(event.target.closest('.b-timeaxissubgrid')) &&\n            !this.client.focusedCell?.isSpecialRow;\n    }\n\n    copy() {\n        this.copyEvents();\n    }\n\n    cut() {\n        this.copyEvents(undefined, true);\n    }\n\n    paste() {\n        this.pasteEvents();\n    }\n\n    /**\n     * Copy events (when using single assignment mode) or assignments (when using multi assignment mode) to clipboard to\n     * paste later\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} [records] Pass records to copy them,\n     * leave out to copying current selection\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut instead\n     * @category Edit\n     */\n    copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {\n        const\n            me                        = this,\n            { scheduler, entityName } = me;\n\n        if (!records?.length) {\n            return;\n        }\n\n        let assignmentRecords = records.slice(); // Slice to not lose records if selection changes\n\n        if (records[0].isEventModel) {\n            assignmentRecords = records.map(r => r.assignments).flat();\n        }\n\n        // Prevent cutting readOnly events\n        if (isCut) {\n            assignmentRecords = assignmentRecords.filter(a => !a.event.readOnly);\n        }\n\n        const eventRecords = assignmentRecords.map(a => a.event);\n\n        /**\n         * Fires on the owning Scheduler before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} records Deprecated, will be removed in 6.0. Use eventRecords instead.\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records about to be copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforeCopy events\n         */\n        if (!assignmentRecords.length || scheduler.readOnly || scheduler.trigger('beforeCopy', {\n            assignmentRecords, records : eventRecords, eventRecords, isCut, entityName\n        }) === false) {\n            return;\n        }\n\n        /**\n         * Fires on the owning Scheduler after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records that were copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other copy events\n         */\n        if (assignmentRecords.length > 0) {\n            scheduler.trigger('copy', { assignmentRecords, eventRecords, isCut, entityName });\n        }\n\n        me._isCut    = isCut;\n        // records is used when call comes from context menu where the current event is the context\n        me.clipboard = { assignmentRecords, eventRecords };\n\n        scheduler.assignmentStore.forEach(assignment => {\n            assignment.meta.isCut = isCut && assignmentRecords.includes(assignment);\n        });\n\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        scheduler.refreshWithTransition();\n    }\n\n    /**\n     * Paste events or assignments to specified date and resource\n     * @fires beforePaste\n     * @fires paste\n     * @param {Date} [date] Date where the events or assignments will be pasted\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] Resource to assign the pasted events or assignments to\n     * @category Edit\n     */\n    pasteEvents(date, resourceRecord) {\n        const\n            me                                   = this,\n            { clipboard, scheduler, entityName } = me,\n            { assignmentRecords, eventRecords }  = clipboard,\n            isCut                                = me._isCut;\n\n        if (arguments.length === 0) {\n            const context  = me._cellClickedContext || {};\n            date           = context.date;\n            resourceRecord = context.resourceRecord;\n        }\n\n        if (resourceRecord) {\n            // No pasting to readOnly resources\n            if (resourceRecord.readOnly) {\n                return;\n            }\n\n            resourceRecord = resourceRecord.$original;\n        }\n\n        /**\n         * Fires on the owning Scheduler before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} records Deprecated, will be removed in 6.0. Use eventRecords instead.\n         * @param {Scheduler.model.EventModel[]} eventRecords The events about to be pasted\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignments about to be pasted\n         * @param {Date} date The date when the pasted events will be scheduled\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record, the clipboard\n         * event records will be assigned to this resource.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforePaste events\n         */\n\n        if (\n            !clipboard ||\n            scheduler.trigger('beforePaste',\n                {\n                    assignmentRecords,\n                    records        : eventRecords,\n                    eventRecords,\n                    resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                    date,\n                    isCut,\n                    entityName\n                }) === false\n        ) {\n            return;\n        }\n\n        let toFocus = null;\n\n        const pastedEvents = new Set();\n\n        for (const assignmentRecord of assignmentRecords) {\n            let { event }            = assignmentRecord;\n            const\n                targetResourceRecord = resourceRecord || assignmentRecord.resource,\n                targetDate           = date || assignmentRecord.event.startDate;\n\n            // Pasting targets a specific resource, we cannot have multiple assignments to the same so remove all but\n            // the first (happens when pasting multiple assignments of the same event)\n            if (pastedEvents.has(event)) {\n                if (isCut) {\n                    assignmentRecord.remove();\n                }\n                continue;\n            }\n\n            pastedEvents.add(event);\n\n            // Cut always means reassign\n            if (isCut) {\n                assignmentRecord.meta.isCut = false;\n                assignmentRecord.resource   = targetResourceRecord;\n                toFocus                     = assignmentRecord;\n            }\n            // Copy creates a new event in single assignment, or when configured to copy\n            else if (scheduler.eventStore.usesSingleAssignment || me.copyPasteAction === 'clone') {\n                event      = event.copy();\n                event.name = me.generateNewName(event);\n                scheduler.eventStore.add(event);\n                event.assign(targetResourceRecord);\n                toFocus = scheduler.assignmentStore.last;\n            }\n            // Safeguard against pasting on a resource where the event is already assigned,\n            // a new assignment in multiassign mode will only change the date in such case\n            else if (!event.resources.includes(targetResourceRecord)) {\n                const newAssignmentRecord    = assignmentRecord.copy();\n                newAssignmentRecord.resource = targetResourceRecord;\n                [toFocus]                    = scheduler.assignmentStore.add(newAssignmentRecord);\n            }\n\n            event.startDate = targetDate;\n\n            // Pro specific, to allow event to appear where pasted\n            if (event.constraintDate) {\n                event.constraintDate = null;\n            }\n        }\n\n        /**\n         * Fires on the owning Scheduler after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords Pasted events\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Pasted assignments\n         * @param {Date} date date Pasted to this date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other paste events\n         */\n        if (clipboard) {\n            scheduler.trigger('paste', { assignmentRecords, eventRecords, resourceRecord, date, isCut, entityName });\n        }\n\n        // Focus the last pasted assignment\n        const detacher = scheduler.ion({\n            renderEvent({ assignmentRecord }) {\n                if (assignmentRecord === toFocus) {\n                    scheduler.navigateTo(assignmentRecord, { scrollIntoView : false });\n                    detacher();\n                }\n            }\n        });\n\n        if (isCut) {\n            me.clearClipboard();\n        }\n    }\n\n    /**\n     * Clears the clipboard and refreshes the UI\n     */\n    clearClipboard() {\n        const me = this;\n        if (me._isCut) {\n            me.clipboard.assignmentRecords.forEach(assignment => {\n                assignment.meta.isCut = false;\n            });\n            me.scheduler.refreshWithTransition();\n            me._isCut = false;\n        }\n        // reset clipboard\n        me.clipboard = null;\n    }\n\n    populateEventMenu({ assignmentRecord, items }) {\n        const me = this;\n\n        if (!me.scheduler.readOnly) {\n            items.copyEvent = {\n                text        : 'L{copyEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => me.copyEvents([assignmentRecord].concat(me.scheduler.selectedAssignments.filter(rec => rec !== assignmentRecord)))\n            };\n\n            items.cutEvent = {\n                text        : 'L{cutEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 120,\n                disabled    : assignmentRecord.event.readOnly,\n                onItem      : () => me.copyEvents([assignmentRecord].concat(me.scheduler.selectedAssignments.filter(rec => rec !== assignmentRecord)), true)\n            };\n        }\n    }\n\n    populateScheduleMenu({ items, resourceRecord }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        if (!scheduler.readOnly && me.clipboard) {\n            items.pasteEvent = {\n                text        : 'L{pasteEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                disabled    : scheduler.resourceStore.count === 0 || resourceRecord.readOnly,\n                weight      : 110,\n                onItem      : ({ date, resourceRecord }) => me.pasteEvents(date, resourceRecord, scheduler.getRowFor(resourceRecord))\n            };\n        }\n    }\n\n    /**\n     * A method used to generate the name for a copy pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord The new eventRecord being pasted\n     * @returns {String}\n     */\n    generateNewName(eventRecord) {\n        const originalName = eventRecord[this.nameField];\n\n        let counter = 2;\n\n        while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n\n        return `${originalName} - ${counter}`;\n    }\n}\n\nEventCopyPaste.featureClass = 'b-event-copypaste';\n\nGridFeatureManager.registerFeature(EventCopyPaste, true, 'Scheduler');\n","/* eslint-disable no-unused-expressions */\nimport DragBase from './base/DragBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n\n/**\n * @module Scheduler/feature/EventDrag\n */\n\n/**\n * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.\n *\n * This feature is **enabled** by default\n *\n * ## Customizing the drag drop tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * features: {\n *     eventDrag : {\n *         // A minimal start date tooltip\n *         tooltipTemplate : ({ eventRecord, startDate }) => {\n *             return DateHelper.format(startDate, 'HH:mm');\n *         }\n *     }\n * }\n * ```\n *\n * ## Constraining the drag drop area\n *\n * You can constrain how the dragged event is allowed to move by using the following configs\n * * {@link #config-constrainDragToResource} Resource fixed, only allowed to change start date\n * * {@link #config-constrainDragToTimeSlot} Start date is fixed, only move between resources\n * * {@link Scheduler.view.Scheduler#config-getDateConstraints} A method on the Scheduler instance\n *    which lets you define the date range for the dragged event programmatically\n *\n * ```js\n * // Enable dragging + constrain drag to current resource\n * const scheduler = new Scheduler({\n *     features : {\n *         eventDrag : {\n *             constrainDragToResource : true\n *         }\n *     }\n * });\n * ```\n * ## Drag drop events from outside\n *\n * Dragging unplanned events from an external grid is a very popular use case. There are\n * several demos showing you how to do this. Please see the [Drag from grid demo](../examples/dragfromgrid)\n * and study the **Drag from grid guide** to learn more.\n *\n * ## Drag drop events to outside target\n *\n * You can also drag events outside the schedule area by setting {@link #config-constrainDragToTimeline} to `false`. You\n * should also either:\n * * provide a {@link #config-validatorFn} to programmatically define if a drop location is valid or not\n * * configure a {@link #config-externalDropTargetSelector} CSS selector to define where drops are allowed\n *\n * See [this demo](../examples/drag-outside) to see this in action.\n *\n * ## Validating drag drop\n *\n * It is easy to programmatically decide what is a valid drag drop operation. Use the {@link #config-validatorFn}\n * and return either `true` / `false` (optionally a message to show to the user).\n *\n * ```javascript\n * features : {\n *     eventDrag : {\n *        validatorFn({ eventRecords, newResource }) {\n *            const task  = eventRecords[0],\n *                  valid = newResource.role === task.resource.role;\n *\n *            return {\n *                valid   : newResource.role === task.resource.role,\n *                message : valid ? '' : 'Resource role does not match required role for this task'\n *            };\n *        }\n *     }\n * }\n * ```\n * See [this demo](../examples/validation) to see validation in action.\n *\n * If you instead want to do a single validation upon drop, you can listen to {@link #event-beforeEventDropFinalize}\n * and set the `valid` flag on the context object provided.\n *\n * ```javascript\n *   const scheduler = new Scheduler({\n *      listeners : {\n *          beforeEventDropFinalize({ context }) {\n *              const { eventRecords } = context;\n *              // Don't allow dropping events in the past\n *              context.valid = Date.now() <= eventRecords[0].startDate;\n *          }\n *      }\n *  });\n * ```\n *\n * ## Preventing drag of certain events\n *\n * To prevent certain events from being dragged, you have two options. You can set {@link Scheduler.model.EventModel#field-draggable}\n * to `false` in your data, or you can listen for the {@link Scheduler.view.Scheduler#event-beforeEventDrag} event and\n * return `false` to block the drag.\n *\n * ```javascript\n * new Scheduler({\n *    listeners : {\n *        beforeEventDrag({ eventRecord }) {\n *            // Don't allow dragging events that have already started\n *            return Date.now() <= eventRecord.startDate;\n *        }\n *    }\n * })\n * ```\n *\n * @extends Scheduler/feature/base/DragBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventDrag.js\n * @classtype eventDrag\n * @feature\n */\nexport default class EventDrag extends DragBase {\n    //region Config\n\n    static get $name() {\n        return 'EventDrag';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Template used to generate drag tooltip contents.\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             dragTipTemplate({eventRecord, startText}) {\n             *                 return `${eventRecord.name}: ${startText}`\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Boolean} data.valid Currently over a valid drop target or not\n             * @param {Date} data.startDate New start date\n             * @param {Date} data.endDate New end date\n             * @returns {String}\n             */\n\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @member {Boolean} constrainDragToResource\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToResource : false,\n\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @member {Boolean} constrainDragToTimeSlot\n             */\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeSlot : false,\n\n            /**\n             * A CSS selector specifying elements outside the scheduler element which are valid drop targets.\n             * @config {String}\n             */\n            externalDropTargetSelector : null,\n\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on the item being\n             * dragged. This function is called during the drag and drop process and also after the drop is made.\n             * Return `true` if the new position is valid, `false` to prevent the drag.\n             *\n             * ```javascript\n             * features : {\n             *     eventDrag : {\n             *         validatorFn({ eventRecords, newResource }) {\n             *             const\n             *                 task  = eventRecords[0],\n             *                 valid = newResource.role === task.resource.role;\n             *\n             *             return {\n             *                 valid   : newResource.role === task.resource.role,\n             *                 message : valid ? '' : 'Resource role does not match required role for this task'\n             *             };\n             *         }\n             *     }\n             * }\n             * ```\n             * @param {Object} context A drag drop context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records which were dragged\n             * @param {Scheduler.model.EventModel[]} context.eventRecords Event records which were dragged\n             * @param {Scheduler.model.ResourceModel} context.newResource New resource record\n             * @param {Scheduler.model.EventModel} context.targetEventRecord Currently hovering this event record\n             * @param {Event} event The event object\n             * @returns {Boolean|Object} `true` if this validation passes, `false` if it does not.\n             *\n             * Or an object with 2 properties: `valid` -  Boolean `true`/`false` depending on validity,\n             * and `message` - String with a custom error message to display when invalid.\n             * @config {Function}\n             */\n            validatorFn : () => {},\n\n            /**\n             * The `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @member {Boolean} unifiedDrag\n             */\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @config {Boolean}\n             * @default false\n             */\n            unifiedDrag : null,\n\n            /**\n             * A hook that allows manipulating the position the drag proxy snaps to. Manipulate the `snapTo` property\n             * to alter snap position.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             snapToPosition({ eventRecord, snapTo }) {\n             *                 if (eventRecord.late) {\n             *                     snapTo.x = 400;\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord Dragged assignment\n             * @param {Scheduler.model.EventModel} context.eventRecord Dragged event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord Currently over this resource\n             * @param {Date} context.startDate Start date for current position\n             * @param {Date} context.endDate End date for current position\n             * @param {Object} context.snapTo\n             * @param {Number} context.snapTo.x X to snap to\n             * @param {Number} context.snapTo.y Y to snap to\n             */\n            snapToPosition : null,\n\n            /**\n             * A modifier key (CTRL, SHIFT, ALT, META) that when pressed will copy an event instead of moving it. Set to\n             * empty string to disable copying\n             * @prp {'CTRL'|'ALT'|'SHIFT'|'META'|''}\n             * @default\n             */\n            copyKey : 'SHIFT',\n\n            /**\n             * Event can be copied two ways: either by adding new assignment to an existing event ('assignment'), or\n             * by copying the event itself ('event'). 'auto' mode will pick 'event' for a single-assignment mode (when\n             * event has `resourceId` field) and 'assignment' mode otherwise.\n             * @prp {'auto'|'assignment'|'event'}\n             * @default\n             */\n            copyMode : 'auto',\n\n            /**\n             * Mode of the current drag drop operation.\n             * @member {'move'|'copy'}\n             * @readonly\n             */\n            mode : 'move',\n\n            capitalizedEventName : null\n        };\n    }\n\n    afterConstruct() {\n        this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;\n        super.afterConstruct(...arguments);\n    }\n\n    //endregion\n\n    changeMode(value) {\n        const { dragData, copyMode } = this;\n\n        // Do not create assignments in case scheduler doesn't use multiple assignments\n        // Do not allow to copy recurring events\n        if (\n            (copyMode === 'event' || copyMode === 'auto' ||\n                copyMode === 'assignment' && !this.scheduler.eventStore.usesSingleAssignment) &&\n            (!dragData || dragData.eventRecords.every(r => !r.isRecurring))\n        ) {\n            return value;\n        }\n    }\n\n    updateMode(mode) {\n        if (this.dragData) {\n            if (mode === 'copy') {\n                this.setCopying();\n            }\n            else {\n                this.setMoving();\n            }\n\n            /**\n             * Triggered when drag mode is changed, for example when copy key is\n             * pressed or released while dragging.\n             * @event eventDragModeChange\n             * @param {String} mode Drag mode, could be either 'move', 'copy', or 'auto'\n             * @on-owner\n             */\n            this.client.trigger('eventDragModeChange', { mode });\n        }\n    }\n\n    setCopying() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        // Check if proxies are added to the DOM by checking if any of them is\n        if (!dragData.eventBarCopies.some(el => el.isConnected)) {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.add('b-drag-proxy-copy');\n                // hidden class can be added by the drag feature if we're dragging event outside\n                el.classList.remove('b-hidden');\n\n                dragData.context.grabbedParent.appendChild(el);\n                // Mark this node as ignored for the DomSync\n                el.retainElement = true;\n            });\n        }\n        else {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.remove('b-hidden');\n            });\n        }\n    }\n\n    setMoving() {\n        const { dragData } = this;\n\n        if (!dragData) {\n            return;\n        }\n\n        dragData.eventBarCopies.forEach(el => {\n            el.classList.add('b-hidden');\n        });\n    }\n\n    //region Events\n\n    /**\n     * Fired on the owning Scheduler to allow implementer to use asynchronous finalization by setting `context.async = true`\n     * in the listener, to show a confirmation popup etc.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * For synchronous one-time validation, simply set `context.valid` to true or false.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.valid = false;\n     *  })\n     * ```\n     * @event beforeEventDropFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to not finalize the drag-drop operation immediately (e.g. to wait for user confirmation)\n     * @param {Scheduler.model.EventModel[]} context.eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records being dragged\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {Boolean} context.valid Set this to `false` to abort the drop immediately.\n     * @param {Function} context.finalize Call this method after an **async** finalization flow, to finalize the drag-drop operation. This method accepts one\n     * argument: pass `true` to update records, or `false` to ignore changes\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after event drop\n     * @event afterEventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Boolean} valid\n     * @param {Object} context\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when an event is dropped\n     * @event eventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {HTMLElement} externalDropTarget The HTML element dropped upon, if drop happened on a valid external drop target\n     * @param {Boolean} isCopy\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler before event dragging starts. Return `false` to prevent the action.\n     * @event beforeEventDrag\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record the drag starts from\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event dragging starts\n     * @event eventDragStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler when event is dragged\n     * @event eventDrag\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {Date} startDate Start date for the current location\n     * @param {Date} endDate End date for the current location\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag started from\n     * @param {Scheduler.model.ResourceModel} newResource Resource at the current location\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to `false` to signal that the current drop position is invalid.\n     * @param {MouseEvent} domEvent Browser event\n     */\n\n    /**\n     * Fired on the owning Scheduler after an event drag operation has been aborted\n     * @event eventDragAbort\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation regardless of the operation being cancelled or not\n     * @event eventDragReset\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     */\n    //endregion\n\n    //region Data layer\n\n    // Deprecated. Use this.client instead\n    get scheduler() {\n        return this.client;\n    }\n\n    //endregion\n\n    //#region Drag lifecycle\n\n    onAfterDragStart(event) {\n        const\n            me                        = this,\n            { context : { element } } = event;\n\n        super.onAfterDragStart(event);\n\n        me.handleKeyDownOrMove(event.event);\n\n        me.keyEventDetacher = EventHelper.on({\n            // In case we drag event between scheduler focused event gets moved and focus\n            // moves to the body. We only need to read the key from this event\n            element : DomHelper.getRootElement(element),\n            keydown : me.handleKeyDownOrMove,\n            keyup   : me.handleKeyUp,\n            thisObj : me\n        });\n    }\n\n    onDragReset(event) {\n        super.onDragReset(event);\n\n        this.keyEventDetacher?.();\n\n        this.mode = 'move';\n    }\n\n    onDrop(event) {\n        // Always remove proxy on drop\n        this.dragData.eventBarCopies?.forEach(el => el.remove());\n\n        return super.onDrop(event);\n    }\n\n    //#endregion\n\n    //region Drag events\n\n    getDraggableElement(el) {\n        return el?.closest(this.drag.targetSelector);\n    }\n\n    resolveEventRecord(eventElement, client = this.client) {\n        return client.resolveEventRecord(eventElement);\n    }\n\n    isElementDraggable(el, event) {\n        const\n            me              = this,\n            { client }      = me,\n            eventElement    = me.getDraggableElement(el);\n\n        if (!eventElement || me.disabled || client.readOnly) {\n            return false;\n        }\n\n        // displaying something resizable within the event?\n        if (el.matches('[class$=\"-handle\"]')) {\n            return false;\n        }\n\n        const eventRecord = me.resolveEventRecord(eventElement, client);\n\n        if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {\n            return false;\n        }\n\n        // Hook for features that need to prevent drag\n        const prevented = client[`is${me.capitalizedEventName}ElementDraggable`]?.(\n            eventElement, eventRecord, el, event\n        ) === false;\n\n        return !prevented;\n    }\n\n    getTriggerParams(dragData) {\n        const { assignmentRecords, eventRecords, resourceRecord, browserEvent: domEvent } = dragData;\n\n        return {\n            // `context` is now private, but used in WebSocketHelper\n            context : dragData,\n            eventRecords,\n            resourceRecord,\n            assignmentRecords,\n            event   : domEvent, // Deprecated, remove on  6.0?\n            domEvent\n        };\n    }\n\n    triggerBeforeEventDrag(eventType, event) {\n        return this.client.trigger(eventType, event);\n    }\n\n    triggerEventDrag(dragData, start) {\n        this.client.trigger('eventDrag', Object.assign(this.getTriggerParams(dragData), {\n            startDate   : dragData.startDate,\n            endDate     : dragData.endDate,\n            newResource : dragData.newResource\n        }));\n    }\n\n    triggerDragStart(dragData) {\n        this.client.navigator.skipNextClick = true;\n\n        this.client.trigger('eventDragStart', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbort(dragData) {\n        this.client.trigger('eventDragAbort', this.getTriggerParams(dragData));\n    }\n\n    triggerDragAbortFinalized(dragData) {\n        this.client.trigger('eventDragAbortFinalized', this.getTriggerParams(dragData));\n    }\n\n    triggerAfterDrop(dragData, valid) {\n        const me = this;\n\n        me.currentOverClient.trigger('afterEventDrop', Object.assign(me.getTriggerParams(dragData), {\n            valid\n        }));\n\n        if (!valid) {\n            // Edge cases:\n            // 1. If this drag was a no-op, and underlying data was changed while drag was ongoing (e.g. web socket\n            // push), we need to manually force a view refresh to ensure a correct render state\n            //\n            // or\n            // 2. Events were removed before we dropped at an invalid point\n            const\n                { assignmentStore, eventStore } = me.client,\n                needRefresh                     = me.dragData.initialAssignmentsState.find(({\n                    resource, assignment\n                }, i) => {\n                    return !assignmentStore.includes(assignment) ||\n                        !eventStore.includes(assignment.event) ||\n                        resource.id !== me.dragData.assignmentRecords[i]?.resourceId;\n                });\n\n            if (needRefresh) {\n                me.client.refresh();\n            }\n        }\n        // Reset the skipNextClick after a potential click event fires. https://github.com/bryntum/support/issues/5135\n        me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);\n    }\n\n    handleKeyDownOrMove(event) {\n        if (this.mode !== 'copy') {\n            if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase() || event[`${this.copyKey.toLowerCase()}Key`]) {\n                this.mode = 'copy';\n            }\n        }\n    }\n\n    handleKeyUp(event) {\n        if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {\n            this.mode = 'move';\n        }\n    }\n\n    //endregion\n\n    //region Finalization & validation\n\n    /**\n     * Checks if an event can be dropped on the specified position.\n     * @private\n     * @returns {Boolean} Valid (true) or invalid (false)\n     */\n    isValidDrop(dragData) {\n        const\n            { newResource, resourceRecord } = dragData,\n            sourceRecord                    = dragData.draggedEntities[0];\n\n        // Only allowed to drop outside scheduler element if we hit an element matching the externalDropTargetSelector\n        if (!newResource) {\n            return (!this.constrainDragToTimeline && this.externalDropTargetSelector) ? Boolean(dragData.browserEvent.target.closest(this.externalDropTargetSelector)) : false;\n        }\n\n        // Not allowed to drop an event on a group header or a readOnly resource\n        if (newResource.isSpecialRow || newResource.readOnly) {\n            return false;\n        }\n\n        // Not allowed to assign an event twice to the same resource\n        if (resourceRecord !== newResource) {\n            return !sourceRecord.event.resources.includes(newResource);\n        }\n\n        return true;\n    }\n\n    checkDragValidity(dragData, event) {\n        const\n            me        = this,\n            scheduler = me.currentOverClient;\n\n        let result;\n\n        // Cannot assign anything to readOnly resources\n        if (dragData.newResource?.readOnly) {\n            return false;\n        }\n\n        // First make sure there's no overlap, if not run the external validatorFn\n        if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(\n            dragData.startDate,\n            dragData.endDate,\n            dragData.draggedEntities[0],\n            dragData.newResource\n        )) {\n            result = {\n                valid   : false,\n                message : me.L('L{eventOverlapsExisting}')\n            };\n        }\n        else {\n            result = me.validatorFn.call(\n                me.validatorFnThisObj || me,\n                dragData,\n                event\n            );\n        }\n\n        if (!result || result.valid) {\n            // Hook for features to have a say on validity\n            result = scheduler['checkEventDragValidity']?.(dragData, event) ?? result;\n        }\n\n        return result;\n    }\n\n    //endregion\n\n    //region Update records\n\n    /**\n     * Update events being dragged.\n     * @private\n     * @param context Drag data.\n     */\n    async updateRecords(context) {\n        const\n            me             = this,\n            fromScheduler  = me.client,\n            toScheduler    = me.currentOverClient,\n            copyKeyPressed = me.mode === 'copy';\n\n        let result;\n\n        if (!context.externalDropTarget) {\n            fromScheduler.eventStore.suspendAutoCommit();\n            toScheduler.eventStore.suspendAutoCommit();\n\n            result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);\n\n            fromScheduler.eventStore.resumeAutoCommit();\n            toScheduler.eventStore.resumeAutoCommit();\n        }\n\n        // Tell the world there was a successful drop\n        toScheduler.trigger('eventDrop', Object.assign(me.getTriggerParams(context), {\n            isCopy               : copyKeyPressed,\n            copyMode             : me.copyMode,\n            domEvent             : context.browserEvent,\n            targetEventRecord    : context.targetEventRecord,\n            targetResourceRecord : context.newResource,\n            externalDropTarget   : context.externalDropTarget\n        }));\n\n        return result;\n    }\n\n    /**\n     * Update assignments being dragged\n     * @private\n     */\n    async updateAssignments(fromScheduler, toScheduler, context, copy) {\n        // The code is written to emit as few store events as possible\n        const\n            me                  = this,\n            { copyMode }        = me,\n            isCrossScheduler    = (fromScheduler !== toScheduler),\n            { isVertical }      = toScheduler,\n            {\n                assignmentStore: fromAssignmentStore,\n                eventStore     : fromEventStore\n            }                   = fromScheduler,\n            {\n                assignmentStore: toAssignmentStore,\n                eventStore     : toEventStore\n            }                   = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore   = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore     = isVertical ? toScheduler.resourceStore : toScheduler.store,\n            {\n                eventRecords,\n                assignmentRecords,\n                timeDiff,\n                initialAssignmentsState,\n                resourceRecord : fromResource,\n                newResource    : toResource\n            }                   = context,\n            { unifiedDrag }     = me,\n            // For an empty target event store, check if it has usesSingleAssignment explicitly set, otherwise use\n            // the value from the source event store\n            useSingleAssignment = (toEventStore.usesSingleAssignment ||\n                (toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment)),\n            event1Date          = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff),\n            eventsToAdd         = [],\n            eventsToRemove      = [],\n            assignmentsToAdd    = [],\n            assignmentsToRemove = [],\n            eventsToCheck       = [],\n            eventsToBatch       = new Set(),\n            resourcesInStore    = fromResourceStore.getAllDataRecords();\n\n        fromScheduler.suspendRefresh();\n        toScheduler.suspendRefresh();\n\n        let updated      = false,\n            updatedEvent = false,\n            indexDiff; // By how many resource rows has the drag moved.\n\n        if (isCrossScheduler) {\n            // The difference in indices via first dragged event will help us find resources for all the rest of the\n            // events accordingly\n            indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource);\n        }\n        else if (me.constainDragToResource) {\n            indexDiff = 0;\n        }\n        else if (isVertical && toResourceStore.isGrouped) {\n            indexDiff = resourcesInStore.indexOf(fromResource) - resourcesInStore.indexOf(toResource);\n        }\n        else {\n            indexDiff = fromResourceStore.indexOf(fromResource) - fromResourceStore.indexOf(toResource);\n        }\n\n        if (isVertical) {\n            // TODO : Broken after merge, figure it out\n            eventRecords.forEach((draggedEvent, i) => {\n                const eventBar = context.eventBarEls[i];\n\n                delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;\n\n                // If it was created by a call to scheduler.currentOrientation.addTemporaryDragElement\n                // then release it back to be available to DomSync next time the rendered event block\n                // is synced.\n                if (eventBar.dataset.transient) {\n                    eventBar.remove();\n                }\n            });\n        }\n\n        const\n            eventBarEls = context.eventBarEls.slice(),\n            addedEvents = [],\n            // this map holds references between original assignment and its copy\n            copiedAssignmentsMap = {};\n\n        // Using for to support await inside\n        for (let i = 0; i < assignmentRecords.length; i++) {\n            const originalAssignment = assignmentRecords[i];\n\n            // Reassigned when dropped on other scheduler, thus not const\n            let draggedEvent = originalAssignment.event,\n                draggedAssignment;\n\n            if (copy) {\n                draggedAssignment = originalAssignment.copy();\n                copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;\n            }\n            else {\n                draggedAssignment = originalAssignment;\n            }\n\n            if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {\n                // Event was removed externally during the drag, just remove element from DOM (DomSync already has\n                // tried to clean it up at this point, but could not due to retainElement being set)\n                eventBarEls[i].remove();\n                eventBarEls.splice(i, 1);\n                assignmentRecords.splice(i, 1);\n                i--;\n                continue;\n            }\n\n            const\n                initialState           = initialAssignmentsState[i],\n                originalEventRecord    = draggedEvent,\n                originalStartDate      = initialState.startDate,\n                // grabbing resource early, since after \".copy()\" the record won't belong to any store\n                // and \".getResources()\" won't work. If it's a move to another scheduler, ensure the\n                // array still has a length. The process function will do an assign as opposed\n                // to a reassign\n                originalResourceRecord = initialState.resource,\n                // Calculate new startDate (and round it) based on timeDiff up here, might be added to another\n                // event store below in which case it is invalidated. But this is anyway the target date\n                newStartDate           = this.constrainDragToTimeSlot\n                    ? originalStartDate\n                    : (unifiedDrag\n                        ? event1Date\n                        : me.adjustStartDate(originalStartDate, timeDiff));\n\n            if (fromAssignmentStore !== toAssignmentStore) {\n                // Single assignment from a multi assigned event dragged over, event needs to be copied over\n                // Same if we hold the copy key\n                const keepEvent = originalEventRecord.assignments.length > 1 || copy;\n\n                let newAssignment;\n\n                if (copy) {\n                    // In a copy mode dragged assignment is already a copy\n                    newAssignment = draggedAssignment;\n                }\n                else {\n                    newAssignment = draggedAssignment.copy();\n                    copiedAssignmentsMap[draggedAssignment.id] = newAssignment;\n                }\n\n                // Pro Engine does not seem to handle having the event already in place on the copied assignment,\n                // replacing it with id to have events bucket properly set up on commit\n                if (newAssignment.event && !useSingleAssignment) {\n                    newAssignment.event = newAssignment.event.id;\n                    newAssignment.resource = newAssignment.resource.id;\n                }\n\n                if (!copy) {\n                    // If we're not copying, remove assignment from source scheduler\n                    assignmentsToRemove.push(draggedAssignment);\n                }\n\n                // If it was the last assignment, the event should also be removed\n                if (!keepEvent) {\n                    eventsToRemove.push(originalEventRecord);\n                }\n\n                // If event does not already exist in target scheduler a copy is added\n                // if we're copying the event, we always need to create new record\n                if (\n                    copy && (copyMode === 'event' || (copyMode === 'auto' && toEventStore.usesSingleAssignment)) ||\n                    !toEventStore.getById(originalEventRecord.id)\n                ) {\n                    draggedEvent = toEventStore.createRecord({\n                        ...originalEventRecord.data,\n                        // If we're copying the event (not making new assignment to existing), we need to generate\n                        // phantom id to link event to the assignment record\n                        id       : copy && (copyMode === 'event' || copyMode === 'auto') ? undefined : originalEventRecord.id,\n                        // Engine gets mad if not nulled\n                        calendar : null\n                    });\n\n                    newAssignment.set({\n                        eventId : draggedEvent.id,\n                        event   : draggedEvent\n                    });\n\n                    eventsToAdd.push(draggedEvent);\n                }\n\n                // And add it to the target scheduler\n                // TODO: Should be handled on the data layer ideally\n                if (!useSingleAssignment) {\n                    assignmentsToAdd.push(newAssignment);\n                }\n                draggedAssignment = newAssignment;\n            }\n\n            let newResource = toResource,\n                reassignedFrom = null;\n\n            if (!unifiedDrag) {\n                if (!isCrossScheduler) {\n                    // If not dragging events as a unified block, distribute each to a new resource\n                    // using the same offset as the dragged event.\n                    if (indexDiff !== 0) {\n                        let newIndex;\n                        if (isVertical && toResourceStore.isGrouped) {\n                            newIndex = Math.max(\n                                Math.min(\n                                    resourcesInStore.indexOf(originalResourceRecord) - indexDiff,\n                                    resourcesInStore.length - 1\n                                ),\n                                0\n                            );\n                            newResource = resourcesInStore[newIndex];\n                        }\n                        else {\n                            newIndex = Math.max(\n                                Math.min(\n                                    fromResourceStore.indexOf(originalResourceRecord) - indexDiff,\n                                    fromResourceStore.count - 1\n                                ),\n                                0\n                            );\n\n                            newResource = fromResourceStore.getAt(newIndex);\n\n                            // Exclude group headers, footers, summary row etc\n                            if (newResource.isSpecialRow) {\n                                newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);\n                            }\n                        }\n\n                        newResource = newResource?.$original;\n                    }\n                    else {\n                        newResource = originalResourceRecord;\n                    }\n                }\n                // we have a resource for first dragged event in toResource\n                else if (i > 0) {\n                    const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);\n                    newResource                     = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;\n                }\n            }\n\n            // Cannot rely on assignment generation to detect update, since it might be a new assignment\n            // TODO: what about a case when we drag between schedulers which have different resource with same ids?\n            if (draggedAssignment.resourceId !== newResource.id) {\n                reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);\n\n                if (copy) {\n                    if (fromAssignmentStore === toAssignmentStore) {\n                        draggedAssignment.resource = newResource;\n                        draggedAssignment.event = toEventStore.getById(draggedAssignment.eventId);\n\n                        if (copyMode === 'event' || (fromEventStore.usesSingleAssignment && copyMode === 'auto')) {\n                            draggedEvent = draggedEvent.copy();\n\n                            draggedAssignment.event = draggedEvent;\n\n                            if (toEventStore.usesSingleAssignment) {\n                                draggedEvent.resource = newResource;\n                                draggedEvent.resourceId = newResource.id;\n                            }\n                        }\n\n                        if (\n                            !toAssignmentStore.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId) &&\n                            !assignmentsToAdd.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)\n                        ) {\n                            eventsToAdd.push(draggedEvent);\n                            assignmentsToAdd.push(draggedAssignment);\n                        }\n                    }\n                    else {\n                        draggedAssignment.resource = newResource;\n                    }\n                }\n                else {\n                    draggedAssignment.resource = newResource;\n                }\n\n                // Actual events should be batched, not data for new events when dragging between\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updated = true;\n\n                // When dragging an occurrence, the assignment is only temporary. We have to tag the newResource along\n                // to be picked up by the occurrence -> event conversion\n                // TODO: A hack, figure a better way out\n                if (draggedEvent.isOccurrence) {\n                    draggedEvent.set('newResource', newResource);\n                }\n\n                // TODO: Should be handled on the datalayer somehow, but it is kind of edge casey\n                if (isCrossScheduler && useSingleAssignment) {\n                    // In single assignment mode, when dragged to another scheduler it will not copy the assignment\n                    // over but instead set the resourceId of the event. To better match expected behaviour\n                    draggedEvent.resourceId = newResource.id;\n                }\n            }\n            else {\n                if (\n                    copy &&\n                    (copyMode === 'event' || (copyMode === 'auto' && fromEventStore.usesSingleAssignment)) &&\n                    !eventsToAdd.includes(draggedEvent)\n                ) {\n                    draggedEvent = draggedEvent.copy();\n                    eventsToAdd.push(draggedEvent);\n\n                    draggedAssignment.event = draggedEvent;\n\n                    if (toEventStore.usesSingleAssignment) {\n                        draggedEvent.set({\n                            resource   : newResource,\n                            resourceId : newResource.id\n                        });\n                    }\n\n                    // Always add assignment to the store to allow proper element reuse\n                    assignmentsToAdd.push(draggedAssignment);\n                }\n            }\n\n            // Same for event\n            if (!eventsToCheck.find(ev => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {\n\n                // only do for non occurence records\n                while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {\n                    draggedEvent.endBatch(true);\n                }\n\n                draggedEvent.startDate = newStartDate;\n\n                eventsToCheck.push({ draggedEvent, originalStartDate });\n\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updatedEvent = true;\n            }\n\n            // Hook for features that need to do additional processing on drop (used by NestedEvents)\n            toScheduler.processEventDrop({\n                eventRecord    : draggedEvent,\n                resourceRecord : newResource,\n                element        : i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                context,\n                toScheduler,\n                reassignedFrom,\n                eventsToAdd,\n                addedEvents,\n                draggedAssignment\n            });\n\n            // There are two cases to consider when triggering this event - `copy` and `move` mode. In case we are\n            // copying the assignment (we can also copy the event) draggedAssignment will point to the copy of the\n            // original assignment record. Same for draggedEvent. These records are new records which are not yet added\n            // to the store and they contain correct state of the drop - which event is going to be assigned to which\n            // resource on what time.\n            // These records possess no knowledge about original records which they were cloned from. And that might be\n            // useful. Let's say you want to copy assignment (or event) to every row in the way. You need to know start\n            // row and the end row. That information is kept in the `originalAssignment` record. Which might be identical\n            // to the `draggedAssignment` record in `move` mode.\n            toScheduler.trigger('processEventDrop', {\n                originalAssignment,\n                draggedAssignment,\n                context,\n                copyMode,\n                isCopy : copy\n            });\n        }\n\n        fromAssignmentStore.remove(assignmentsToRemove);\n        fromEventStore.remove(eventsToRemove);\n        toAssignmentStore.add(assignmentsToAdd);\n\n        // Modify syncIdMap on the FGCanvas to make sure elements get animated nicely to new position\n        if (copy && fromAssignmentStore === toAssignmentStore) {\n            const { syncIdMap } = fromScheduler.foregroundCanvas;\n\n            Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {\n                const element = syncIdMap[originalId];\n                delete syncIdMap[originalId];\n                syncIdMap[cloneRecord.id] = element;\n            });\n        }\n\n        eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));\n\n        // When not constrained to timeline we are dragging a clone and need to manually do some cleanup if\n        // dropped in view\n        if (!me.constrainDragToTimeline) {\n            // go through assignmentRecords again after events has been added to toEventStore (if any)\n            // now we have updated assignment ids and can properly reuse event HTML elements\n            for (let i = 0; i < assignmentRecords.length; i++) {\n                const\n                    assignmentRecord     = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i],\n                    originalDraggedEvent = assignmentRecord.event,\n                    // try to get dragged event from addedEvents array, it will be there with updated ids\n                    // if toScheduler is different\n                    draggedEvent         = addedEvents?.find(r => r.id === originalDraggedEvent.id) || originalDraggedEvent,\n                    eventBar             = context.eventBarEls[i],\n                    element              = i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                    // Determine if in time axis here also, since the records date might be invalidated further below\n                    inTimeAxis           = toScheduler.isInTimeAxis(draggedEvent);\n\n                if (!copy) {\n                    // Remove original element properly\n                    DomSync.removeChild(eventBar.parentElement, eventBar);\n                }\n\n                if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {\n                    // Nested events are added to correct parent by the feature\n                    if (!draggedEvent.parent || draggedEvent.parent.isRoot) {\n                        const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);\n\n                        // Ensure that after inserting the dragged element clone into the toScheduler's foregroundCanvas\n                        // it's at the same visual position that it was dragged to.\n                        DomHelper.setTopLeft(element, elRect.y, elRect.x);\n\n                        // Add element properly, so that DomSync will reuse it on next update\n                        DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);\n\n                        isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({\n                            eventRecord : draggedEvent,\n                            toScheduler\n                        });\n                    }\n\n                    element.classList.remove('b-sch-event-hover', 'b-active', 'b-drag-proxy', 'b-dragging');\n                    element.retainElement = false;\n                }\n            }\n        }\n\n        addedEvents?.forEach(added => eventsToBatch.add(added));\n\n        // addedEvents order is the same with [context.element, ..context.relatedElements]\n        // Any added or removed events or assignments => something changed\n        if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {\n            updated = true;\n        }\n\n        // Commit changes to affected projects\n        if (updated || updatedEvent) {\n            // By batching event changes when using single assignment we avoid two updates, without it there will be one\n            // for date change and one when changed assignment updates resourceId on the event\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.beginBatch());\n\n            await Promise.all([\n                toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null,\n                fromScheduler.project.commitAsync()\n            ]);\n\n            // End batch in engine friendly way, avoiding to have `set()` trigger another round of calculations\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.endBatch(false, true));\n        }\n\n        if (!updated) {\n            // Engine might have reverted the date change, in which case this should be considered an invalid op\n            updated = eventsToCheck.some(({ draggedEvent, originalStartDate }) =>\n                !DateHelper.isEqual(draggedEvent.startDate, originalStartDate)\n            );\n        }\n\n        // Resumes self twice if not cross scheduler, but was suspended twice above also so all good\n        toScheduler.resumeRefresh();\n        fromScheduler.resumeRefresh();\n\n        if (assignmentRecords.length > 0) {\n            if (!updated) {\n                context.valid = false;\n            }\n            else {\n                // https://github.com/bryntum/support/issues/630\n                // Force re-render when using fillTicks. If date changed within same tick the element wont actually\n                // change and since we hijacked it for drag it wont be returned to its original position\n                if (toScheduler.fillTicks) {\n                    eventBarEls.forEach(el => delete el.lastDomConfig);\n                }\n\n                // Not doing full refresh above, to allow for animations\n                toScheduler.refreshWithTransition();\n\n                if (isCrossScheduler) {\n                    fromScheduler.refreshWithTransition();\n\n                    toScheduler.selectedEvents = addedEvents;\n                }\n            }\n        }\n    }\n\n    //endregion\n\n    //region Drag data\n\n    getProductDragContext(dragData) {\n        const\n            me                                = this,\n            { currentOverClient : scheduler } = me,\n            target                            = dragData.browserEvent.target,\n            previousResolvedResource          = dragData.newResource || dragData.resourceRecord,\n            previousTargetEventRecord         = dragData.targetEventRecord;\n\n        let\n            targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null,\n            newResource, externalDropTarget;\n\n        // Ignore if over dragged event\n        if (dragData.eventRecords.includes(targetEventRecord)) {\n            targetEventRecord = null;\n        }\n\n        if (me.constrainDragToResource) {\n            newResource = dragData.resourceRecord;\n        }\n        else if (!me.constrainDragToTimeline) {\n            newResource = me.resolveResource();\n        }\n        else if (scheduler) {\n            newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;\n        }\n\n        const\n            { assignmentRecords, eventRecords } = dragData,\n            isOverNewResource                   = previousResolvedResource !== newResource;\n\n        let valid = Boolean(newResource && !newResource.isSpecialRow);\n\n        if (!newResource && me.externalDropTargetSelector) {\n            externalDropTarget = target.closest(me.externalDropTargetSelector);\n            valid              = Boolean(externalDropTarget);\n        }\n\n        return {\n            valid,\n            externalDropTarget,\n            eventRecords,\n            assignmentRecords,\n            newResource,\n            targetEventRecord,\n            dirty         : isOverNewResource || targetEventRecord !== previousTargetEventRecord,\n            proxyElements : [dragData.context.element, ...dragData.context.relatedElements || []]\n        };\n    }\n\n    getMinimalDragData(info) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            element           = me.getElementFromContext(info),\n            eventRecord       = me.resolveEventRecord(element, scheduler),\n            resourceRecord    = scheduler.resolveResourceRecord(element),\n            assignmentRecord  = scheduler.resolveAssignmentRecord(element),\n            assignmentRecords = assignmentRecord ? [assignmentRecord] : [];\n\n        // We multi drag other selected events if the dragged event is already selected, or the ctrl key is pressed\n        if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || me.drag.startEvent.ctrlKey)) {\n            assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));\n        }\n\n        const eventRecords = [...new Set(assignmentRecords.map(assignment => assignment.event))];\n\n        return {\n            eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            eventRecords,\n            assignmentRecords\n        };\n    }\n\n    setupProductDragData(info) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = me.getElementFromContext(info),\n            {\n                eventRecord,\n                resourceRecord,\n                assignmentRecord,\n                assignmentRecords\n            }             = me.getMinimalDragData(info),\n            eventBarEls   = [];\n\n        if (me.constrainDragToResource && !resourceRecord) {\n            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);\n        }\n\n        let dateConstraints;\n\n        if (me.constrainDragToTimeline) {\n            dateConstraints = me.getDateConstraints?.(resourceRecord, eventRecord);\n\n            const\n                constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord),\n                eventRegion        = Rectangle.from(element, scheduler.timeAxisSubGridElement);\n\n            super.setupConstraints(\n                constrainRectangle,\n                eventRegion,\n                scheduler.timeAxisViewModel.snapPixelAmount,\n                Boolean(dateConstraints.start)\n            );\n        }\n\n        // Collecting all elements to drag\n        assignmentRecords.forEach(assignment => {\n            let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);\n\n            if (!eventBarEl) {\n                eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);\n            }\n\n            eventBarEls.push(eventBarEl);\n        });\n\n        return {\n            record          : assignmentRecord,\n            draggedEntities : assignmentRecords,\n            dateConstraints : dateConstraints?.start ? dateConstraints : null,\n            // Create copies of the elements\n            eventBarCopies  : eventBarEls.map(el => me.createProxy(el)),\n            eventBarEls\n        };\n    }\n\n    getDateConstraints(resourceRecord, eventRecord) {\n        const\n            { scheduler }           = this,\n            externalDateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        let minDate, maxDate;\n\n        if (this.constrainDragToTimeSlot) {\n            minDate = eventRecord.startDate;\n            maxDate = eventRecord.endDate;\n        }\n        else if (externalDateConstraints) {\n            minDate = externalDateConstraints.start;\n            maxDate = externalDateConstraints.end;\n        }\n\n        return {\n            start : minDate,\n            end   : maxDate\n        };\n    }\n\n    getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {\n        return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {\n            start : dateRange.start, end : dateRange.end\n        });\n    }\n\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const dragData = this.getMinimalDragData(info) || {};\n\n        return {\n            ...super.getDragData(info),\n            ...dragData,\n            initialAssignmentsState : dragData.assignmentRecords.map(assignment => ({\n                startDate : assignment.event.startDate,\n                resource  : assignment.resource,\n                assignment\n            }))\n        };\n    }\n\n    /**\n     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dragged\n     * @returns {Scheduler.model.AssignmentModel[]} An array of assignment records to drag together with the original\n     */\n    getRelatedRecords(assignmentRecord) {\n        return this.scheduler.selectedAssignments.filter(selectedRecord => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);\n    }\n\n    /**\n     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone\n     * layout into account.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Record being dragged\n     * @param {HTMLElement} element Element being dragged\n     * @param {Number[]} coord XY coordinates\n     * @returns {Number|Number[]} X,Y or XY\n     */\n    getCoordinate(eventRecord, element, coord) {\n        const scheduler = this.currentOverClient;\n\n        if (scheduler.isHorizontal) {\n            let x = coord[0];\n\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        x += element.offsetWidth / 2;\n                        break;\n                    case 'end':\n                        x += element.offsetWidth;\n                        break;\n                }\n            }\n\n            return x;\n        }\n        else {\n            let y = coord[1];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        y += element.offsetHeight / 2;\n                        break;\n                    case 'end':\n                        y += element.offsetHeight;\n                        break;\n                }\n            }\n\n            return y;\n        }\n    }\n\n    /**\n     * Get resource record occluded by the drag proxy.\n     * @private\n     * @returns {Scheduler.model.ResourceModel}\n     */\n    resolveResource() {\n        const\n            me               = this,\n            client           = me.currentOverClient,\n            { isHorizontal } = client,\n            {\n                context,\n                browserEvent,\n                dragProxy\n            }                = me.dragData,\n            element          = dragProxy || context.element,\n            // Page coords for elementFromPoint\n            pageRect         = Rectangle.from(element, null, true),\n            y                = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,\n            // Local coords to resolve resource in vertical\n            localRect        = Rectangle.from(element, client.timeAxisSubGridElement, true),\n            { x: lx, y: ly } = localRect.center,\n            eventTarget      = me.getMouseMoveEventTarget(browserEvent);\n\n        let resource = null;\n\n        if (client.element.contains(eventTarget)) {\n            // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate\n            // so use it in preference to elementFromPoint (which causes a forced synchronous layout) in horizontal mode.\n            if (isHorizontal) {\n                const row = client.rowManager.getRowAt(y);\n\n                resource = row && client.store.getAt(row.dataIndex);\n            }\n            else {\n                // In vertical mode, just use the X coordinate to find out which resource we are under.\n                // The method requires that a .b-sch-timeaxis-cell element be passed.\n                // There is only one in vertical mode, so use that.\n                resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);\n            }\n        }\n\n        return resource;\n    }\n\n    //endregion\n\n    //region Other stuff\n\n    adjustStartDate(startDate, timeDiff) {\n        const scheduler = this.currentOverClient;\n\n        return scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);\n    }\n\n    getRecordElement(assignmentRecord) {\n        return this.client.getElementFromAssignmentRecord(assignmentRecord, true);\n    }\n\n    // Used by the Dependencies feature to draw lines to the drag proxy instead of the original event element\n    getProxyElement(assignmentRecord) {\n        if (this.isDragging) {\n            const index = this.dragData.assignmentRecords.indexOf(assignmentRecord);\n\n            if (index >= 0) {\n                return this.dragData.proxyElements[index];\n            }\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //#region Salesforce hooks\n\n    getMouseMoveEventTarget(event) {\n        return event.target;\n    }\n\n    //#endregion\n}\n\nGridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDrag, false, 'ResourceHistogram');\n","import DragCreateBase from './base/DragCreateBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/feature/EventDragCreate\n */\n\n/**\n * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.\n *\n * {@inlineexample Scheduler/feature/EventDragCreate.js}\n *\n * This feature is **enabled** by default.\n *\n * <div class=\"note\">Incompatible with the {@link Scheduler.feature.EventDragSelect EventDragSelect} and\n * {@link Scheduler.feature.Pan Pan} features. If either of those features are enabled, this feature has no effect.\n * </div>\n *\n * ## Conditionally preventing drag creation\n *\n * To conditionally prevent drag creation for a certain resource or a certain timespan, you listen for the\n * {@link #event-beforeDragCreate} event, add your custom logic to it and return `false` to prevent the operation\n * from starting. For example to not allow drag creation on the topmost resource:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     listeners : {\n *         beforeDragCreate({ resource }) {\n *             // Prevent drag creating on the topmost resource\n *             if (resource === scheduler.resourceStore.first) {\n *                 return false;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/base/DragCreateBase\n * @demo Scheduler/basic\n * @classtype eventDragCreate\n * @feature\n */\nexport default class EventDragCreate extends DragCreateBase {\n    //region Config\n\n    static $name = 'EventDragCreate';\n\n    static configurable = {\n        /**\n         * An empty function by default, but provided so that you can perform custom validation on the event being\n         * created. Return `true` if the new event is valid, `false` to prevent an event being created.\n         * @param {Object} context A drag create context\n         * @param {Date} context.startDate Event start date\n         * @param {Date} context.endDate Event end date\n         * @param {Scheduler.model.EventModel} context.record Event record\n         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n         * @param {Event} event The event object\n         * @returns {Boolean} `true` if this validation passes\n         * @config {Function}\n         */\n        validatorFn : () => true,\n\n        /**\n         * Locks the layout during drag create, overriding the default behaviour that uses the same rendering\n         * pathway for drag creation as for already existing events.\n         *\n         * This more closely resembles the behaviour of versions prior to 4.2.0.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        lockLayout : false\n    };\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fires on the owning Scheduler after the new event has been created.\n     * @event dragCreateEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource for the row in which the event is being\n     * created.\n     * @param {MouseEvent} event The ending mouseup event.\n     * @param {HTMLElement} eventElement The DOM element representing the newly created event un the UI.\n     */\n\n    /**\n     * Fires on the owning Scheduler at the beginning of the drag gesture. Returning `false` from a listener prevents\n     * the drag create operation from starting.\n     *\n     * ```javascript\n     * const scheduler = new Scheduler({\n     *     listeners : {\n     *         beforeDragCreate({ date }) {\n     *             // Prevent drag creating events in the past\n     *             return date >= Date.now();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeDragCreate\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date The datetime associated with the drag start point.\n     */\n\n    /**\n     * Fires on the owning Scheduler after the drag start has created a new Event record.\n     * @event dragCreateStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new event.\n     */\n\n    /**\n     * Fires on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforedragcreatefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeDragCreateFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new Event record\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user\n     * confirmation)\n     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one\n     * argument: pass true to update records, or false, to ignore changes\n     */\n\n    /**\n     * Fires on the owning Scheduler at the end of the drag create gesture whether or not\n     * a new event was created by the gesture.\n     * @event afterDragCreate\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the created event record\n     */\n\n    //endregion\n\n    //region Init\n\n    get scheduler() {\n        return this.client;\n    }\n\n    get store() {\n        return this.client.eventStore;\n    }\n\n    updateLockLayout(lock) {\n        this.dragActiveCls = `b-dragcreating${lock ? ' b-dragcreate-lock' : ''}`;\n    }\n\n    //endregion\n\n    //region Scheduler specific implementation\n\n    handleBeforeDragCreate(drag, eventRecord, event) {\n        const { resourceRecord } = drag;\n\n        if (resourceRecord.readOnly) {\n            return false;\n        }\n\n        const { scheduler }      = this,\n            // For resources with a calendar, ensure the date is inside a working time range\n            isWorkingTime      = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate),\n            result             = isWorkingTime && scheduler.trigger('beforeDragCreate', {\n                resourceRecord,\n                date : drag.mousedownDate,\n                event\n            });\n\n        // Save date constraints\n        this.dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n\n        return result;\n    }\n\n    dragStart(drag) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                eventStore,\n                assignmentStore,\n                enableEventAnimations\n            }                  = client,\n            { resourceRecord } = drag,\n            eventRecord        = me.createEventRecord(drag),\n            resourceRecords    = [resourceRecord];\n\n        eventRecord.set('duration', DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));\n\n        // It's only a provisional event until gesture is completed (possibly longer if an editor dialog is shown after)\n        eventRecord.isCreating = true;\n\n        // Flag used by rendering to not draw a zero length event being drag created as a milestone\n        eventRecord.meta.isDragCreating = true;\n\n        // force the transaction canceling in the taskeditor early\n        // this is because we are going to add a new event record to the store, and it has to be out of the\n        // task editor's stm transaction\n        // now there's a re-entrant protection in that method, so hopefully when it will be called by the\n        // editor itself that's ok\n        // `taskEdit === false` in some cases, so can't just use `?.` here\n        client.features.taskEdit && client.features.taskEdit.doCancel();\n\n        // This presents the event to be scheduled for validation at the proposed mouse/date point\n        // If rejected, we cancel operation\n        if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {\n            return false;\n        }\n\n        let assignmentRecords = [];\n\n        if (resourceRecord) {\n            assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n        }\n\n        // Vetoable beforeEventAdd allows cancel of this operation\n        if (client.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            assignmentStore.remove(assignmentRecords);\n            return false;\n        }\n\n        // When configured to lock layout during drag create, set a flag that HorizontalRendering will pick up to\n        // exclude the new event from the layout calculations. It will then be at the topmost position in the \"cell\"\n        if (me.lockLayout) {\n            eventRecord.meta.excludeFromLayout = true;\n        }\n\n        client.onEventCreated?.(eventRecord);\n\n        client.enableEventAnimations = false;\n        eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);\n\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        client.isCreating = true;\n        client.refreshRows();\n        client.isCreating = false;\n\n        // Set the element we are dragging\n        drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);\n\n        // If the resource row is very tall, the event may have been rendered outside of the\n        // visible viewport. If so, scroll it into view.\n        if (!DomHelper.isInView(drag.itemElement)) {\n            client.scrollable.scrollIntoView(drag.itemElement, {\n                animate    : true,\n                edgeOffset : client.barMargin\n            });\n        };\n\n        return super.dragStart(drag);\n    }\n\n    checkValidity(context, event) {\n        const\n            me         = this,\n            { client } = me;\n\n        // Nicer for users of validatorFn\n        context.resourceRecord = me.dragging.resourceRecord;\n        return (\n            client.allowOverlap ||\n            client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);\n    }\n\n    // Determine if resource already has events or not\n    isRowEmpty(resourceRecord) {\n        const events = this.store.getEventsForResource(resourceRecord);\n        return !events || !events.length;\n    }\n\n    //endregion\n\n    triggerBeforeFinalize(event) {\n        this.client.trigger(`beforeDragCreateFinalize`, event);\n    }\n\n    /**\n     * Creates an event by the event object coordinates\n     * @param {Object} drag The Bryntum event object\n     * @private\n     */\n    createEventRecord(drag) {\n        const\n            me          = this,\n            { client }  = me,\n            dimension   = client.isHorizontal ? 'X' : 'Y',\n            {\n                timeAxis,\n                eventStore,\n                weekStartDay\n            }           = client,\n            {\n                event,\n                mousedownDate\n            }           = drag,\n            draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`],\n            eventConfig = {\n                name      : eventStore.modelClass.fieldMap.name.defaultValue || me.L('L{Object.newEvent}'),\n                startDate : draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,\n                endDate   : draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)\n            };\n\n        // if project model has been imported from Gantt, we have to define constraint data directly to correct\n        // auto-scheduling while dragCreate\n        if (client.project.isGanttProjectMixin) {\n            ObjectHelper.assign(eventConfig, {\n                constraintDate : eventConfig.startDate,\n                constraintType : 'startnoearlierthan'\n            });\n        }\n\n        return eventStore.createRecord(eventConfig);\n    }\n\n    async finalizeDragCreate(context) {\n        const { meta } = context.eventRecord;\n\n        // Remove the layout lock flag, event will jump into place as part of the finalization\n        meta.excludeFromLayout = false;\n        // Also allow new event to become a milestone now\n        meta.isDragCreating    = false;\n\n        if (!this.client.hasEventEditor) {\n            context.eventRecord.isCreating = false;\n        }\n\n        return super.finalizeDragCreate(context);\n    }\n\n    getTipHtml(...args) {\n        const\n            html        = super.getTipHtml(...args),\n            { element } = this.tip;\n\n        element.classList.add('b-sch-dragcreate-tooltip');\n        element.classList.toggle('b-too-narrow', this.dragging.context.tooNarrow);\n\n        return html;\n    }\n\n    onAborted(context) {\n        const { eventRecord, resourceRecord } = context;\n\n        // The product this is being used in may not have resources.\n        this.store.unassignEventFromResource?.(eventRecord, resourceRecord);\n        this.store.remove(eventRecord);\n    }\n}\n\nGridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDragCreate, false, 'ResourceHistogram');\n","import TooltipBase from './base/TooltipBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n\n/**\n * @module Scheduler/feature/EventTooltip\n */\n\n/**\n * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.\n * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.\n *\n * ## Showing local data\n * To show a basic \"local\" tooltip (with data available in the Event record) upon hover:\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *         // Tooltip configs can be used here\n *         align : 'l-r' // Align left to right,\n *         // A custom HTML template\n *         template : data => `<dl>\n *           <dt>Assigned to:</dt>\n *              <dt>Time:</dt>\n *              <dd>\n *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}\n *              </dd>\n *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}\n *\n *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class=\"image\" src=\"${data.eventRecord.get('image')}\"/></dd>` : ''}\n *          </dl>`\n *     }\n *   }\n * });\n * ```\n *\n * ## Showing remotely loaded data\n * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())\n *     }\n *   }\n * });\n * ```\n * This feature is **enabled** by default\n *\n * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}\n * meaning that it will stay aligned with its target should a scroll interaction make the target move.\n *\n * If this is causing performance issues in a Scheduler, such as if there are many dozens of events\n * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is\n * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a\n * scroll interaction.\n *\n * @extends Scheduler/feature/base/TooltipBase\n * @demo Scheduler/basic\n * @inlineexample Scheduler/feature/EventTooltip.js\n * @classtype eventTooltip\n * @feature\n */\nexport default class EventTooltip extends TooltipBase {\n    //region Config\n\n    static get $name() {\n        return 'EventTooltip';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * A function which receives data about the event and returns a string,\n             * or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.\n             * This method will be called with an object containing the fields below\n             * @param {Object} data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Date} data.startDate\n             * @param {Date} data.endDate\n             * @param {String} data.startText\n             * @param {String} data.endText\n             * @config {Function} template\n             */\n            template : data => `\n                ${data.eventRecord.name ? StringHelper.xss`<div class=\"b-sch-event-title\">${data.eventRecord.name}</div>` : ''}\n                ${data.startClockHtml}\n                ${data.endClockHtml}`,\n\n            cls : 'b-sch-event-tooltip',\n\n            monitorRecordUpdate : true,\n\n            /**\n             * Defines what to do if document is scrolled while the tooltip is visible.\n             *\n             * Valid values: ´null´: do nothing, ´hide´: hide the tooltip or ´realign´: realign to the target if possible.\n             *\n             * @config {'hide'|'realign'|null}\n             * @default\n             */\n            scrollAction : 'hide'\n        };\n    }\n\n    //endregion\n\n    construct(client, config) {\n        const me = this;\n\n        super.construct(client, config);\n\n        if (typeof me.align === 'string') {\n            me.align = { align : me.align };\n        }\n    }\n\n    onPaint({ firstPaint }) {\n        super.onPaint(...arguments);\n\n        if (firstPaint) {\n            const\n                me           = this,\n                dependencies = me.client.features.dependencies;\n\n            if (dependencies) {\n                const configuredOffset = me.align.offset;\n\n                me.tooltip.ion({\n                    beforeShow : ({ source : tooltip }) => {\n                        // Don't let dependency terminal interfere with this tooltip\n                        if (!dependencies.disabled) {\n                            tooltip.align.offset = [0, 10];\n                        }\n                        else {\n                            tooltip.align.offset = configuredOffset;\n                        }\n                    }\n                });\n            }\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventTooltip, false, 'ResourceHistogram');\n","import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n\n/**\n * @module Scheduler/feature/StickyEvents\n */\n\nconst zeroMargins = { width : 0, height : 0 };\n\n/**\n * This feature applies native `position: sticky` to event contents in horizontal mode, keeping the contents in view as\n * long as possible on scroll. For vertical mode it uses a programmatic solution to achieve the same result.\n *\n * Assign `eventRecord.stickyContents = false` to disable stickiness on a per event level (docs for\n * {@link Scheduler/model/EventModel#field-stickyContents}).\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyEvents\n * @feature\n */\nexport default class StickyEvents extends InstancePlugin {\n    static $name = 'StickyEvents';\n\n    static type = 'stickyEvents';\n\n    static pluginConfig = {\n        chain : ['onEventDataGenerated']\n    }\n\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n\n        if (scheduler.isVertical) {\n            this.toUpdate = new Set();\n\n            scheduler.ion({\n                scroll           : 'onSchedulerScroll',\n                horizontalScroll : 'onHorizontalScroll',\n                thisObj          : this,\n                prio             : 10000\n            });\n        }\n    }\n\n    onEventDataGenerated(renderData) {\n        if (this.client.isHorizontal) {\n            renderData.wrapperCls['b-disable-sticky'] = renderData.eventRecord.stickyContents === false;\n        }\n        else {\n            this.syncEventContentPosition(renderData, undefined, true);\n            this.updateStyles();\n        }\n    }\n\n    //region Vertical mode\n\n    onSchedulerScroll() {\n        if (!this.disabled) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    // Have to sync also on horizontal scroll, since we reuse elements and dom configs\n    onHorizontalScroll({ subGrid }) {\n        if (subGrid === this.client.timeAxisSubGrid) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n\n    updateStyles() {\n        for (const { contentEl, style } of this.toUpdate) {\n            DomHelper.applyStyle(contentEl, style);\n        }\n\n        this.toUpdate.clear();\n    }\n\n    verticalSyncAllEventsContentPosition(scheduler) {\n        const { resourceMap } = scheduler.currentOrientation;\n\n        for (const eventsData of resourceMap.values()) {\n            for (const { renderData, elementConfig } of Object.values(eventsData)) {\n                const args = [renderData];\n\n                if (elementConfig && renderData.eventRecord.isResourceTimeRange) {\n                    args.push(elementConfig.children[0]);\n                }\n\n                this.syncEventContentPosition.apply(this, args);\n            }\n        }\n        this.toUpdate.size && this.updateStyles();\n    }\n\n    syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {\n        if (\n            this.disabled ||\n            // Allow client disable stickiness for certain events\n            renderData.eventRecord.stickyContents === false\n        ) {\n            return;\n        }\n\n        const\n            { client }        = this,\n            {\n                eventRecord,\n                resourceRecord,\n                useEventBuffer,\n                bufferAfterWidth,\n                bufferBeforeWidth,\n                top,\n                height\n            }                 = renderData,\n            scrollPosition    = client.scrollable.y,\n            wrapperEl         = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true),\n            contentEl         = wrapperEl && DomSync.getChild(wrapperEl, 'event.content'),\n            meta              = eventRecord.instanceMeta(client),\n            style             = typeof eventContent.style === 'string'\n                ? (eventContent.style = DomHelper.parseStyle(eventContent.style))\n                : eventContent.style || (eventContent.style = {});\n\n        // Do not process events being dragged\n        if (wrapperEl?.classList.contains('b-dragging')) {\n            return;\n        }\n\n        let start       = top,\n            contentSize = height,\n            end         = start + contentSize;\n\n        if (useEventBuffer) {\n            start += bufferBeforeWidth;\n            contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;\n            end = start + contentSize;\n        }\n\n        // Only process non-milestones that are partially out of view\n        if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {\n            const\n                contentWidth = contentEl?.offsetWidth,\n                justify      = contentEl?.parentNode && DomHelper.getStyleValue(contentEl.parentNode, 'justifyContent'),\n                c            = justify === 'center' ? (renderData.width - contentWidth) / 2 : 0,\n                eventStart   = start,\n                eventEnd     = eventStart + contentSize - 1;\n\n            // Only process non-milestone events. Milestones have no width.\n            // If there's no offsetWidth, it's still b-released, so we cannot measure it.\n            // If the event starts off the left edge, but its right edge is still visible,\n            // translate the contentEl to compensate. If not, undo any translation.\n            if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {\n                const\n                    edgeSizes = this.getEventContentMargins(contentEl),\n                    maxOffset = contentEl\n                        ? (contentSize - contentEl.offsetHeight - edgeSizes.height) - c\n                        : Number.MAX_SAFE_INTEGER,\n                    offset = Math.min(scrollPosition - eventStart, maxOffset - 2);\n\n                style.transform = offset > 0 ? `translateY(${offset}px)` : '';\n                meta.stuck = true;\n            }\n            else {\n                style.transform = '';\n                meta.stuck = false;\n            }\n\n            if (contentEl) {\n                this.toUpdate.add({\n                    contentEl,\n                    style\n                });\n            }\n        }\n        else if (contentEl && meta.stuck) {\n            style.transform = '';\n            meta.stuck = false;\n\n            this.toUpdate.add({\n                contentEl,\n                style\n            });\n        }\n    }\n\n    // Only measure the margins of an event's contentEl once\n    getEventContentMargins(contentEl) {\n        if (contentEl?.classList.contains('b-sch-event-content')) {\n            return DomHelper.getEdgeSize(contentEl, 'margin');\n        }\n        return zeroMargins;\n    }\n\n    //endregion\n\n    doDisable() {\n        super.doDisable(...arguments);\n\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\n\nGridFeatureManager.registerFeature(StickyEvents, true, 'Scheduler');\nGridFeatureManager.registerFeature(StickyEvents, false, 'ResourceHistogram');\n","import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport TimeSpan from '../model/TimeSpan.js';\n\n/**\n * @module Scheduler/feature/TimeRanges\n */\n\n/**\n * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch\n * or some important point in time (a `line`, i.e. a range with 0 duration). This feature can also show a current time\n * indicator if you set {@link #config-showCurrentTimeLine} to true. To style the rendered elements, use the\n * {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.\n *\n * {@inlineexample Scheduler/feature/TimeRanges.js}\n *\n * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple\n * {@link Core.data.Store}. The feature uses {@link Scheduler/model/ProjectModel#property-timeRangeStore} defined on the\n * project by default. The store's persisting/loading is handled by Crud Manager (if it's used by the component).\n *\n * Note that the feature uses virtualized rendering, only the currently visible ranges are available in the DOM.\n *\n * This feature is **off** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ## Showing an icon in the time range header\n *\n * You can use Font Awesome icons easily (or set any other icon using CSS) by using the {@link Scheduler.model.TimeSpan#field-iconCls}\n * field. The JSON data below will show a flag icon:\n *\n * ```json\n * {\n *     \"id\"        : 5,\n *     \"iconCls\"   : \"b-fa b-fa-flag\",\n *     \"name\"      : \"v5.0\",\n *     \"startDate\" : \"2019-02-07 15:45\"\n * },\n * ```\n *\n * ## Recurring time ranges\n *\n * The feature supports recurring ranges in case the provided store and models\n * have {@link Scheduler/data/mixin/RecurringTimeSpansMixin} and {@link Scheduler/model/mixin/RecurringTimeSpan}\n * mixins applied:\n *\n * ```javascript\n * // We want to use recurring time ranges so we make a special model extending standard TimeSpan model with\n * // RecurringTimeSpan which adds recurrence support\n * class MyTimeRange extends RecurringTimeSpan(TimeSpan) {}\n *\n * // Define a new store extending standard Store with RecurringTimeSpansMixin mixin to add recurrence support to the\n * // store. This store will contain time ranges.\n * class MyTimeRangeStore extends RecurringTimeSpansMixin(Store) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyTimeRange\n *         };\n *     }\n * };\n *\n * // Instantiate store for timeRanges using our new classes\n * const timeRangeStore = new MyTimeRangeStore({\n *     data : [{\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Lunch',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n *\n * const scheduler = new Scheduler({\n *     ...\n *     features : {\n *         timeRanges : true\n *     },\n *\n *     crudManager : {\n *         // store for \"timeRanges\" feature\n *         timeRangeStore\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @classtype timeRanges\n * @feature\n * @demo Scheduler/timeranges\n */\nexport default class TimeRanges extends AbstractTimeRanges.mixin(AttachToProjectMixin) {\n    //region Config\n\n    static get $name() {\n        return 'TimeRanges';\n    }\n\n    static get defaultConfig() {\n        return {\n            store : true\n        };\n    }\n\n    static configurable = {\n        /**\n         * Store that holds the time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).\n         * A store will be automatically created if none is specified.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Misc\n         */\n        store : {\n            modelClass : TimeSpan\n        },\n\n        /**\n         * The interval (as amount of ms) defining how frequently the current timeline will be updated\n         * @config {Number}\n         * @default\n         * @category Misc\n         */\n        currentTimeLineUpdateInterval : 10000,\n\n        /**\n         * The date format to show in the header for the current time line (when {@link #config-showCurrentTimeLine} is configured).\n         * See {@link Core.helper.DateHelper} for the possible formats to use.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        currentDateFormat : 'HH:mm',\n\n        /**\n         * Show a line indicating current time. Either `true` or `false` or a {@link Scheduler.model.TimeSpan}\n         * configuration object to apply to this special time range (allowing you to provide a custom text):\n         *\n         * ```javascript\n         * showCurrentTimeLine : {\n         *     name : 'Now'\n         * }\n         * ```\n         *\n         * The line carries the CSS class name `b-sch-current-time`, and this may be used to add custom styling to it.\n         *\n         * @prp {Boolean|TimeSpanConfig}\n         * @default\n         * @category Common\n         */\n        showCurrentTimeLine : false\n    }\n\n    //endregion\n\n    //region Init & destroy\n\n    doDestroy() {\n        this.storeDetacher?.();\n\n        super.doDestroy();\n    }\n\n    /**\n     * Returns the TimeRanges which occur within the client Scheduler's time axis.\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get timeRanges() {\n        const me        = this;\n\n        if (!me._timeRanges) {\n            const { store } = me;\n\n            let { records } = store;\n\n            if (store.recurringEvents) {\n                const {\n                    startDate,\n                    endDate\n                } = me.client.timeAxis;\n\n                records = records.flatMap(timeSpan => {\n                    // Collect occurrences for the recurring events in the record set\n                    if (timeSpan.isRecurring) {\n                        return timeSpan.getOccurrencesForDateRange(startDate, endDate);\n                    }\n\n                    return timeSpan;\n                });\n            }\n\n            if (me.currentTimeLine) {\n                // Avoid polluting store records\n                if (!store.recurringEvents) {\n                    records = records.slice();\n                }\n\n                records.push(me.currentTimeLine);\n            }\n\n            me._timeRanges = records;\n        }\n\n        return me._timeRanges;\n    }\n    //endregion\n\n    //region Current time line\n\n    attachToProject(project) {\n        super.attachToProject(project);\n        const me = this;\n\n        me.projectTimeZoneChangeDetacher?.();\n\n        if (me.showCurrentTimeLine) {\n\n            // Update currentTimeLine immediately after a time zone change\n            me.projectTimeZoneChangeDetacher = me.client.project?.ion({ timeZoneChange : () => me.updateCurrentTimeLine() });\n\n            // Update currentTimeLine if its already created\n            if (me.currentTimeLine) {\n                me.updateCurrentTimeLine();\n            }\n        }\n    }\n\n    initCurrentTimeLine() {\n        const me = this;\n\n        if (me.currentTimeLine || !me.showCurrentTimeLine) {\n            return;\n        }\n\n        const data = typeof me.showCurrentTimeLine === 'object' ? me.showCurrentTimeLine : {};\n\n        me.currentTimeLine = me.store.modelClass.new({\n            // eslint-disable-next-line quote-props\n            'id' : 'currentTime',\n            cls  : 'b-sch-current-time'\n        }, data);\n\n        me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);\n\n        me._timeRanges = null;\n\n        me.updateCurrentTimeLine();\n    }\n\n    updateCurrentTimeLine() {\n        const\n            me                  = this,\n            { currentTimeLine } = me;\n\n        currentTimeLine._inTimeZone = me.project?.timeZone;\n        currentTimeLine.setLocalDate('startDate', new Date());\n        currentTimeLine.endDate = currentTimeLine.startDate;\n\n        if (!currentTimeLine.originalData.name) {\n            currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);\n        }\n\n        me.renderRanges();\n    }\n\n    hideCurrentTimeLine() {\n        const me = this;\n\n        if (!me.currentTimeLine) {\n            return;\n        }\n\n        me.clearInterval(me.currentTimeInterval);\n        me.currentTimeLine = null;\n\n        me.refresh();\n    }\n\n    updateShowCurrentTimeLine(show) {\n        if (show) {\n            this.initCurrentTimeLine();\n        }\n        else {\n            this.hideCurrentTimeLine();\n        }\n    }\n\n    //endregion\n\n    //region Menu items\n\n    /**\n     * Adds a menu item to show/hide current time line.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {\n        items.currentTimeLine = {\n            weight   : 400,\n            text     : this.L('L{showCurrentTimeLine}'),\n            checked  : this.showCurrentTimeLine,\n            onToggle : ({ checked }) => {\n                this.showCurrentTimeLine = checked;\n            }\n        };\n    }\n\n    //endregion\n\n    //region Store\n\n    attachToStore(store) {\n        const me = this;\n\n        let renderRanges = false;\n\n        // if we had some store assigned before we need to detach it\n        if (me.storeDetacher) {\n            me.storeDetacher();\n            // then we'll need to render ranges provided by the new store\n            renderRanges = true;\n        }\n\n        me.storeDetacher = store.ion({\n            change  : 'onStoreChange',\n            refresh : 'onStoreChange',\n            thisObj : me\n        });\n\n        me._timeRanges = null;\n\n        // render ranges if needed\n        renderRanges && me.renderRanges();\n    }\n\n    /**\n     * Returns the {@link Core.data.Store store} used by this feature\n     * @property {Core.data.Store}\n     * @category Misc\n     */\n    get store() {\n        return this.client.project.timeRangeStore;\n    }\n\n    updateStore(store) {\n        const\n            me          = this,\n            { client }  = me,\n            { project } = client;\n\n        store = project.timeRangeStore;\n\n        me.attachToStore(store);\n\n        // timeRanges can be set on scheduler/gantt, for convenience. Should only be processed by the TimeRanges and not\n        // any subclasses\n        if (client.timeRanges && !client._timeRangesExposed) {\n            store.add(client.timeRanges);\n            delete client.timeRanges;\n        }\n    }\n\n    // Called by ProjectConsumer after a new store is assigned at runtime\n    attachToTimeRangeStore(store) {\n        this.store = store;\n    }\n\n    resolveTimeRangeRecord(el) {\n        return this.store.getById(el.closest(this.baseSelector).dataset.id);\n    }\n\n    onStoreChange({ type, action }) {\n        const me = this;\n\n        // Force re-evaluating of which ranges to consider for render\n        me._timeRanges = null;\n\n        // https://github.com/bryntum/support/issues/1398 - checking also if scheduler is visible to change elements\n        if (me.disabled || !me.client.isVisible || me.isConfiguring || (type === 'refresh' && action !== 'batch')) {\n            return;\n        }\n\n        me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);\n    }\n\n    //endregion\n\n    //region Drag\n\n    onDragStart(event) {\n        const\n            me                = this,\n            { context }       = event,\n            record            = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl       = me.getBodyElementByRecord(record);\n\n        context.relatedElements = [rangeBodyEl];\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl,\n            originRangeX : DomHelper.getTranslateX(rangeBodyEl),\n            originRangeY : DomHelper.getTranslateY(rangeBodyEl)\n        });\n\n        super.onDragStart(event);\n\n        me.showTip(context);\n    }\n\n    onDrop(event) {\n        const { context } = event;\n\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { record }  = context,\n            box         = Rectangle.from(context.rangeBodyEl),\n            newStart    = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), 'round', false),\n            wasModified = (record.startDate - newStart !== 0);\n\n        if (wasModified) {\n            record.setStartDate(newStart);\n        }\n        else {\n            me.onInvalidDrop();\n        }\n\n        me.destroyTip();\n\n        super.onDrop(event);\n    }\n\n    //endregion\n\n    //region Resize\n\n    onResizeStart({ context }) {\n        const\n            me          = this,\n            record      = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl = me.getBodyElementByRecord(record);\n\n        Object.assign(context, {\n            record,\n            rangeBodyEl\n        });\n\n        me.showTip(context);\n    }\n\n    onResizeDrag({ context }) {\n        const\n            me              = this,\n            { rangeBodyEl } = context;\n\n        if (me.client.isVertical) {\n            if (context.edge === 'top') {\n                DomHelper.setTranslateY(rangeBodyEl, context.newY);\n            }\n\n            rangeBodyEl.style.height = context.newHeight + 'px';\n        }\n        else {\n            if (context.edge === 'left') {\n                DomHelper.setTranslateX(rangeBodyEl, context.newX);\n            }\n\n            rangeBodyEl.style.width = context.newWidth + 'px';\n        }\n    }\n\n    onResize({ context }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n\n        const\n            me          = this,\n            { client }  = me,\n            { rtl }     = client,\n            record      = context.record,\n            box         = Rectangle.from(context.element),\n            startPos    = box.getStart(rtl, client.isHorizontal),\n            endPos      = box.getEnd(rtl, client.isHorizontal),\n            newStart    = client.getDateFromCoordinate(startPos, 'round', false),\n            isStart     = (rtl && context.edge === 'right') || (!rtl && context.edge === 'left') || context.edge === 'top',\n            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),\n            wasModified = (isStart && record.startDate - newStart !== 0) ||\n                (newEnd && record.endDate - newEnd !== 0);\n\n        if (wasModified && newEnd > newStart) {\n            if (isStart) {\n                // could be that the drag operation placed the range with start/end outside the axis\n                record.setStartDate(newStart, false);\n            }\n            else {\n                record.setEndDate(newEnd, false);\n            }\n        }\n        else {\n            me.onInvalidResize({ context });\n        }\n\n        me.destroyTip();\n    }\n\n    onInvalidResize({ context }) {\n        const me = this;\n\n        me.resize.reset();\n        // Allow DomSync to reapply original state\n        context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = null;\n        me.renderRanges();\n\n        me.destroyTip();\n    }\n\n    //endregion\n}\n\nGridFeatureManager.registerFeature(TimeRanges, false, ['Scheduler', 'Gantt']);\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerDom\n */\n\n/**\n * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions\n *\n * @mixin\n */\nexport default Target => class SchedulerDom extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDom';\n    }\n\n    //region Get\n\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromAssignmentRecord(assignmentRecord, returnWrapper = false) {\n        if (this.isPainted && assignmentRecord) {\n            let wrapper = this.foregroundCanvas.syncIdMap?.[assignmentRecord.id];\n\n            // When using links, the original might not be rendered but a link might\n            if (!wrapper && assignmentRecord.resource.hasLinks) {\n                for (const link of assignmentRecord.resource.$links) {\n                    wrapper = this.foregroundCanvas.syncIdMap?.[`${assignmentRecord.id}_${link.id}`];\n\n                    if (wrapper) {\n                        break;\n                    }\n                }\n            }\n\n            // Wrapper wont have syncIdMap when saving dragcreated event from editor\n            return returnWrapper ? wrapper : wrapper?.syncIdMap?.event;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromEventRecord(eventRecord, resourceRecord = eventRecord.resources?.[0], returnWrapper = false) {\n        if (eventRecord.isResourceTimeRange) {\n            const wrapper = this.foregroundCanvas.syncIdMap?.[eventRecord.domId];\n\n            return returnWrapper ? wrapper : wrapper?.syncIdMap.event;\n        }\n\n        const assignmentRecord = this.assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);\n        return this.getElementFromAssignmentRecord(assignmentRecord, returnWrapper);\n    }\n\n    /**\n     * Returns all the HTMLElements representing an event record.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record\n     *\n     * @returns {HTMLElement[]} The element(s) representing the event record\n     * @category DOM\n     */\n    getElementsFromEventRecord(eventRecord, resourceRecord, returnWrapper = false) {\n        // Single event instance, as array\n        if (resourceRecord) {\n            return [this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper)];\n        }\n        // All instances\n        else {\n            return eventRecord.resources.reduce((result, resourceRecord) => {\n                const el = this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper);\n\n                el && result.push(el);\n\n                return result;\n            }, []);\n        }\n    }\n\n    //endregion\n\n    //region Resolve\n\n    /**\n     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in\n     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual\n     * columns.\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from\n     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveResourceRecord(elementOrEvent, xy) {\n        return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);\n    }\n\n    /**\n     * Product agnostic method which yields the {@link Scheduler.model.ResourceModel} record which underpins the row which\n     * encapsulates the passed element. The element can be a grid cell, or an event element, and the result\n     * will be a {@link Scheduler.model.ResourceModel}\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a record from\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     */\n    resolveRowRecord(elementOrEvent) {\n        return this.resolveResourceRecord(elementOrEvent);\n    }\n\n    /**\n     * Returns the event record for a DOM element\n     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup\n     * @returns {Scheduler.model.EventModel} The event record\n     * @category DOM\n     */\n    resolveEventRecord(elementOrEvent) {\n        if (elementOrEvent instanceof Event) {\n            elementOrEvent = elementOrEvent.target;\n        }\n\n        const element = elementOrEvent?.closest(this.eventSelector);\n\n        if (element) {\n            if (element.dataset.eventId) {\n                return this.eventStore.getById(element.dataset.eventId);\n            }\n\n            if (element.dataset.assignmentId) {\n                return this.assignmentStore.getById(element.dataset.assignmentId).event;\n            }\n        }\n\n        return null;\n    }\n\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {\n        return this.resolveEventRecord(element);\n    }\n\n    /**\n     * Returns an assignment record for a DOM element\n     * @param {HTMLElement} element The DOM node to lookup\n     * @returns {Scheduler.model.AssignmentModel} The assignment record\n     * @category DOM\n     */\n    resolveAssignmentRecord(element) {\n        const\n            eventElement     = element.closest(this.eventSelector),\n            assignmentRecord = eventElement && this.assignmentStore.getById(eventElement.dataset.assignmentId),\n            eventRecord      = eventElement && this.eventStore.getById(eventElement.dataset.eventId);\n\n        // When resolving a recurring event, we might be resolving an occurrence\n        return this.assignmentStore.getOccurrence(assignmentRecord, eventRecord);\n    }\n\n    //endregion\n\n    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)\n    isRowVisible(resourceRecord) {\n        // records in collapsed groups/branches etc are removed from processedRecords\n        return this.store.indexOf(resourceRecord) >= 0;\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerDomEvents\n */\n\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class SchedulerDomEvents extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDomEvents';\n    }\n\n    //region Events\n\n    /**\n     * Triggered when user mousedowns over an empty area in the schedule.\n     * @event scheduleMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when mouse enters an empty area in the schedule.\n     * @event scheduleMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when mouse leaves an empty area in the schedule.\n     * @event scheduleMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user mouseups over an empty area in the schedule.\n     * @event scheduleMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user moves mouse over an empty area in the schedule.\n     * @event scheduleMouseMove\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user clicks an empty area in the schedule.\n     * @event scheduleClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user double-clicks an empty area in the schedule.\n     * @event scheduleDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Index of double-clicked resource\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when user right-clicks an empty area in the schedule.\n     * @event scheduleContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse down on an event.\n     * @event eventMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse up on an event.\n     * @event eventMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for click on an event.\n     * @event eventClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for double-click on an event.\n     * @event eventDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for right-click on an event.\n     * @event eventContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse enters an event bar.\n     * @event eventMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered when the mouse leaves an event bar.\n     * @event eventMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse over events when moving into and within an event bar.\n     *\n     * Note that `mouseover` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving into the event bar is required, use the {@link #event-eventMouseEnter} event._\n     * @event eventMouseOver\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    /**\n     * Triggered for mouse out events within and when moving out of an event bar.\n     *\n     * Note that `mouseout` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving out of the event bar is required, use the {@link #event-eventMouseLeave} event._\n     * @event eventMouseOut\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n\n    //endregion\n\n    //region Event handling\n\n    getTimeSpanMouseEventParams(eventElement, event) {\n        // May have hovered a record being removed / faded out\n        const eventRecord = this.resolveEventRecord(eventElement);\n\n        return eventRecord && {\n            eventRecord,\n            resourceRecord   : this.resolveResourceRecord(eventElement),\n            assignmentRecord : this.resolveAssignmentRecord(eventElement),\n            eventElement,\n            event\n        };\n    }\n\n    getScheduleMouseEventParams(cellData, event) {\n        const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);\n\n        return { resourceRecord };\n    }\n\n    /**\n     * Relays keydown events as eventkeydown if we have a selected task.\n     * @private\n     */\n    onElementKeyDown(event) {\n        const\n            result = super.onElementKeyDown(event),\n            me     = this;\n\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyDown', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                // TODO REMOVE FOR 6.0\n                eventRecord       : me.selectedEvents,\n                assignmentRecord  : me.selectedAssignments\n            });\n        }\n\n        return result;\n    }\n\n    /**\n     * Relays keyup events as eventkeyup if we have a selected task.\n     * @private\n     */\n    onElementKeyUp(event) {\n        super.onElementKeyUp(event);\n\n        const me = this;\n\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyUp', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n\n                // TODO REMOVE FOR 5.0\n                eventRecord      : me.selectedEvents,\n                assignmentRecord : me.selectedAssignments\n            });\n        }\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport DomClassList from '../../../Core/helper/util/DomClassList.js';\nimport HorizontalLayoutStack from '../../eventlayout/HorizontalLayoutStack.js';\nimport HorizontalLayoutPack from '../../eventlayout/HorizontalLayoutPack.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerEventRendering\n */\n\n/**\n * Layout data object used to lay out an event record.\n * @typedef {Object} EventRenderData\n * @property {Scheduler.model.EventModel} eventRecord Event instance\n * @property {Scheduler.model.ResourceModel} resourceRecord Assigned resource\n * @property {Scheduler.model.AssignmentModel} assignmentRecord Assignment instance\n * @property {Number} startMS Event start date time in milliseconds\n * @property {Number} endMS Event end date in milliseconds\n * @property {Number} height Calculated event element height\n * @property {Number} width Calculated event element width\n * @property {Number} top Calculated event element top position in the row (or column)\n * @property {Number} left Calculated event element left position in the row (or column)\n */\n\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class SchedulerEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerEventRendering';\n    }\n\n    //region Default config\n\n    static get configurable() {\n        return {\n            /**\n             * Position of the milestone text:\n             * * 'inside' - for short 1-char text displayed inside the diamond, not applicable when using\n             *   {@link #config-milestoneLayoutMode})\n             * * 'outside' - for longer text displayed outside the diamond, but inside it when using\n             *   {@link #config-milestoneLayoutMode}\n             * * 'always-outside' - outside even when combined with {@link #config-milestoneLayoutMode}\n             *\n             * @prp {'inside'|'outside'|'always-outside'}\n             * @default\n             * @category Milestones\n             */\n            milestoneTextPosition : 'outside',\n\n            /**\n             * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`\n             * other than `default`. Valid values are:\n             * * start\n             * * center (default)\n             * * end\n             * @prp {'start'|'center'|'end'}\n             * @default\n             * @category Milestones\n             */\n            milestoneAlign : 'center',\n\n            /**\n             * Factor representing the average char width in pixels used to determine milestone width when configured\n             * with `milestoneLayoutMode: 'estimate'`.\n             * @prp {Number}\n             * @default\n             * @category Milestones\n             */\n            milestoneCharWidth : 10,\n\n            /**\n             * How to handle milestones during event layout. How the milestones are displayed when part of the layout\n             * are controlled using {@link #config-milestoneTextPosition}.\n             *\n             * Options are:\n             * * default - Milestones do not affect event layout\n             * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth\n             * * data - Milestone width is determined by checking EventModel#milestoneWidth\n             * * measure - Milestone width is determined by measuring label width\n             * Please note that currently text width is always determined using EventModel#name.\n             * Also note that only 'default' is supported by eventStyles line, dashed and minimal.\n             * @prp {'default'|'estimate'|'data'|'measure'}\n             * @default\n             * @category Milestones\n             */\n            milestoneLayoutMode : 'default',\n\n            /**\n             * Defines how to handle overlapping events. Valid values are:\n             * - `stack`, adjusts row height (only horizontal)\n             * - `pack`, adjusts event height\n             * - `mixed`, allows two events to overlap, more packs (only vertical)\n             * - `none`, allows events to overlap\n             *\n             * This config can also accept an object:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     eventLayout : { type : 'stack' }\n             * })\n             * ```\n             *\n             * @prp {'stack'|'pack'|'mixed'|'none'|Object}\n             * @default\n             * @category Scheduled events\n             */\n            eventLayout : 'stack',\n\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. See {@link\n             * #config-overlappingEventSorter} for more details.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @member {Function} overlappingEventSorter\n             * @category Misc\n             */\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. This only applies\n             * to the horizontal mode, where the order the events are sorted in determines their vertical placement\n             * within a resource.\n             *\n             * By default, overlapping events are laid out based on the start date. If the start date is equal, events\n             * with earlier end date go first. And lastly the name of events is taken into account.\n             *\n             * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event\n             * `a` is placed above event `b`:\n             *\n             * ```javascript\n             * overlappingEventSorter(a, b) {\n             *\n             *   const startA = a.startDate, endA = a.endDate;\n             *   const startB = b.startDate, endB = b.endDate;\n             *\n             *   const sameStart = (startA - startB === 0);\n             *\n             *   if (sameStart) {\n             *     return endA > endB ? -1 : 1;\n             *   } else {\n             *     return (startA < startB) ? -1 : 1;\n             *   }\n             * }\n             * ```\n             *\n             * NOTE: The algorithms (stack, pack) that lay the events out expects them to be served in chronological\n             * order, be sure to first sort by `startDate` to get predictable results.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @config {function}\n             * @category Misc\n             */\n            overlappingEventSorter : null,\n\n            /**\n             * Deprecated, to be removed in version 6.0. Replaced by {@link #config-overlappingEventSorter}.\n             * @deprecated Since 5.0. Use {@link #config-overlappingEventSorter} instead.\n             * @config {function}\n             */\n            horizontalEventSorterFn : null,\n\n            /**\n             * Control how much space to leave between the first event/last event and the resources edge (top/bottom\n             * margin within the resource row in horizontal mode, left/right margin within the resource column in\n             * vertical mode), in px. Defaults to the value of {@link Scheduler.view.Scheduler#config-barMargin}.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-resourceMargin\n             * resource.resourceMargin}.\n             *\n             * @prp {Number}\n             * @category Scheduled events\n             */\n            resourceMargin : null,\n\n            /**\n             * By default, scheduler fade events in on load. Specify `false` to prevent this animation or specify one\n             * of the available animation types to use it (`true` equals `'fade-in'`):\n             * * fade-in (default)\n             * * slide-from-left\n             * * slide-from-top\n             * ```\n             * // Slide events in from the left on load\n             * scheduler = new Scheduler({\n             *     useInitialAnimation : 'slide-from-left'\n             * });\n             * ```\n             * @prp {Boolean|String}\n             * @default\n             * @category Misc\n             */\n            useInitialAnimation : true,\n\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * an event is rendered into the schedule to render the contents of the event. It's called with the event,\n             * its resource and a `renderData` object which allows you to populate data placeholders inside the event\n             * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.\n             *\n             * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property\n             * is a {@link Core.helper.util.DomClassList} which will be added to the event element. The style property\n             * is an inline style declaration for the event element.\n             *\n             * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS\n             * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as\n             * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as\n             * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.\n             *\n             * ```javascript\n             *  eventRenderer({ eventRecord, resourceRecord, renderData }) {\n             *      renderData.style = 'color:white';                 // You can use inline styles too.\n             *\n             *      // Property names with truthy values are added to the resulting elements CSS class.\n             *      renderData.cls.isImportant = this.isImportant(eventRecord);\n             *      renderData.cls.isModified = eventRecord.isModified;\n             *\n             *      // Remove a class name by setting the property to false\n             *      renderData.cls[scheduler.generatedIdCls] = false;\n             *\n             *      // Or, you can treat it as a string, but this is less efficient, especially\n             *      // if your renderer wants to *remove* classes that may be there.\n             *      renderData.cls += ' extra-class';\n             *\n             *      return StringHelper.xss`${DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD')}: ${eventRecord.name}`;\n             *  }\n             * ```\n             *\n             * @param {Object} detail An object containing the information needed to render an Event.\n             * @param {Scheduler.model.EventModel} detail.eventRecord The event record.\n             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.\n             * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record.\n             * @param {Object} detail.renderData An object containing details about the event rendering.\n             * @param {Scheduler.model.EventModel} detail.renderData.event The event record.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.cls An object whose property names\n             * represent the CSS class names to be added to the event bar element. Set a property's value to truthy or\n             * falsy to add or remove the class name based on the property name. Using this technique, you do not have\n             * to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.wrapperCls An object whose property names\n             * represent the CSS class names to be added to the event wrapper element. Set a property's value to truthy\n             * or falsy to add or remove the class name based on the property name. Using this technique, you do not\n             * have to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.iconCls An object whose property names\n             * represent the CSS class names to be added to an event icon element.\n             *\n             * Note that an element carrying this icon class is injected into the event element *after*\n             * the renderer completes, *before* the renderer's created content.\n             *\n             * To disable this if the renderer takes full control and creates content using the iconCls,\n             * you can set `renderData.iconCls = null`.\n             * @param {Number} detail.renderData.left Vertical offset position (in pixels) on the time axis.\n             * @param {Number} detail.renderData.width Width in pixels of the event element.\n             * @param {Number} detail.renderData.height Height in pixels of the event element.\n             * @param {String|Object<String,String>} detail.renderData.style Inline styles for the event bar DOM element.\n             * Use either 'border: 1px solid black' or `{ border: '1px solid black' }`\n             * @param {String|Object<String,String>} detail.renderData.wrapperStyle Inline styles for wrapper of the\n             * event bar DOM element. Use either 'border: 1px solid green' or `{ border: '1px solid green' }`\n             * @param {String} detail.renderData.eventStyle The `eventStyle` of the event. Use this to apply custom\n             * styles to the event DOM element\n             * @param {String} detail.renderData.eventColor The `eventColor` of the event. Use this to set a custom\n             * color for the rendered event\n             * @param {DomConfig[]} detail.renderData.children An array of DOM configs used as children to the\n             * `b-sch-event` element. Can be populated with additional DOM configs to have more control over contents.\n             * @returns {String|Object} A simple string, or a custom object which will be applied to the\n             * {@link #config-eventBodyTemplate}, creating the actual HTML\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventRenderer : null,\n\n            /**\n             * `this` reference for the {@link #config-eventRenderer} function\n             * @config {Object}\n             * @category Scheduled events\n             */\n            eventRendererThisObj : null,\n\n            /**\n             * Field from EventModel displayed as text in the bar when rendering\n             * @config {String}\n             * @default\n             * @category Scheduled events\n             */\n            eventBarTextField : 'name',\n\n            /**\n             * The template used to generate the markup of your events in the scheduler. To 'populate' the\n             * eventBodyTemplate with data, use the {@link #config-eventRenderer} method.\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventBodyTemplate : null,\n\n            /**\n             * The class responsible for the packing horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutPackClass : HorizontalLayoutPack,\n\n            /**\n             * The class name responsible for the stacking horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutStackClass : HorizontalLayoutStack,\n\n            /**\n             * A config object used to configure the resource columns in vertical mode.\n             * See {@link Scheduler.view.ResourceHeader} for more details on available properties.\n             *\n             * ```\n             * new Scheduler({\n             *   resourceColumns : {\n             *     columnWidth    : 100,\n             *     headerRenderer : ({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`\n             *   }\n             * })\n             * ```\n             * @config {ResourceHeaderConfig}\n             * @category Resources\n             */\n            resourceColumns : null,\n\n            /**\n             * Path to load resource images from. Used by the resource header in vertical mode and the\n             * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature\n             * images for each resource using their `image` or `imageUrl` fields.\n             *\n             * * `image` represents image name inside the specified `resourceImagePath`,\n             * * `imageUrl` represents fully qualified image URL.\n             *\n             *  If set and a resource has no `imageUrl` or `image` specified it will try show miniature using\n             *  the resource's name with {@link #config-resourceImageExtension} appended.\n             *\n             * **NOTE**: The path should end with a `/`:\n             *\n             * ```\n             * new Scheduler({\n             *   resourceImagePath : 'images/resources/'\n             * });\n             * ```\n             * @config {String}\n             * @category Resources\n             */\n            resourceImagePath : null,\n\n            /**\n             * Generic resource image, used when provided `imageUrl` or `image` fields or path calculated from resource\n             * name are all invalid. If left blank, resource name initials will be shown when no image can be loaded.\n             * @default\n             * @config {String}\n             * @category Resources\n             */\n            defaultResourceImageName : null,\n\n            /**\n             * Resource image extension, used when creating image path from resource name.\n             * @default\n             * @config {String}\n             * @category Resources\n             */\n            resourceImageExtension : '.jpg',\n\n            /**\n             * Controls how much space to leave between stacked event bars in px.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-barMargin\n             * resource.barMargin}.\n             *\n             * @config {Number} barMargin\n             * @default\n             * @category Scheduled events\n             */\n\n            // Used to animate events on first render\n            isFirstRender : true,\n\n            initialAnimationDuration : 2000,\n\n            /**\n             * When an event bar has a width less than this value, it gets the CSS class `b-sch-event-narrow`\n             * added. You may apply custom CSS rules using this class.\n             *\n             * In vertical mode, this class causes the text to be rotated so that it runs vertically.\n             * @default\n             * @config {Number}\n             * @category Scheduled events\n             */\n            narrowEventWidth : 10,\n\n            internalEventLayout : null,\n            eventPositionMode   : 'translate',\n            eventScrollMode     : 'move'\n        };\n    }\n\n    //endregion\n\n    //region Settings\n\n    changeEventLayout(eventLayout) {\n        // Pass layout config to internal config to normalize its form\n        this.internalEventLayout = eventLayout;\n\n        // Return normalized string type\n        return this.internalEventLayout.type;\n    }\n\n    changeInternalEventLayout(eventLayout) {\n        return this.getEventLayout(eventLayout);\n    }\n\n    updateInternalEventLayout(eventLayout, oldEventLayout) {\n        const me = this;\n\n        if (oldEventLayout) {\n            me.element.classList.remove(`b-eventlayout-${oldEventLayout.type}`);\n        }\n\n        me.element.classList.add(`b-eventlayout-${eventLayout.type}`);\n\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n\n            me.trigger('stateChange');\n        }\n    }\n\n    changeHorizontalEventSorterFn(fn) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Replaced by overlappingEventSorter()');\n        this.overlappingEventSorter = fn;\n    }\n\n    updateOverlappingEventSorter(fn) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    //endregion\n\n    //region Layout helpers\n\n    // Wraps string config to object with type\n    getEventLayout(value) {\n        if (value?.isModel) {\n            value = value.eventLayout || this.internalEventLayout;\n        }\n\n        if (typeof value === 'string') {\n            value = { type : value };\n        }\n\n        return value;\n    }\n\n    /**\n     * Get event layout handler. The handler decides the vertical placement of events within a resource.\n     * Returns null if no eventLayout is used (if {@link #config-eventLayout} is set to \"none\")\n     * @internal\n     * @returns {Scheduler.eventlayout.HorizontalLayout}\n     * @readonly\n     * @category Scheduled events\n     */\n    getEventLayoutHandler(eventLayout) {\n        const me = this;\n\n        if (!me.isHorizontal) {\n            return null;\n        }\n\n        const\n            { timeAxisViewModel, horizontal } = me,\n            { type }                          = eventLayout;\n\n        if (!me.layouts) {\n            me.layouts = {};\n        }\n\n        switch (type) {\n            // stack, adjust row height to fit all events\n            case 'stack': {\n                if (!me.layouts.horizontalStack) {\n                    me.layouts.horizontalStack = new me.horizontalLayoutStackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyStack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n\n                return me.layouts.horizontalStack;\n            }\n            // pack, fit all events in available height by adjusting their height\n            case 'pack': {\n                if (!me.layouts.horizontalPack) {\n                    me.layouts.horizontalPack = new me.horizontalLayoutPackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyPack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n\n                return me.layouts.horizontalPack;\n            }\n            default:\n                return null;\n        }\n    }\n\n    //endregion\n\n    //region Resource header/columns\n\n    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`\n\n    /**\n     * Use it to manipulate resource column properties at runtime.\n     * @property {Scheduler.view.ResourceHeader}\n     * @readonly\n     */\n    get resourceColumns() {\n        return this.timeAxisColumn?.resourceColumns || this._resourceColumns;\n    }\n\n    /**\n     * Get resource column width. Only applies to vertical mode. To set it, assign to\n     * `scheduler.resourceColumns.columnWidth`.\n     * @property {Number}\n     * @readonly\n     */\n    get resourceColumnWidth() {\n        return this.resourceColumns?.columnWidth || null;\n    }\n\n    //endregion\n\n    //region Event rendering\n\n    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.\n    // Chained by ResourceTimeRanges\n    getEventsToRender(resource, events) {\n        return events;\n    }\n\n    /**\n     * Rerenders events for specified resource (by rerendering the entire row).\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     */\n    repaintEventsForResource(resourceRecord) {\n        this.currentOrientation.repaintEventsForResource(resourceRecord);\n    }\n\n    /**\n     * Rerenders the events for all resources connected to the specified event\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @private\n     */\n    repaintEvent(eventRecord) {\n        const resources = this.eventStore.getResourcesForEvent(eventRecord);\n        resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));\n    }\n\n    // Returns a resource specific resourceMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceMargin(resourceRecord) {\n        return resourceRecord?.resourceMargin ?? this.resourceMargin;\n    }\n\n    // Returns a resource specific barMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getBarMargin(resourceRecord) {\n        return resourceRecord?.barMargin ?? this.barMargin;\n    }\n\n    // Returns a resource specific rowHeight, falling back to Schedulers setting\n    // Prio order: Height from record, configured height\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceHeight(resourceRecord) {\n        return resourceRecord.rowHeight ?? (this.isHorizontal ? this.rowHeight : this.getResourceWidth(resourceRecord));\n    }\n\n    getResourceWidth(resourceRecord) {\n        return resourceRecord.columnWidth ?? this.resourceColumnWidth;\n    }\n\n    // Similar to getResourceHeight(), but for usage later in the process to take height set by renderers into account.\n    // Cant be used earlier in the process because then the row will grow\n    // Prio order: Height requested by renderer, height from record, configured height\n    getAppliedResourceHeight(resourceRecord) {\n        const row = this.getRowById(resourceRecord);\n\n        return row?.maxRequestedHeight ?? this.getResourceHeight(resourceRecord);\n    }\n\n    // Combined convenience getter for destructuring on calling side\n    // Second arg only passed for nested events, handled by NestedEvent feature\n    getResourceLayoutSettings(resourceRecord, parentEventRecord = null) {\n        const\n            resourceMargin = this.getResourceMargin(resourceRecord, parentEventRecord),\n            rowHeight      = this.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n\n        return {\n            barMargin     : this.getBarMargin(resourceRecord, parentEventRecord),\n            contentHeight : Math.max(rowHeight - resourceMargin * 2, 1),\n            rowHeight,\n            resourceMargin\n        };\n    }\n\n    getEventStyle(eventRecord, resourceRecord) {\n        return eventRecord.eventStyle || resourceRecord.eventStyle || this.eventStyle;\n    }\n\n    getEventColor(eventRecord, resourceRecord) {\n        return eventRecord.eventColor || eventRecord.event?.eventColor || eventRecord.parent?.eventColor || resourceRecord.eventColor || this.eventColor;\n    }\n\n    //endregion\n\n    //region Template\n\n    /**\n     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies\n     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for\n     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside the vertical timespan viewport's bounds.\n     * @returns {Object} Data to use in event template, or `undefined` if the event is outside the rendered zone.\n     */\n    generateRenderData(eventRecord, resourceRecord, includeOutside = { viewport : true }) {\n        // TODO: Change this fn to accept an assignment instead of event + resource\n        const\n            me               = this,\n            // generateRenderData calculates layout for events which are outside the vertical viewport\n            // because the RowManager needs to know a row height.\n            renderData       = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside),\n            { isEvent }      = eventRecord,\n            { eventResize }  = me.features,\n            // Don't want events drag created to zero duration to render as milestones\n            isMilestone      = !eventRecord.meta.isDragCreating && eventRecord.isMilestone,\n            // $originalId allows lookup to yield same result for original resources and linked resources\n            assignmentRecord = isEvent && eventRecord.assignments.find(a => a.resourceId === resourceRecord.$originalId),\n            // Events inner element, will be populated by renderer and/or eventBodyTemplate\n            eventContent     = {\n                className : 'b-sch-event-content',\n                role      : 'presentation',\n                dataset   : {\n                    taskBarFeature : 'content'\n                }\n            };\n\n        if (renderData) {\n            renderData.tabIndex = '0';\n\n            let resizable = eventRecord.isResizable;\n\n            if (eventResize && resizable) {\n                if (renderData.startsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'end';\n                    }\n                    else if (resizable === 'start') {\n                        resizable = false;\n                    }\n                }\n                if (renderData.endsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'start';\n                    }\n                    else if (resizable === 'end') {\n                        resizable = false;\n                    }\n                }\n\n                // Let the feature veto start/end handles\n                if (resizable) {\n                    if (me.isHorizontal) {\n                        if ((!me.rtl && !eventResize.leftHandle) || (me.rtl && !eventResize.rightHandle)) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if ((!me.rtl && !eventResize.rightHandle) || (me.rtl && !eventResize.leftHandle)) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                    else {\n                        if (!eventResize.topHandle) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if (!eventResize.bottomHandle) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                }\n            }\n\n            // Event record cls properties are now DomClassList instances, so clone them\n            // so that they can be manipulated here and by renderers.\n            // Truthy value means the key will be added as a class name.\n            // ResourceTimeRanges applies custom cls to wrapper.\n            const\n                // Boolean needed here, otherwise DomSync will dig into comparing the modifications\n                isDirty           = Boolean(\n                    eventRecord.hasPersistableChanges || assignmentRecord?.hasPersistableChanges\n                ),\n                clsListObj        = {\n                    [resourceRecord.cls]      : resourceRecord.cls,\n                    [me.generatedIdCls]       : !eventRecord.isOccurrence && eventRecord.hasGeneratedId,\n                    [me.dirtyCls]             : isDirty,\n                    [me.committingCls]        : eventRecord.isCommitting,\n                    [me.endsOutsideViewCls]   : renderData.endsOutsideView,\n                    [me.startsOutsideViewCls] : renderData.startsOutsideView,\n                    'b-clipped-start'         : renderData.clippedStart,\n                    'b-clipped-end'           : renderData.clippedEnd,\n                    'b-iscreating'            : eventRecord.isCreating,\n                    'b-rtl'                   : me.rtl\n                },\n                wrapperClsListObj = {\n                    [`${me.eventCls}-parent`] : resourceRecord.isParent,\n                    'b-readonly'              : eventRecord.readOnly || assignmentRecord?.readOnly,\n                    'b-linked-resource'       : resourceRecord.isLinked,\n                    'b-original-resource'     : resourceRecord.hasLinks\n                },\n                clsList           = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.internalCls.clone(),\n                wrapperClsList    = eventRecord.isResourceTimeRange ? eventRecord.internalCls.clone() : new DomClassList();\n\n            renderData.wrapperStyle = '';\n\n            // mark as wrapper to make sure fire render events for this level only\n            renderData.isWrap = true;\n\n            // Event specifics, things that do not apply to ResourceTimeRanges\n            if (isEvent) {\n                const selected = assignmentRecord && me.isAssignmentSelected(assignmentRecord);\n\n                ObjectHelper.assign(clsListObj, {\n                    [me.eventCls]                          : 1,\n                    'b-milestone'                          : isMilestone,\n                    'b-sch-event-narrow'                   : !isMilestone && renderData.width < me.narrowEventWidth,\n                    [me.fixedEventCls]                     : eventRecord.isDraggable === false,\n                    [`b-sch-event-resizable-${resizable}`] : Boolean(eventResize?.enabled && !eventRecord.readOnly),\n                    [me.eventSelectedCls]                  : selected,\n                    [me.eventAssignHighlightCls]           : me.eventAssignHighlightCls && !selected && me.isEventSelected(eventRecord),\n                    'b-recurring'                          : eventRecord.isRecurring,\n                    'b-occurrence'                         : eventRecord.isOccurrence,\n                    'b-inactive'                           : eventRecord.inactive\n                });\n\n                renderData.eventId  = eventRecord.id;\n\n                const\n                    eventStyle   = me.getEventStyle(eventRecord, resourceRecord),\n                    eventColor   = me.getEventColor(eventRecord, resourceRecord),\n                    hasAnimation = me.isFirstRender && me.useInitialAnimation && globalThis.bryntum.noAnimations !== true;\n\n                ObjectHelper.assign(wrapperClsListObj, {\n                    [`${me.eventCls}-wrap`] : 1,\n                    'b-milestone-wrap'      : isMilestone\n                });\n\n                if (hasAnimation) {\n                    const\n                        index   = renderData.row ? renderData.row.index : (renderData.top - me.scrollTop) / me.tickSize,\n                        delayMS = index / 20 * 1000;\n\n                    renderData.wrapperStyle = `animation-delay: ${delayMS}ms;`;\n                    me.maxDelay = Math.max(me.maxDelay || 0, delayMS);\n\n                    // Add an extra delay to wait for the most delayed animation to finish\n                    // before we call stopInitialAnimation. In this way, we allow them all to finish\n                    // before we remove the b-initial-${me._useInitialAnimation} class.\n                    if (!me.initialAnimationDetacher) {\n                        me.initialAnimationDetacher = EventHelper.on({\n                            element  : me.foregroundCanvas,\n                            delegate : me.eventSelector,\n\n                            // Just listen for the first animation end fired by our event els\n                            once         : true,\n                            animationend : () => me.setTimeout({\n                                fn                : 'stopInitialAnimation',\n                                delay             : me.maxDelay,\n                                cancelOutstanding : true\n                            }),\n                            // Fallback in case animation is interrupted\n                            expires : {\n                                alt   : 'stopInitialAnimation',\n                                delay : me.initialAnimationDuration + me.maxDelay\n                            },\n                            thisObj : me\n                        });\n                    }\n                }\n\n                renderData.eventColor = eventColor;\n                renderData.eventStyle = eventStyle;\n\n                // TODO: Deprecate assignment, use assignmentRecord\n                renderData.assignmentRecord = renderData.assignment = assignmentRecord;\n            }\n\n            // If not using a wrapping div, this cls will be added to event div for correct rendering\n            renderData.wrapperCls = ObjectHelper.assign(wrapperClsList, wrapperClsListObj);\n\n            renderData.cls = ObjectHelper.assign(clsList, clsListObj);\n            renderData.iconCls = new DomClassList(eventRecord.get(me.eventBarIconClsField) || eventRecord.iconCls);\n\n            // ResourceTimeRanges applies custom style to the wrapper\n            if (eventRecord.isResourceTimeRange) {\n                renderData.style = '';\n                renderData.wrapperStyle += eventRecord.style || '';\n            }\n            // Others to inner\n            else {\n                renderData.style = eventRecord.style || '';\n            }\n\n            // TODO: Deprecate resource in favor of resourceRecord\n            renderData.resource = renderData.resourceRecord = resourceRecord;\n            renderData.resourceId = renderData.rowId;\n\n            if (isEvent) {\n                let childContent = null,\n                    milestoneLabelConfig = null,\n                    value;\n\n                if (me.eventRenderer) {\n                    // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate\n                    const\n                        rendererValue = me.eventRenderer.call(me.eventRendererThisObj || me, {\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord : renderData.assignmentRecord,\n                            renderData\n                        });\n\n                    // If the user's renderer coerced it into a string, recreate a DomClassList.\n                    if (typeof renderData.cls === 'string') {\n                        renderData.cls = new DomClassList(renderData.cls);\n                    }\n\n                    if (typeof renderData.wrapperCls === 'string') {\n                        renderData.wrapperCls = new DomClassList(renderData.wrapperCls);\n                    }\n\n                    // Same goes for iconCls\n                    if (typeof renderData.iconCls === 'string') {\n                        renderData.iconCls = new DomClassList(renderData.iconCls);\n                    }\n\n                    if (me.eventBodyTemplate) {\n                        value = me.eventBodyTemplate(rendererValue);\n                    }\n                    else {\n                        value = rendererValue;\n                    }\n                }\n                else if (me.eventBodyTemplate) {\n                    // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.\n                    value = me.eventBodyTemplate(eventRecord);\n                }\n                else if (me.eventBarTextField) {\n                    // User has specified a field in the data model to read from\n                    value = StringHelper.encodeHtml(eventRecord[me.eventBarTextField] || '');\n                }\n\n                if (!me.eventBodyTemplate || Array.isArray(value)) {\n                    eventContent.children = [];\n\n                    // Give milestone a dedicated label element so we can use padding\n                    if (isMilestone && (me.milestoneLayoutMode === 'default' || me.milestoneTextPosition === 'always-outside') && value != null && value !== '') {\n                        eventContent.children.unshift(milestoneLabelConfig = {\n                            tag      : 'label',\n                            children : []\n                        });\n                    }\n\n                    if (renderData.iconCls?.length) {\n                        eventContent.children.unshift({\n                            tag       : 'i',\n                            className : renderData.iconCls\n                        });\n                    }\n\n                    // Array, assumed to contain DOM configs for eventContent children (or milestone label)\n                    if (Array.isArray(value)) {\n                        (milestoneLabelConfig || eventContent).children.push(...value);\n                    }\n                    // Likely HTML content\n                    else if (StringHelper.isHtml(value)) {\n                        if (eventContent.children.length) {\n                            childContent = {\n                                tag   : 'span',\n                                class : 'b-event-text-wrap',\n                                html  : value\n                            };\n                        }\n                        else {\n                            eventContent.children = null;\n                            eventContent.html = value;\n                        }\n                    }\n                    // DOM config or plain string can be used as is\n                    else if (typeof value === 'string' || typeof value === 'object') {\n                        childContent = value;\n                    }\n                    // Other, use string\n                    else if (value != null) {\n                        childContent = String(value);\n                    }\n\n                    // Must allow empty string as valid content\n                    if (childContent != null) {\n                        // Milestones have content in their label, other events in their \"body\"\n                        (milestoneLabelConfig || eventContent).children.push(childContent);\n                        renderData.cls.add('b-has-content');\n                    }\n\n                    if (eventContent.html != null || eventContent.children.length) {\n                        renderData.children.push(eventContent);\n                    }\n                }\n                else {\n                    eventContent.html = value;\n                    renderData.children.push(eventContent);\n                }\n            }\n\n            const { eventStyle, eventColor } = renderData;\n\n            // Renderers have last say on style & color\n            renderData.wrapperCls[`b-sch-style-${eventStyle || 'none'}`] = 1;\n\n            // Named colors are applied as a class to the wrapper\n            if (DomHelper.isNamedColor(eventColor)) {\n                renderData.wrapperCls[`b-sch-color-${eventColor}`] = eventColor;\n            }\n            else if (eventColor) {\n                const colorProp = eventStyle ? 'color' : 'background-color';\n\n                renderData.style = `${colorProp}:${eventColor};` + renderData.style;\n                renderData.wrapperCls['b-sch-custom-color'] = 1;\n            }\n            else {\n                renderData.wrapperCls[`b-sch-color-none`] = 1;\n            }\n\n            // Milestones has to apply styling to b-sch-event-content\n            if (renderData.style && isMilestone && eventContent) {\n                eventContent.style = renderData.style;\n                delete renderData.style;\n            }\n\n            // If there are any iconCls entries...\n            renderData.cls['b-sch-event-withicon'] = renderData.iconCls?.length;\n\n            // For comparison in sync, cheaper than comparing DocumentFragments\n            renderData.eventContent = eventContent;\n\n            renderData.wrapperChildren = [];\n\n            // Method which features may chain in to\n            me.onEventDataGenerated(renderData);\n        }\n\n        return renderData;\n    }\n\n    /**\n     * A method which may be chained by features. It is called when an event's render\n     * data is calculated so that features may update the style, class list or body.\n     * @param {Object} eventData\n     * @internal\n     */\n    onEventDataGenerated(eventData) {}\n\n    //endregion\n\n    //region Initial animation\n\n    changeUseInitialAnimation(name) {\n        return name === true ? 'fade-in' : name;\n    }\n\n    updateUseInitialAnimation(name, old) {\n        const { classList } = this.element;\n\n        if (old) {\n            classList.remove(`b-initial-${old}`);\n        }\n\n        if (name) {\n            classList.add(`b-initial-${name}`);\n\n            // Transition block for FF, to not interfere with animations\n            if (BrowserHelper.isFirefox) {\n                classList.add('b-prevent-event-transitions');\n            }\n        }\n    }\n\n    /**\n     * Restarts initial events animation with new value {@link #config-useInitialAnimation}.\n     * @param {Boolean|String} initialAnimation new initial animation value\n     */\n    restartInitialAnimation(initialAnimation) {\n        const me = this;\n\n        me.initialAnimationDetacher?.();\n        me.initialAnimationDetacher = null;\n\n        me.useInitialAnimation = initialAnimation;\n        me.isFirstRender = true;\n        me.refresh();\n    }\n\n    stopInitialAnimation() {\n        const me = this;\n\n        me.initialAnimationDetacher();\n        me.isFirstRender = false;\n\n        // Prevent any further initial animations\n        me.useInitialAnimation = false;\n\n        // Remove transition block for FF a bit later, to not interfere with animations\n        if (BrowserHelper.isFirefox) {\n            me.setTimeout(() => me.element.classList.remove('b-prevent-event-transitions'), 100);\n        }\n    }\n\n    //endregion\n\n    //region Milestones\n\n    /**\n     * Determines width of a milestones label. How width is determined is decided by configuring\n     * {@link #config-milestoneLayoutMode}. Please note that text width is always determined using the events\n     * {@link Scheduler/model/EventModel#field-name}.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Number}\n     */\n    getMilestoneLabelWidth(eventRecord, resourceRecord) {\n        const\n            me   = this,\n            mode = me.milestoneLayoutMode,\n            size = me.getResourceLayoutSettings(resourceRecord).contentHeight;\n\n        if (mode === 'measure') {\n            const\n                html    = StringHelper.encodeHtml(eventRecord.name),\n                color   = me.getEventColor(eventRecord, resourceRecord),\n                style   = me.getEventStyle(eventRecord, resourceRecord),\n                element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({\n                    className : {\n                        'b-sch-event-wrap'       : 1,\n                        'b-milestone-wrap'       : 1,\n                        'b-measure'              : 1,\n                        [`b-sch-color-${color}`] : color,\n                        [`b-sch-style-${style}`] : style\n                    },\n                    children : [\n                        {\n                            className : 'b-sch-event b-milestone',\n                            children  : [\n                                {\n                                    className : 'b-sch-event-content',\n                                    children  : [\n                                        { tag : 'label' }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    parent : me.foregroundCanvas\n                }));\n\n            // DomSync should not touch\n            element.retainElement = true;\n\n            element.style.fontSize = `${size}px`;\n\n            if (me.milestoneTextPosition === 'always-outside') {\n                const label = element.firstElementChild.firstElementChild.firstElementChild;\n\n                label.innerHTML = html;\n\n                const bounds = Rectangle.from(label, label.parentElement);\n\n                // +2 for a little margin\n                return bounds.left + bounds.width + 2;\n            }\n            else {\n                // b-sch-event-content\n                element.firstElementChild.firstElementChild.innerHTML = `<label></label>${html}`;\n\n                return element.firstElementChild.offsetWidth;\n            }\n        }\n\n        if (mode === 'estimate') {\n            return eventRecord.name.length * me.milestoneCharWidth + (me.milestoneTextPosition === 'always-outside' ? size : 0);\n        }\n\n        if (mode === 'data') {\n            return eventRecord.milestoneWidth;\n        }\n\n        return 0;\n    }\n\n    updateMilestoneLayoutMode(mode) {\n        const\n            me            = this,\n            alwaysOutside = me.milestoneTextPosition === 'always-outside';\n\n        me.element.classList.toggle('b-sch-layout-milestones', mode !== 'default' && !alwaysOutside);\n        me.element.classList.toggle('b-sch-layout-milestone-labels', mode !== 'default' && alwaysOutside);\n\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n        }\n    }\n\n    updateMilestoneTextPosition(position) {\n        this.element.classList.toggle('b-sch-layout-milestone-text-position-inside', position === 'inside');\n\n        this.updateMilestoneLayoutMode(this.milestoneLayoutMode);\n    }\n\n    updateMilestoneAlign() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    updateMilestoneCharWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n\n    // endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ProjectConsumer from '../../data/mixin/ProjectConsumer.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerStores\n */\n\n/**\n * Functions for store assignment and store event listeners.\n *\n * @mixin\n * @extends Scheduler/data/mixin/ProjectConsumer\n */\nexport default Target => class SchedulerStores extends ProjectConsumer(Target || Base) {\n    static get $name() {\n        return 'SchedulerStores';\n    }\n\n    //region Default config\n\n    // This is the static definition of the Stores we consume from the project, and\n    // which we must provide *TO* the project if we or our CrudManager is configured\n    // with them.\n    // The property name is the store name, and within that there is the dataName which\n    // is the property which provides static data definition. And there is a listeners\n    // definition which specifies the listeners *on this object* for each store.\n    //\n    // To process incoming stores, implement an updateXxxxxStore method such\n    // as `updateEventStore(eventStore)`.\n    //\n    // To process an incoming Project implement `updateProject`. __Note that\n    // `super.updateProject(...arguments)` must be called first.__\n    static get projectStores() {\n        return {\n            resourceStore : {\n                dataName : 'resources'\n            },\n\n            eventStore : {\n                dataName  : 'events',\n                listeners : {\n                    batchedUpdate   : 'onEventStoreBatchedUpdate',\n                    changePreCommit : 'onInternalEventStoreChange',\n                    commitStart     : 'onEventCommitStart',\n                    commit          : 'onEventCommit',\n                    exception       : 'onEventException',\n                    idchange        : 'onEventIdChange',\n                    beforeLoad      : 'applyStartEndParameters'\n                }\n            },\n\n            assignmentStore : {\n                dataName  : 'assignments',\n                listeners : {\n                    changePreCommit : 'onAssignmentChange', // In EventSelection.js\n                    commitStart     : 'onAssignmentCommitStart',\n                    commit          : 'onAssignmentCommit',\n                    exception       : 'onAssignmentException',\n                    beforeRemove    : {\n                        fn   : 'onAssignmentBeforeRemove',\n                        // We must go last in case an app vetoes a remove\n                        // by returning false from a handler.\n                        prio : -1000\n                    }\n                }\n            },\n\n            dependencyStore : {\n                dataName : 'dependencies'\n            },\n\n            calendarManagerStore   : {},\n            timeRangeStore         : {},\n            resourceTimeRangeStore : {}\n        };\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Overridden to *not* auto create a store at the Scheduler level.\n             * The store is the {@link Scheduler.data.ResourceStore} of the backing project\n             * @config {Core.data.Store}\n             * @private\n             */\n            store : null,\n\n            /**\n             * The name of the start date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            startParamName : 'startDate',\n\n            /**\n             * The name of the end date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            endParamName : 'endDate',\n\n            /**\n             * true to apply start and end dates of the current view to any `eventStore` load requests.\n             * @config {Boolean}\n             * @category Data\n             */\n            passStartEndParameters : false,\n\n            /**\n             * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to\n             * {@link #config-crudManager} config.\n             * @config {Scheduler.data.CrudManager}\n             * @typings {typeof CrudManager}\n             * @category Data\n             */\n            crudManagerClass : null,\n\n            /**\n             * Get/set the CrudManager instance\n             * @member {Scheduler.data.CrudManager} crudManager\n             * @category Data\n             */\n            /**\n             * Supply a {@link Scheduler.data.CrudManager} instance or a config object if you want to use\n             * CrudManager for handling data.\n             * @config {CrudManagerConfig|Scheduler.data.CrudManager}\n             * @category Data\n             */\n            crudManager : null\n        };\n    }\n\n    //endregion\n\n    //region Project\n\n    updateProject(project, oldProject) {\n        super.updateProject(project, oldProject);\n\n        this.detachListeners('schedulerStores');\n\n        project.ion({\n            name    : 'schedulerStores',\n            refresh : 'onProjectRefresh',\n            thisObj : this\n        });\n    }\n\n    // Called when project changes are committed, before data is written back to records (but still ready to render\n    // since data is fetched from engine)\n    onProjectRefresh({ isInitialCommit }) {\n        const me = this;\n\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            if (isInitialCommit) {\n                if (me.isVertical) {\n                    me.refreshAfterProjectRefresh = false;\n                    me.refreshWithTransition();\n                }\n            }\n\n            if (me.navigateToAfterRefresh) {\n                me.navigateTo(me.navigateToAfterRefresh);\n                me.navigateToAfterRefresh = null;\n            }\n\n            if (me.refreshAfterProjectRefresh) {\n                me.refreshWithTransition(false, !isInitialCommit);\n                me.refreshAfterProjectRefresh = false;\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n\n    //endregion\n\n    //region CrudManager\n\n    changeCrudManager(crudManager) {\n        const me = this;\n\n        if (crudManager && !crudManager.isCrudManager) {\n            //<debug>\n            if (!me.crudManagerClass) {\n                throw new Error('No CrudManager class configured on CrudManager\\'s View');\n            }\n            //</debug>\n\n            // CrudManager injects itself into is Scheduler's _crudManager property\n            // because code it triggers needs to access it through its getter.\n            crudManager = me.crudManagerClass.new({\n                scheduler : me\n            }, crudManager);\n        }\n        // config setter will veto because of above described behaviour\n        // of setting the property early on creation\n        me._crudManager = crudManager;\n\n        me.bindCrudManager(crudManager);\n    }\n\n    //endregion\n\n    //region Row store\n\n    get store() {\n        // Vertical uses a dummy store\n        if (!this._store && this.isVertical) {\n            // TODO: Make this store readonly, since we are using single cell approach\n            this._store = new Store({\n                data : [\n                    {\n                        // Quoted to avoid commit-hook check:\n                        'id' : 'verticalTimeAxisRow', // eslint-disable-line quote-props\n                        cls  : 'b-verticaltimeaxis-row'\n                    }\n                ]\n            });\n        }\n\n        return super.store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid\n    refreshFromRowOnStoreAdd(row, { isExpand, records }) {\n        const args = arguments;\n\n        this.runWithTransition(() => {\n            // Postpone drawing of events for a new resource until the following project refresh. Previously the draw\n            // would not happen because engine was not ready, but now when we allow commits and can read values during\n            // commit that block is no longer there\n            this.currentOrientation.suspended = !isExpand && !records.some(r => r.isLinked);\n\n            super.refreshFromRowOnStoreAdd(row, ...args);\n\n            this.currentOrientation.suspended = false;\n        }, !isExpand);\n    }\n\n    onStoreAdd(event) {\n        super.onStoreAdd(event);\n\n        if (this.isPainted) {\n            this.calculateRowHeights(event.records);\n        }\n    }\n\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        // Ignore engine changes that do not affect row rendering\n        let ignoreCount = 0;\n\n        if ('assigned' in changes) {\n            ignoreCount++;\n        }\n\n        if ('calendar' in changes) {\n            ignoreCount++;\n        }\n\n        if (ignoreCount !== Object.keys(changes).length) {\n            super.onStoreUpdateRecord(...arguments);\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    updateResourceStore(resourceStore) {\n        // Reconfigure grid if resourceStore is backing the rows\n        if (resourceStore && this.isHorizontal) {\n            resourceStore.metaMapId = this.id;\n            this.store = resourceStore;\n        }\n    }\n\n    get usesDisplayStore() {\n        return this.store !== this.resourceStore;\n    }\n\n    //endregion\n\n    //region Events\n\n    onEventIdChange(params) {\n        this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);\n    }\n\n    /**\n     * Listener to the batchedUpdate event which fires when a field is changed on a record which\n     * is batch updating. Occasionally UIs must keep in sync with batched changes.\n     * For example, the EventResize feature performs batched updating of the startDate/endDate\n     * and it tells its client to listen to batchedUpdate.\n     * @private\n     */\n    onEventStoreBatchedUpdate(event) {\n        if (this.listenToBatchedUpdates) {\n            return this.onInternalEventStoreChange(event);\n        }\n    }\n\n    /**\n     * Calls appropriate functions for current event layout when the event store is modified.\n     * @private\n     */\n    // Named as Internal to avoid naming collision with wrappers that relay events\n    onInternalEventStoreChange(params) {\n        // Too early, bail out\n        // Also bail out if this is a reassign using resourceId, any updates will be handled by AssignmentStore instead\n        if (!this.isPainted || !this._mode || params.isAssign || this.assignmentStore.isRemovingAssignment) {\n            return;\n        }\n\n        this.currentOrientation.onEventStoreChange(params);\n    }\n\n    /**\n     * Refreshes committed events, to remove dirty/committing flag.\n     * CSS is added\n     * @private\n     */\n    onEventCommit({ changes }) {\n        let resourcesToRepaint = [...changes.added, ...changes.modified].map(\n            eventRecord => this.eventStore.getResourcesForEvent(eventRecord)\n        );\n\n        // getResourcesForEvent returns an array, so need to flatten resourcesToRepaint\n        resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);\n\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n\n    /**\n     * Adds the committing flag to changed events before commit.\n     * @private\n     */\n    onEventCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        // Committing sets a flag in meta that during event rendering applies a CSS class. But to not mess up drag and\n        // drop between resources no redraw is performed before committing, so class is never applied to the element(s).\n        // Applying here instead\n        [...changes.added, ...changes.modified].forEach(eventRecord =>\n            eventRecord.assignments.forEach(\n                assignmentRecord => currentOrientation.toggleCls(assignmentRecord, committingCls, true)\n            )\n        );\n    }\n\n    // Clear committing flag\n    onEventException({ action }) {\n        if (action === 'commit') {\n            const { changes } = this.eventStore;\n\n            [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord =>\n                this.repaintEvent(eventRecord)\n            );\n        }\n    }\n\n    onAssignmentCommit({ changes }) {\n        this.repaintEventsForAssignmentChanges(changes);\n    }\n\n    onAssignmentCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n\n        [...changes.added, ...changes.modified].forEach(assignmentRecord => {\n            currentOrientation.toggleCls(assignmentRecord, committingCls, true);\n        });\n    }\n\n    // Clear committing flag\n    onAssignmentException({ action }) {\n        if (action === 'commit') {\n            this.repaintEventsForAssignmentChanges(this.assignmentStore.changes);\n        }\n    }\n\n    repaintEventsForAssignmentChanges(changes) {\n        const resourcesToRepaint = [...changes.added, ...changes.modified, ...changes.removed].map(\n            assignmentRecord => assignmentRecord.getResource()\n        );\n\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n\n    onAssignmentBeforeRemove({ records, removingAll }) {\n        if (removingAll) {\n            return;\n        }\n\n        const me = this;\n\n        let moveTo;\n\n        // Deassigning the active assignment\n        if (!me.isConfiguring &&\n            // If we have current active assignment or we scheduled navigating to an assignment, we should check\n            // if we're removing that assignment in order to avoid navigating to it\n            (me.navigateToAfterRefresh || me.activeAssignment && records.includes(me.activeAssignment))\n        ) {\n            // If next navigation target is removed, clean up the flag\n            if (records.includes(me.navigateToAfterRefresh)) {\n                me.navigateToAfterRefresh = null;\n            }\n            // If being done by a keyboard gesture then look for a close target until we find an existing record, not\n            // scheduled for removal. Otherwise, push focus outside of the Scheduler.\n            // This condition will react not only on meaningful keyboard action - like pressing DELETE key on selected\n            // event - but also in case user started dragging and pressed CTRL (or any other key) in process.\n            // https://github.com/bryntum/support/issues/3479\n            if (GlobalEvents.lastInteractionType === 'key') {\n                // Look for a close target until we find an existing record, not scheduled for removal. Provided\n                // assignment position in store is arbitrary as well as order of removed records, it does not make much\n                // sense trying to apply any specific order to them. Existing assignment next to any removed one is as\n                // good as any.\n                for (let i = 0, l = records.length; i < l && !moveTo; i++) {\n                    const assignment = records[i];\n\n                    if (assignment.resource && assignment.resource.isModel) {\n                        // Find next record\n                        let next = me.getNext(assignment);\n\n                        // If next record is not found or also removed, look for previous. This should not become a\n                        // performance bottleneck because we only can get to this code if project is committing, if\n                        // records are removed on a dragdrop listener and user pressed any key after mousedown, or if\n                        // user is operating with a keyboard and pressed [DELETE] to remove multiple records.\n                        if (!next || records.includes(next)) {\n                            next = me.getPrevious(assignment);\n                        }\n\n                        if (next && !records.includes(next)) {\n                            moveTo = next;\n                        }\n                    }\n                }\n            }\n\n            // Move focus away from the element which will soon have no backing data.\n            if (moveTo) {\n                // Although removing records from assignment store will trigger project commit and consequently\n                // `refresh` event on the project which will use this record to navigate to, some tests expect\n                // immediate navigation\n                me.navigateTo(moveTo);\n                me.navigateToAfterRefresh = moveTo;\n            }\n            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation\n            // key gesture is delivered before the outgoing event's element has faded\n            // out and been removed, navigation will be attempted from a deleted\n            // event. Animated hiding is problematic.\n            //\n            // We cannot just revertFocus() because that might move focus back to an\n            // element in a floating EventEditor which is not yet faded out and\n            // been removed. Animated hiding is problematic.\n            //\n            // We cannot focus scheduler.timeAxisColumn.element because the browser\n            // would scroll it in some way if we have horizontal overflow.\n            //\n            // The only thing we can know about to focus here is the Scheduler itself.\n            else {\n                DomHelper.focusWithoutScrolling(me.focusElement);\n            }\n        }\n    }\n\n    //endregion\n\n    //region TimeRangeStore & TimeRanges\n\n    /**\n     * Inline time ranges, will be loaded into an internally created store if {@link Scheduler.feature.TimeRanges}\n     * is enabled.\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Data\n     */\n\n    /**\n     * Get/set time ranges, applies to the backing project's TimeRangeStore.\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the time ranges store instance or config object for {@link Scheduler.feature.TimeRanges} feature.\n     * @member {Core.data.Store} timeRangeStore\n     * @accepts {Core.data.Store|StoreConfig}\n     * @category Data\n     */\n\n    /**\n     * The time ranges store instance for {@link Scheduler.feature.TimeRanges} feature.\n     * @config {Core.data.Store|StoreConfig} timeRangeStore\n     * @category Data\n     */\n\n    set timeRanges(timeRanges) {\n        this.project.timeRanges = timeRanges;\n    }\n\n    get timeRanges() {\n        return this.project.timeRanges;\n    }\n\n    //endregion\n\n    //region ResourceTimeRangeStore\n\n    /**\n     * Inline resource time ranges, will be loaded into an internally created store if\n     * {@link Scheduler.feature.ResourceTimeRanges ResourceTimeRanges} is enabled.\n     * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges\n     * @category Data\n     */\n\n    /**\n     * Get/set time ranges, applies to the backing project's ResourceTimeRangeStore.\n     * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the resource time ranges store instance for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n     * @accepts {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n     * @category Data\n     */\n\n    /**\n     * Resource time ranges store instance or config object for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig} resourceTimeRangeStore\n     * @category Data\n     */\n\n    set resourceTimeRanges(resourceTimeRanges) {\n        this.project.resourceTimeRanges = resourceTimeRanges;\n    }\n\n    get resourceTimeRanges() {\n        return this.project.resourceTimeRanges;\n    }\n\n    //endregion\n\n    //region Other functions\n\n    /**\n     * Applies the start and end date to each event store request (formatted in the same way as the start date, defined\n     * in the EventStore Model class).\n     * @category Data\n     */\n    applyStartEndParameters({ source : eventStore, params }) {\n        const\n            me = this,\n            field = eventStore.modelClass.fieldMap.startDate;\n\n        if (me.passStartEndParameters) {\n            params[me.startParamName] = field.print(me.startDate);\n            params[me.endParamName] = field.print(me.endDate);\n        }\n    }\n\n    /**\n     * Get events grouped by timeAxis ticks from resources array\n     * @category Data\n     * @param {Scheduler.model.ResourceModel[]} resources An array of resources to process. If not passed, all resources\n     * will be used.\n     * @param {Function} filterFn filter function to filter events if required. Optional.\n     * @private\n     */\n    getResourcesEventsPerTick(resources, filterFn) {\n        const\n            { timeAxis, resourceStore } = this,\n            eventsByTick                = [];\n\n        resources = resources || resourceStore.records;\n        resources.forEach(resource => {\n            resource.events.forEach(event => {\n                if (!timeAxis.isTimeSpanInAxis(event) || (filterFn && !filterFn.call(this, { resource, event }))) {\n                    return;\n                }\n                // getTickFromDate may return float if event starts/ends in a middle of a tick\n                let startTick = Math.floor(timeAxis.getTickFromDate(event.startDate)),\n                    endTick = Math.ceil(timeAxis.getTickFromDate(event.endDate));\n\n                // if startDate/endDate of the event is out of timeAxis' bounds, use first/last tick id instead\n                if (startTick == -1) {\n                    startTick = 0;\n                }\n\n                if (endTick === -1) {\n                    endTick = timeAxis.ticks.length;\n                }\n\n                do {\n                    if (!eventsByTick[startTick]) {\n                        eventsByTick[startTick] = [event];\n                    }\n                    else {\n                        eventsByTick[startTick].push(event);\n                    }\n                } while (++startTick < endTick);\n            });\n        });\n\n        return eventsByTick;\n    }\n\n    //endregion\n\n    //region WidgetClass\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n\n    //endregion\n};\n","import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerScroll\n */\n\nconst\n    defaultScrollOptions = {\n        block      : 'nearest',\n        edgeOffset : 20\n    },\n    unrenderedScrollOptions = {\n        highlight : false,\n        focus     : false\n    };\n\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerScroll extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerScroll';\n    }\n\n    //region Scroll to event\n\n    /**\n     * Scrolls an event record into the viewport.\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.\n     *\n     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord the event record to scroll into view\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @async\n     * @category Scrolling\n     */\n    async scrollEventIntoView(eventRecord, options = defaultScrollOptions) {\n        const\n            me        = this,\n            resources = eventRecord.resources || [eventRecord];\n\n        if (resources.length > 1) {\n            throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');\n        }\n\n        if (!resources.length) {\n            console.warn('You have asked to scroll to an event which is not assigned to a resource');\n        }\n\n        await me.scrollResourceEventIntoView(resources[0], eventRecord, options);\n    }\n\n    /**\n     * Scrolls an assignment record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord A resource record an event record is assigned to\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollAssignmentIntoView(assignmentRecord, ...args) {\n        return this.scrollResourceEventIntoView(assignmentRecord.resource, assignmentRecord.event, ...args);\n    }\n\n    /**\n     * Scrolls a resource event record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {Scheduler.model.EventModel} eventRecord An event record to scroll into view\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     * @async\n     */\n    async scrollResourceEventIntoView(resourceRecord, eventRecord, options = defaultScrollOptions) {\n        const\n            me             = this,\n            eventStart     = eventRecord.startDate,\n            eventEnd       = eventRecord.endDate,\n            eventIsOutside = eventRecord.isScheduled && eventStart < me.timeAxis.startDate | ((eventEnd > me.timeAxis.endDate) << 1);\n\n        // TODO Remove in 6.0\n        if (arguments.length > 3) {\n            options = arguments[3];\n        }\n\n        let el;\n\n        if (options.edgeOffset == null) {\n            options.edgeOffset = 20;\n        }\n\n        // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.\n        // The EventEdit feature passes false because it must not mutate the TimeAxis.\n        // Bitwise flag:\n        //  1 === start is before TimeAxis start.\n        //  2 === end is after TimeAxis end.\n        if (eventIsOutside && options.extendTimeAxis !== false) {\n            const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;\n\n            // Event is too wide, expand the range to encompass it.\n            if (eventIsOutside === 3) {\n                me.setTimeSpan(\n                    new Date(eventStart.valueOf() - currentTimeSpanRange / 2),\n                    new Date(eventEnd.getTime() + currentTimeSpanRange / 2)\n                );\n            }\n            // Event is partially or wholly outside but will fit.\n            // Move the TimeAxis to include it. That will maintain visual position.\n            else {\n                // Event starts before\n                if (eventIsOutside & 1) {\n                    me.setTimeSpan(\n                        new Date(eventStart),\n                        new Date(eventStart.valueOf() + currentTimeSpanRange)\n                    );\n                }\n                // Event ends after\n                else {\n                    me.setTimeSpan(\n                        new Date(eventEnd.valueOf() - currentTimeSpanRange),\n                        new Date(eventEnd)\n                    );\n                }\n            }\n        }\n\n        if (me.store.tree) {\n            // If we're a tree, ensure parents are expanded first\n            await me.expandTo?.(resourceRecord);\n        }\n\n        // Handle nested events too\n        if (eventRecord.parent && !eventRecord.parent.isRoot) {\n            await this.scrollEventIntoView(eventRecord.parent);\n        }\n\n        // Establishing element to scroll to\n        el = me.getElementFromEventRecord(eventRecord, resourceRecord);\n\n        if (el) {\n            // It's usually the event wrapper that holds focus\n            if (!DomHelper.isFocusable(el)) {\n                el = el.parentNode;\n            }\n\n            const scroller = me.timeAxisSubGrid.scrollable;\n\n            // Force horizontalscroll to be triggered directly on scroll instead of on next frame, to have events\n            // already drawn when promise resolves\n            me.timeAxisSubGrid.forceScrollUpdate = true;\n            // Scroll into view with animation and highlighting if needed.\n            await scroller.scrollIntoView(el, options);\n        }\n        else if (eventIsOutside && options.extendTimeAxis === false) {\n            console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');\n        }\n        else if (!eventRecord.isOccurrence && !me.eventStore.isAvailable(eventRecord)) {\n            console.warn('You have asked to scroll to an event which is not available');\n        }\n        else if (eventRecord.isScheduled) {\n            // Event scheduled but not rendered, scroll to calculated location\n            await me.scrollUnrenderedEventIntoView(resourceRecord, eventRecord, options);\n        }\n        else {\n            // Event not scheduled, just scroll resource row into view\n            await me.scrollResourceIntoView(resourceRecord, options);\n        }\n    }\n\n    /**\n     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.\n     * @private\n     * @category Scrolling\n     */\n    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions) {\n        // We must only resolve when the event's element has been painted\n        // *and* the scroll has fully completed.\n        return new Promise(resolve => {\n            const\n                me               = this,\n                // Knock out highlight and focus options. They must be applied after the scroll\n                // has fully completed and we have an element. Use a default edgeOffset of 20.\n                modifiedOptions  = Object.assign({ edgeOffset : 20 }, options, unrenderedScrollOptions),\n                scroller         = me.timeAxisSubGrid.scrollable,\n                box              = me.getResourceEventBox(eventRec, resourceRec),\n                scrollerViewport = scroller.viewport;\n\n            // Event may fall on a time not included by workingTime settings\n            if (!scrollerViewport || !box) {\n                resolve();\n                return;\n            }\n\n            // In case of subPixel position, scroll the whole pixel into view\n            box.x = Math.ceil(box.x);\n            box.y = Math.ceil(box.y);\n\n            if (me.rtl) {\n                // RTL scrolls in negative direction but coordinates are still LTR\n                box.translate(-me.timeAxisViewModel.totalSize + scrollerViewport.width, 0);\n            }\n\n            // Note use of scroller.scrollLeft here. We need the natural DOM scrollLeft value\n            // not the +ve X position along the scrolling axis.\n            box.translate(scrollerViewport.x - scroller.scrollLeft, scrollerViewport.y - scroller.y);\n\n            const\n                // delta         = scroller.getDeltaTo(box, modifiedOptions)[me.isHorizontal ? 'xDelta' : 'yDelta'],\n                onEventRender = async({ eventRecord, element, targetElement }) => {\n                    if (eventRecord === eventRec) {\n                        // Vertical's renderEvent is different to horizontal's\n                        const el = element || targetElement;\n\n                        detacher();\n\n                        // Don't resolve until the scroll has fully completed.\n                        await initialScrollPromise;\n\n                        options.highlight && DomHelper.highlight(el);\n                        options.focus && el.focus();\n\n                        resolve();\n                    }\n                },\n                // On either paint or repaint of the event, resolve the scroll promise and detach the listeners.\n                detacher = me.ion({\n                    renderEvent : onEventRender\n                }),\n                initialScrollPromise = scroller.scrollIntoView(box, modifiedOptions);\n        });\n    }\n\n    /**\n     * Scrolls the specified resource into view, works for both horizontal and vertical modes.\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {ScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions) {\n        if (this.isVertical) {\n            return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);\n        }\n        else {\n            return this.scrollRowIntoView(resourceRecord, options);\n        }\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerRegions\n */\n\n/**\n * Functions to get regions (bounding boxes) for scheduler, events etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerRegions extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerRegions';\n    }\n\n    //region Orientation dependent regions\n\n    /**\n     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the\n     * scheduler for the resource availability by calling getResourceAvailability. By overriding that method you can\n     * constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record\n     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints) {\n        return this.currentOrientation.getScheduleRegion(...arguments);\n    }\n\n    /**\n     * Gets the region, relative to the timeline view element, representing the passed resource and optionally just for a certain date interval.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} A Rectangle which encapsulates the resource time span\n     */\n    getResourceRegion(resourceRecord, startDate, endDate) {\n        return this.currentOrientation.getRowRegion(...arguments);\n    }\n\n    //endregion\n\n    //region ResourceEventBox\n\n    getAssignmentEventBox(assignmentRecord, includesOutside) {\n        return this.getResourceEventBox(assignmentRecord.event, assignmentRecord.resource, includesOutside);\n    }\n\n    /**\n     * Get the region for a specified resources specified event.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both\n     *   dimensions. This option is used when calculating dependency lines, and we need to include routes from events\n     *   which may be outside the rendered zone.\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false, roughly = false) {\n        return this.currentOrientation.getResourceEventBox(...arguments);\n    }\n\n    //endregion\n\n    //region Item box\n\n    /**\n     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item\n     * then the method returns all of them. Box coordinates are in view coordinate system.\n     *\n     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)\n     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible\n     * top row or below currently visible bottom row) will be calculated approximately.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Object|Object[]}\n     * @returns {Boolean} return.isPainted Whether the box was calculated for the rendered scheduled record or was\n     *    approximately calculated for the scheduled record outside of the current vertical view area.\n     * @returns {Number} return.top\n     * @returns {Number} return.bottom\n     * @returns {Number} return.start\n     * @returns {Number} return.end\n     * @returns {'before'|'after'} return.relPos if the item is not rendered then provides a view relative\n     * position one of 'before', 'after'\n     * @internal\n     */\n    getItemBox(event, includeOutside = false) {\n        return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));\n    }\n\n    //endregion\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Scheduler/view/mixin/SchedulerState\n */\n\nconst copyProperties = [\n    'eventLayout',\n    'mode',\n    'eventColor',\n    'eventStyle',\n    'tickSize',\n    'fillTicks'\n];\n\n/**\n * A Mixin for Scheduler that handles state. It serializes the following scheduler properties, in addition to what\n * is already stored by its superclass {@link Grid/view/mixin/GridState}:\n *\n * * eventLayout\n * * barMargin\n * * mode\n * * tickSize\n * * zoomLevel\n * * eventColor\n * * eventStyle\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class SchedulerState extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerState';\n    }\n\n    /**\n     * Gets or sets scheduler's state. Check out {@link Scheduler.view.mixin.SchedulerState} mixin\n     * and {@link Grid.view.mixin.GridState} for more details.\n     * @member {Object} state\n     * @property {String} state.eventLayout\n     * @property {String} state.eventStyle\n     * @property {String} state.eventColor\n     * @property {Number} state.barMargin\n     * @property {Number} state.tickSize\n     * @property {Boolean} state.fillTicks\n     * @property {Number} state.zoomLevel\n     * @property {'horizontal'|'vertical'} state.mode\n     * @property {Object[]} state.columns\n     * @property {Boolean} state.readOnly\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.selectedCell\n     * @property {String} state.style\n     * @property {Object} state.subGrids\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     */\n\n    /**\n     * Get scheduler's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        return ObjectHelper.copyProperties(super.getState(), this, copyProperties);\n    }\n\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        this.suspendRefresh();\n\n        let propsToCopy = copyProperties.slice();\n\n        if (state?.eventLayout === 'layoutFn') {\n            delete state.eventLayout;\n            propsToCopy.splice(propsToCopy.indexOf('eventLayout'), 1);\n        }\n\n        // Zoom level will set tick size, no need to update model additionally\n        if (state?.zoomLevelOptions?.width) {\n            propsToCopy = propsToCopy.filter(p => p !== 'tickSize');\n        }\n\n        ObjectHelper.copyProperties(this, state, propsToCopy);\n\n        super.applyState(state);\n\n        this.resumeRefresh(true);\n    }\n\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n","import BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/view/orientation/HorizontalRendering\n */\n\n/**\n * @typedef HorizontalRenderData\n * @property {Scheduler.model.EventModel} eventRecord\n * @property {Date} start Span start\n * @property {Date} end Span end\n * @property {String} rowId Id of the resource row\n * @property {DomConfig[]} children Child elements\n * @property {Number} startMS Wrap element start in milliseconds\n * @property {Number} endMS Span Wrap element end in milliseconds\n * @property {Number} durationMS Wrap duration in milliseconds (not just a difference between start and end)\n * @property {Number} innerStartMS Actual event start in milliseconds\n * @property {Number} innerEndMS Actual event end in milliseconds\n * @property {Number} innerDurationMS Actual event duration in milliseconds\n * @property {Boolean} startsOutsideView True if span starts before time axis start\n * @property {Boolean} endsOutsideView True if span ends after time axis end\n * @property {Number} left Absolute left coordinate of the wrap element\n * @property {Number} width\n * @property {Number} top Absolute top coordinate of the wrap element (can be changed by layout)\n * @property {Number} height\n * @property {Boolean} clippedStart True if start is clipped\n * @property {Boolean} clippedEnd True if end is clipped\n * @private\n */\n\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    MAX_WIDTH           = 9999999,\n    heightEventSorter   = ({ startDateMS : lhs }, { startDateMS : rhs }) => lhs - rhs,\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    };\n\nfunction getStartEnd(scheduler, eventRecord, useEnd, fieldName, useEventBuffer) {\n    // Must use Model.get in order to get latest values in case we are inside a batch.\n    // EventResize changes the endDate using batching to enable a tentative change\n    // via the batchedUpdate event which is triggered when changing a field in a batch.\n    // Fall back to accessor if propagation has not populated date fields.\n    const\n        { timeAxis }     = scheduler,\n        date             = eventRecord.isBatchUpdating && !useEventBuffer ? eventRecord.get(fieldName) : eventRecord[fieldName],\n        hasBatchedChange = eventRecord.hasBatchedChange?.(fieldName),\n        // fillTicks shouldn't be used during resizing for changing date for smooth animation.\n        // correct date will be applied after resize, when `isResizing` will be falsy\n        useTickDates     = scheduler.fillTicks && (!eventRecord.meta.isResizing || !hasBatchedChange);\n\n    if (useTickDates) {\n        let tick = timeAxis.getTickFromDate(date);\n\n        if (tick >= 0) {\n            // If date matches a tick start/end, use the earlier tick\n            if (useEnd && tick === Math.round(tick) && tick > 0) {\n                tick--;\n            }\n\n            const\n                tickIndex  = Math.floor(tick),\n                tickRecord = timeAxis.getAt(tickIndex);\n\n            return tickRecord[fieldName].getTime();\n        }\n    }\n\n    return date?.getTime();\n}\n\n/**\n * Handles event rendering in Schedulers horizontal mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class HorizontalRendering extends Base.mixin(AttachToProjectMixin) {\n    //region Config & Init\n\n    static $name = 'HorizontalRendering';\n\n    static get configurable() {\n        return {\n            // It's needed to adjust visible date range in Export. Set to 100 to render additional 100px\n            // worth of ticks which helps to scroll faster during export and fixes\n            // issue when scrollToDate cannot reach panel end date on exceptionally narrow view\n            scrollBuffer : 0,\n\n            /**\n             * Amount of pixels to extend the current visible range at both ends with when deciding which events to\n             * render. Only applies when using labels or for milestones\n             * @config {Number}\n             * @default\n             */\n            bufferSize : 150,\n\n            verticalBufferSize : 150\n        };\n    }\n\n    static get properties() {\n        return {\n            // Map with event DOM configs, keyed by resource id\n            resourceMap            : new Map(),\n            // Map with visible events DOM configs, keyed by row instance\n            rowMap                 : new Map(),\n            eventConfigs           : [],\n            // Flag to avoid transitioning on first refresh\n            isFirstRefresh         : true,\n            toDrawOnProjectRefresh : new Set(),\n            toDrawOnDataReady      : new Set()\n        };\n    }\n\n    construct(scheduler) {\n        const me = this;\n\n        me.client = me.scheduler = scheduler;\n\n        me.eventSorter = me.eventSorter.bind(scheduler);\n\n        // Catch scroll before renderers are called\n        scheduler.scrollable.ion({\n            scroll  : 'onEarlyScroll',\n            prio    : 1,\n            thisObj : me\n        });\n\n        scheduler.rowManager.ion({\n            name            : 'rowManager',\n            renderDone      : 'onRenderDone',\n            removeRows      : 'onRemoveRows',\n            translateRow    : 'onTranslateRow',\n            offsetRows      : 'onOffsetRows',\n            beforeRowHeight : 'onBeforeRowHeightChange',\n            thisObj         : me\n        });\n\n        super.construct({});\n    }\n\n    init() {}\n\n    updateVerticalBufferSize() {\n        const { rowManager } = this.scheduler;\n\n        if (this.scheduler.isPainted) {\n            // Refresh rows when vertical buffer size changes to trigger event repaint. Required for the export feature.\n            rowManager.renderRows(rowManager.rows);\n        }\n    }\n\n    //endregion\n\n    //region Region, dates & coordinates\n\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { scheduler } = this;\n\n        let coord = xy[0];\n\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n\n        coord = scheduler.getRtlX(coord);\n\n        return scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n\n    translateToScheduleCoordinate(x) {\n        const\n            { scheduler } = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n\n        let result = x - scheduler.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        // The vertical counterpart uses the _bodyRectangle which was created with that adjustment.\n\n        if (scheduler.rtl) {\n            result += scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result += scheduler.scrollLeft;\n        }\n\n        return result;\n    }\n\n    translateToPageCoordinate(x) {\n        const\n            { scheduler } = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n\n        let result = x + scheduler.timeAxisSubGridElement.getBoundingClientRect().left;\n\n        if (scheduler.rtl) {\n            result -= scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result -= scheduler.scrollLeft;\n        }\n\n        return result;\n    }\n\n    /**\n     * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource.\n     * This method will call getDateConstraints to allow for additional resource/event based constraints. By overriding\n     * that method you can constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] (optional) The row record\n     * @param {Scheduler.model.EventModel} [eventRecord] (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints, stretch = false) {\n        const\n            me                                   = this,\n            { scheduler }                        = me,\n            { timeAxisSubGridElement, timeAxis } = scheduler,\n            resourceMargin                       = (!stretch || resourceRecord) && scheduler.getResourceMargin(resourceRecord) || 0;\n\n        let region;\n\n        if (resourceRecord) {\n            const eventElement = eventRecord && scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];\n\n            region = Rectangle.from(scheduler.getRowById(resourceRecord.id).getElement('normal'), timeAxisSubGridElement);\n\n            if (eventElement) {\n                const eventRegion = Rectangle.from(eventElement, timeAxisSubGridElement);\n\n                region.y = eventRegion.y;\n                region.bottom = eventRegion.bottom;\n            }\n            else {\n                region.y = region.y + resourceMargin;\n                region.bottom = region.bottom - resourceMargin;\n            }\n        }\n        else {\n            // TODO: This is what the function that was removed here did.\n            // The coordinate space needs to be sorted out here!\n            region = Rectangle.from(timeAxisSubGridElement).moveTo(null, 0);\n            region.width = timeAxisSubGridElement.scrollWidth;\n\n            region.y = region.y + resourceMargin;\n            region.bottom = region.bottom - resourceMargin;\n        }\n\n        const\n            taStart         = timeAxis.startDate,\n            taEnd           = timeAxis.endDate;\n\n        dateConstraints = (dateConstraints?.start && dateConstraints) || scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n            start : taStart,\n            end   : taEnd\n        };\n\n        let startX          = scheduler.getCoordinateFromDate(dateConstraints.start ? DateHelper.max(taStart, dateConstraints.start) : taStart),\n            endX            = scheduler.getCoordinateFromDate(dateConstraints.end ? DateHelper.min(taEnd, dateConstraints.end) : taEnd);\n\n        if (!local) {\n            startX = me.translateToPageCoordinate(startX);\n            endX = me.translateToPageCoordinate(endX);\n        }\n\n        region.left = Math.min(startX, endX);\n        region.right = Math.max(startX, endX);\n\n        return region;\n    }\n\n    /**\n     * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a\n     * certain date interval.\n     * @param {Core.data.Model} rowRecord The row record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} The Rectangle which encapsulates the row\n     */\n    getRowRegion(rowRecord, startDate, endDate) {\n        const\n            { scheduler } = this,\n            { timeAxis }  = scheduler,\n            row           = scheduler.getRowById(rowRecord.id);\n\n        // might not be rendered\n        if (!row) {\n            return null;\n        }\n\n        const\n            taStart    = timeAxis.startDate,\n            taEnd      = timeAxis.endDate,\n            start      = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end        = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startX     = scheduler.getCoordinateFromDate(start),\n            endX       = scheduler.getCoordinateFromDate(end, true, true),\n            y          = row.top,\n            x          = Math.min(startX, endX),\n            bottom     = y + row.offsetHeight;\n\n        return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);\n    }\n\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside, roughly = false) {\n        const resourceData = this.resourceMap.get(resourceRecord.id);\n\n        let eventLayout  = null,\n            approx       = false;\n\n        if (resourceData) {\n            eventLayout = resourceData.eventsData.find(d => d.eventRecord === eventRecord);\n        }\n\n        // Outside of view, layout now if supposed to be included\n        if (!eventLayout) {\n            eventLayout = this.getTimeSpanRenderData(\n                eventRecord,\n                resourceRecord,\n                { viewport : true, timeAxis : includeOutside }\n            );\n\n            approx = true;\n        }\n\n        if (eventLayout) {\n            // Event layout is relative to row, need to make to absolute before returning\n            const\n                rowBox      = this.scheduler.rowManager.getRecordCoords(resourceRecord, true, roughly),\n                absoluteTop = eventLayout.top + rowBox.top,\n                box         = new Rectangle(eventLayout.left, absoluteTop, eventLayout.width, eventLayout.height);\n\n            // Flag informing other parts of the code that this box is approximated\n            box.layout = !approx;\n            box.rowTop = rowBox.top;\n            box.rowBottom = rowBox.bottom;\n\n            box.resourceId = resourceRecord.id;\n\n            return box;\n        }\n\n        return null;\n    }\n\n    //endregion\n\n    //region Element <-> Record mapping\n\n    resolveRowRecord(elementOrEvent) {\n        const\n            me             = this,\n            { scheduler }  = me,\n            element        = elementOrEvent.nodeType ? elementOrEvent : elementOrEvent.target,\n            // Fix for FF on Linux having text nodes as event.target\n            el             = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventNode      = el.closest(scheduler.eventSelector);\n\n        if (eventNode) {\n            return me.resourceStore.getById(eventNode.dataset.resourceId);\n        }\n\n        return scheduler.getRecordFromElement(el);\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        this.refreshAllWhenReady = true;\n\n        // Perform a full clear when replacing the project, to not leave any references to old project in DOM\n        if (!this.scheduler.isConfiguring) {\n            this.clearAll({ clearDom : true });\n        }\n\n        project?.ion({\n            name            : 'project',\n            refresh         : 'onProjectRefresh',\n            commitFinalized : 'onProjectCommitFinalized',\n            thisObj         : this\n        });\n    }\n\n    onProjectCommitFinalized() {\n        const { scheduler, toDrawOnDataReady, project } = this;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.refreshSuspended) {\n                // If this is a timezone commit, we got here from a store dataset\n                // We need to do a full refresh\n                if (!toDrawOnDataReady.size && project.timeZone && project.ignoreRecordChanges) {\n                    toDrawOnDataReady.add(...project.resourceStore.records.flatMap(r => r.id));\n                }\n                if (toDrawOnDataReady.size) {\n                    this.clearResources(toDrawOnDataReady);\n                    this.refreshResources(toDrawOnDataReady);\n                }\n\n                toDrawOnDataReady.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refreshRows');\n        }\n    }\n\n    onProjectRefresh({ isCalculated, isInitialCommit }) {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.isConfiguring && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset or when delayed calculations are finished)\n                if (me.refreshAllWhenReady || (isInitialCommit && isCalculated)) {\n                    scheduler.calculateAllRowHeights(true);\n                    const { rowManager } = scheduler;\n\n                    // Rows rendered? Refresh\n                    if (rowManager.topRow) {\n                        me.clearAll();\n\n                        // Refresh only if it won't be refreshed elsewhere (SchedulerStore#onProjectRefresh())\n                        if (!scheduler.refreshAfterProjectRefresh) {\n                            // If refresh was suspended when replacing the dataset in a scrolled view we might end up with a\n                            // topRow outside of available range -> reset it. Call renderRows() to mimic what normally happens\n                            // when refresh is not suspended\n                            if (rowManager.topRow.dataIndex >= scheduler.store.count) {\n                                scheduler.renderRows(false);\n                            }\n                            else {\n                                // Dont transition first refresh / early render\n                                scheduler.refreshWithTransition(false, !me.isFirstRefresh && isCalculated && !isInitialCommit);\n                            }\n                        }\n\n                        me.isFirstRefresh = false;\n                    }\n                    // No rows yet, reinitialize (happens if initial project empty and then non empty project assigned)\n                    else {\n                        rowManager.reinitialize();\n                    }\n\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refreshResources(toDrawOnProjectRefresh);\n                }\n\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n\n    //endregion\n\n    //region AssignmentStore\n\n    attachToAssignmentStore(assignmentStore) {\n        this.refreshAllWhenReady = true;\n\n        super.attachToAssignmentStore(assignmentStore);\n\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onAssignmentStoreChange({ source, action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            resourceIds       = new Set(assignmentRecords.flatMap(assignmentRecord => ([\n                assignmentRecord.resourceId,\n                // Also include any linked resources (?. twice since resource might not be resolved and point to id)\n                ...assignmentRecord.resource?.$links?.map(link => link.id) ?? []\n            ])));\n\n        // Ignore assignment changes caused by removing resources, the remove will redraw things anyway\n        // Also ignore case when resource id is changed. In this case row will be refreshed by the grid\n        if (me.resourceStore.isRemoving || me.resourceStore.isChangingId) {\n            return;\n        }\n\n        switch (action) {\n            // These operations will invalidate the graph, need to draw later\n            case 'dataset': {\n                // Ignore dataset when using single assignment mode\n                if (!me.eventStore.usesSingleAssignment) {\n                    if (resourceIds.size) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearAll();\n                        scheduler.refreshWithTransition();\n                    }\n                }\n                return;\n            }\n\n            case 'add':\n            case 'remove':\n            case 'updateMultiple': // TODO: Dont think updateMultiple is covered by any test...\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n\n            case 'removeall':\n                me.refreshAllWhenReady = true;\n                return;\n\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([oldAssignment, newAssignment]) => {\n                    resourceIds.add(oldAssignment.resourceId);\n                    resourceIds.add(newAssignment.resourceId);\n                });\n                // And refresh them\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n\n            // These operations wont invalidate the graph, redraw now\n            case 'filter':\n                me.clearAll();\n                scheduler.calculateAllRowHeights(true);\n                scheduler.refreshWithTransition();\n                return;\n\n            case 'update': {\n                if ('eventId' in changes || 'resourceId' in changes || 'id' in changes) {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // When chaining stores in single assignment mode, we might not be the project store\n                    if (source === scheduler.project.assignmentStore) {\n                        me.refreshResourcesOnDataReady(resourceIds);\n                    }\n                    // Refresh directly when we are not\n                    else {\n                        me.refreshResources(resourceIds);\n                    }\n                }\n                break;\n            }\n\n            case 'clearchanges': {\n                const { added, modified, removed } = changes;\n\n                // If modified records appear in the clearchanges action we need to refresh entire view\n                // because we have not enough information about previously assigned resource\n                if (modified) {\n                    scheduler.refreshWithTransition();\n                }\n                else {\n                    added.forEach(r => resourceIds.add(r.resourceId));\n                    removed.forEach(r => resourceIds.add(r.resourceId));\n\n                    me.refreshResourcesOnDataReady(resourceIds);\n                }\n            }\n        }\n    }\n\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.scheduler.refreshWithTransition();\n        }\n    }\n\n    //endregion\n\n    //region EventStore\n\n    attachToEventStore(eventStore) {\n        this.refreshAllWhenReady = true;\n\n        super.attachToEventStore(eventStore);\n\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            const { scheduler } = this;\n            if (scheduler.isEngineReady && scheduler.isPainted) {\n                this.clearAll();\n                scheduler.refreshWithTransition();\n            }\n        }\n    }\n\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, source }) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            isResourceTimeRange = source.isResourceTimeRangeStore,\n            resourceIds         = new Set();\n\n        if (!scheduler.isPainted) {\n            return;\n        }\n\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n\n            // When rendering a Gantt project, the project model also passes through here -> no `resources`\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n\n        if (isResourceTimeRange) {\n            switch (action) {\n                // - dataset cant pass through same path as events, which relies on project being invalidated. and\n                // resource time ranges does not pass through engine\n                // - removeall also needs special path, since no resources to redraw will be collected\n                case 'removeall':\n                case 'dataset':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n            }\n\n            me.refreshResources(resourceIds);\n        }\n        else {\n            switch (action) {\n                // No-ops\n                case 'batch': // Handled elsewhere, dont want it to clear again\n                case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n                case 'group':\n                case 'move':\n                    return;\n\n                case 'remove':\n                    // Remove is a no-op since assignment will also be removed\n                    return;\n\n                case 'clearchanges':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n\n                case 'dataset': {\n                    me.clearAll();\n                    // This is mainly for chained stores, where data is set from main store without project being\n                    // invalidated. Nothing to wait for, refresh now\n                    if (scheduler.isEngineReady) {\n                        scheduler.refreshWithTransition();\n                    }\n                    else {\n                        me.refreshAllWhenReady = true;\n                    }\n                    return;\n                }\n\n                case 'add':\n                case 'updateMultiple':\n                    // Just refresh below\n                    break;\n\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([, newEvent]) => {\n                        // Old cleared by changed assignment\n                        newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                    });\n                    break;\n\n                case 'removeall':\n                case 'filter':\n                    // Filter might be caused by add retriggering filters, in which case we need to refresh later\n                    if (!scheduler.isEngineReady) {\n                        me.refreshAllWhenReady = true;\n                        return;\n                    }\n\n                    // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                    // figure out which events was filtered out and only clear their resources.\n                    me.clearAll();\n                    scheduler.calculateAllRowHeights(true);\n                    scheduler.refreshWithTransition();\n                    return;\n\n                case 'update': {\n                    // Check if changes are graph related or not\n                    const allChrono = record.$entity\n                        ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                        : !Object.keys(changes).some(name => !chronoFields[name]);\n\n                    let dateChanges = 0;\n                    'startDate' in changes && dateChanges++;\n                    'endDate' in changes && dateChanges++;\n                    'duration' in changes && dateChanges++;\n\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // If we have a set of resources to update, refresh them.\n                    // Always redraw non chrono changes (name etc) and chrono changes that can affect appearance\n                    if (\n                        resourceIds.size && (\n                            !allChrono ||\n                            // skip case when changed \"duration\" only (w/o start/end affected)\n                            dateChanges && !('duration' in changes && dateChanges === 1) ||\n                            'percentDone' in changes ||\n                            'inactive' in changes ||\n                            'segments' in changes\n                        )\n                    ) {\n                        // if we are finalizing data loading let's delay the resources refresh till all the\n                        // propagation results get into stores\n                        if (me.project?.propagatingLoadChanges || me.project?.isWritingData) {\n                            me.refreshResourcesOnDataReady(resourceIds);\n                        }\n                        else {\n                            me.refreshResources(resourceIds);\n                        }\n                    }\n                    return;\n                }\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    attachToResourceStore(resourceStore) {\n\n        this.refreshAllWhenReady = true;\n\n        super.attachToResourceStore(resourceStore);\n\n        if (resourceStore) {\n            this.clearAll({ clearLayoutCache : true });\n\n            resourceStore.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreChange',\n                thisObj         : this\n            });\n        }\n    }\n\n    get resourceStore() {\n        return this.client.store;\n    }\n\n    onResourceStoreChange({ action, isExpand, records, changes }) {\n        const\n            me          = this,\n            // Update link + original when asked for link\n            resourceIds = records?.flatMap(r => r.isLinked ? [r.id, r.$originalId] : [r.id]);\n\n        if (!me.scheduler.isPainted) {\n            return;\n        }\n\n        switch (action) {\n            case 'add':\n                // #635 Events disappear when toggling other node\n                // If we are expanding project won't fire refresh event\n                if (!isExpand) {\n                    // Links won't cause calculations, refresh now\n                    if (records.every(r => r.isLinked)) {\n                        me.refreshResources(resourceIds);\n                    }\n                    // Otherwise refresh when project is ready\n                    else {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                }\n                return;\n            case 'update': {\n                // Ignore changes from project commit, if they affect events they will be redrawn anyway\n                // Also ignore explicit transformation of leaf <-> parent\n                if (!me.project.isBatchingChanges && !changes.isLeaf) {\n                    // Resource changes might affect events, refresh\n                    me.refreshResources(resourceIds);\n                }\n                return;\n            }\n            case 'filter':\n                // Bail out on filter action. Map was already updated on `refresh` event triggered before this `change`\n                // one. And extra records are removed from rowMap by `onRemoveRows`\n                return;\n            case 'removeall':\n                me.clearAll({ clearLayoutCache : true });\n                return;\n\n                // We must not clear all resources when whole dataset changes\n                // https://github.com/bryntum/support/issues/3292\n            case 'dataset':\n                return;\n        }\n\n        resourceIds && me.clearResources(resourceIds);\n    }\n\n    //endregion\n\n    //region RowManager\n\n    onTranslateRow({ row }) {\n        // Newly added rows are translated prior to having an id, rule those out since they will be rendered later\n        if (row.id != null) {\n            // Event layouts are stored relative to the resource, only need to rerender the row to have its absolute\n            // position updated to match new translation\n            this.refreshEventsForResource(row, false);\n        }\n    }\n\n    // RowManager error correction, cached layouts will no longer match.\n    // Redraw to have events correctly positioned for dependency feature to draw to their elements\n    onOffsetRows() {\n        this.clearAll();\n        this.doUpdateTimeView();\n    }\n\n    // Used to pre-calculate row heights\n    calculateRowHeight(resourceRecord) {\n        const\n            { scheduler } = this,\n            rowHeight     = scheduler.getResourceHeight(resourceRecord),\n            eventLayout   = scheduler.getEventLayout(resourceRecord),\n            layoutType    = eventLayout.type;\n\n        if (\n            layoutType === 'stack' &&\n            scheduler.isEngineReady &&\n            !resourceRecord.isSpecialRow &&\n            // Generated parents when TreeGrouping do not have assigned bucket\n            resourceRecord.assigned?.size > 1\n        ) {\n            const\n                {\n                    assignmentStore,\n                    eventStore,\n                    timeAxis\n                }               = scheduler,\n                {\n                    barMargin,\n                    resourceMargin,\n                    contentHeight\n                }               = scheduler.getResourceLayoutSettings(resourceRecord),\n                // When using an AssignmentStore we will get all events for the resource even if the EventStore is\n                // filtered\n                eventFilter     = (eventStore.isFiltered || assignmentStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a))),\n                events          = eventStore\n                    .getEvents({\n                        resourceRecord,\n                        includeOccurrences : scheduler.enableRecurringEvents,\n                        startDate          : timeAxis.startDate,\n                        endDate            : timeAxis.endDate,\n                        filter             : eventFilter\n                    })\n                    .sort(heightEventSorter)\n                    .map(eventRecord => {\n                        const\n                            // Must use Model.get in order to get latest values in case we are inside a batch.\n                            // EventResize changes the endDate using batching to enable a tentative change\n                            // via the batchedUpdate event which is triggered when changing a field in a batch.\n                            // Fall back to accessor if propagation has not populated date fields.\n                            startDate = eventRecord.isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n                            endDate   = eventRecord.isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate || startDate;\n\n                        return {\n                            eventRecord,\n                            resourceRecord,\n                            startMS : startDate.getTime(),\n                            endMS   : endDate.getTime()\n                        };\n                    }),\n                layoutHandler = scheduler.getEventLayoutHandler(eventLayout),\n                nbrOfBandsRequired = layoutHandler.layoutEventsInBands(events, true);\n\n            if (layoutHandler.type === 'layoutFn') {\n                return nbrOfBandsRequired;\n            }\n\n            return (nbrOfBandsRequired * contentHeight) + ((nbrOfBandsRequired - 1) * barMargin) + resourceMargin * 2;\n        }\n\n        return rowHeight;\n    }\n\n    //endregion\n\n    //region TimeAxis\n\n    doUpdateTimeView() {\n        const { scrollable } = this.scheduler.timeAxisSubGrid;\n\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX i always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x);\n    }\n\n    onTimeAxisViewModelUpdate() {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        me.clearAll();\n\n        // If refresh is suspended, update timeView as soon as refresh gets unsuspended\n        if (scheduler.refreshSuspended) {\n            me.detachListeners('renderingSuspend');\n\n            scheduler.ion({\n                name : 'renderingSuspend',\n                resumeRefresh({ trigger }) {\n                    // This code will try to refresh rows, but resumeRefresh event doesn't guarantee rowManager rows are\n                    // in actual state. e.g. if resources were removed during a suspended refresh rowManager won't get a\n                    // chance to update them until `refresh` event from the project. We can safely update the view only\n                    // if engine in ready (not committing), otherwise we leave refresh a liability of normal project refresh\n                    // logic. Covered by SchedulerRendering.t.js\n                    // https://github.com/bryntum/support/issues/1462\n                    if (scheduler.isEngineReady && trigger) {\n                        me.doUpdateTimeView();\n                    }\n                },\n                thisObj : me,\n                once    : true\n            });\n        }\n\n        // Call update anyway. If refresh is suspended this call will only update visible date range and will not redraw rows\n        me.doUpdateTimeView();\n    }\n\n    //endregion\n\n    //region Dependency connectors\n\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'start';\n    }\n\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'end';\n    }\n\n    //endregion\n\n    //region Scheduler hooks\n\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n        }\n    }\n\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n\n    // Called when viewport size changes\n    onViewportResize(width, height, oldWidth, oldHeight) {\n        // We dont draw events for all rendered rows, \"refresh\" when height changes to make sure events in previously\n        // invisible rows gets displayed\n        if (height > oldHeight) {\n            this.onRenderDone();\n        }\n    }\n\n    // Called from EventDrag\n    onDragAbort({ context, dragData }) {\n        // Aborted a drag in a scrolled scheduler, with origin now out of view. Element is no longer needed\n        if (this.resourceStore.indexOf(dragData.record.resource) < this.scheduler.topRow.dataIndex) {\n            context.element.remove();\n        }\n    }\n\n    // Called from EventSelection\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const\n            element      = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper),\n            // TODO: Should be assignmentRecord.resourceId, but breaks engine. Hoping https://github.com/bryntum/bryntum-suite/pull/1252 will fix it\n            resourceData = this.resourceMap.get(assignmentRecord.isModel ? assignmentRecord.get('resourceId') : assignmentRecord.resourceId),\n            eventData    = resourceData?.eventsData.find(d => d.eventId === assignmentRecord.eventId);\n\n        // Update cached config\n        if (eventData) {\n            eventData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n        }\n\n        // Live update element\n        if (element) {\n            // Update element\n            element.classList[add ? 'add' : 'remove'](cls);\n            // And its DOM config\n            element.lastDomConfig.className[cls] = add;\n        }\n    }\n\n    // React to rows being removed, refreshes view without any relayouting needed since layout is cached relative to row\n    onRemoveRows({ rows }) {\n        rows.forEach(row => this.rowMap.delete(row));\n        this.onRenderDone();\n    }\n\n    // Reset renderer flag before any renderers are called\n    onEarlyScroll() {\n        this.rendererCalled = false;\n    }\n\n    // If vertical scroll did not cause a renderer to be called we still want to update since we only draw events in\n    // view, \"independent\" from their rows\n    updateFromVerticalScroll() {\n        this.fromScroll = true;\n        if (!this.rendererCalled) {\n            this.onRenderDone();\n        }\n    }\n\n    // Update header range on horizontal scroll. No need to draw any tasks, Gantt only cares about vertical scroll\n    updateFromHorizontalScroll(scrollX) {\n        const\n            me            = this,\n            {\n                scheduler,\n                // scrollBuffer is an export only thing\n                scrollBuffer\n            } = me,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = scheduler,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = scheduler.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = scheduler.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd ? timeAxis.endDate : (scheduler.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n\n        if (startDate && !scheduler._viewPresetChanging) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords  = rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n\n            // Update timeaxis header making it display the new dates\n            const range = scheduler.timeView.range = { startDate, endDate };\n\n            scheduler.onVisibleDateRangeChange(range);\n\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!scheduler.refreshSuspended && scheduler.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (scheduler.rowManager.rows[0].id === null) {\n                    return;\n                }\n\n                me.fromScroll = true;\n                scheduler.rowManager.rows.forEach(row => me.refreshEventsForResource(row, false, false));\n\n                me.onRenderDone();\n            }\n        }\n    }\n\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.refreshResources([resourceRecord.id]);\n    }\n\n    onBeforeRowHeightChange() {\n        // Row height is cached per resource, all have to be re-laid out\n        this.clearAll();\n    }\n\n    //endregion\n\n    //region Refresh resources\n\n    refreshResourcesOnDataReady(resourceIds) {\n        resourceIds.forEach(id => this.toDrawOnDataReady.add(id));\n    }\n\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n\n    /**\n     * Clears and redraws resources directly. Respects schedulers refresh suspension\n     * @param {Number[]|String[]} ids Resource ids\n     * @param {Boolean} [transition] Use transition or not\n     * @private\n     */\n    refreshResources(ids, transition = true) {\n        const\n            me            = this,\n            { scheduler } = me,\n            rows          = [],\n            noRows        = [];\n\n        me.clearResources(ids);\n\n        if (!scheduler.refreshSuspended) {\n            ids.forEach(id => {\n                const row = scheduler.getRowById(id);\n                if (row) {\n                    rows.push(row);\n                }\n                else {\n                    noRows.push(row);\n                }\n            });\n\n            scheduler.runWithTransition(() => {\n                // Rendering rows populates row heights, but not all resources might have a row in view\n                scheduler.calculateRowHeights(noRows.map(id => this.resourceStore.getById(id)), true);\n\n                // Render those that do\n                scheduler.rowManager.renderRows(rows);\n            }, transition);\n        }\n    }\n\n    //endregion\n\n    //region Stack & pack\n\n    layoutEventVerticallyStack(bandIndex, eventRecord, resourceRecord) {\n        const { barMargin, resourceMargin, contentHeight } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent);\n\n        return bandIndex === 0\n            ? resourceMargin\n            : resourceMargin + bandIndex * contentHeight + bandIndex * barMargin;\n    }\n\n    layoutEventVerticallyPack(topFraction, heightFraction, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMargin,\n                contentHeight\n            }               = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent),\n            count           = 1 / heightFraction,\n            bandIndex       = topFraction * count, // \"y\" within row\n            height          = (contentHeight - ((count - 1) * barMargin)) * heightFraction,\n            top             = resourceMargin + bandIndex * height + bandIndex * barMargin;\n\n        return {\n            top, height\n        };\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord, resourceRecord = eventRecord.resource) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(eventRecord, resourceRecord, { timeAxis : true, viewport : true });\n\n        renderData.absoluteTop = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, resourceRecord, true).top;\n\n        const\n            domConfig = this.renderEvent(renderData),\n            { dataset } = domConfig;\n\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent = this.scheduler.foregroundCanvas;\n\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n\n        const result = DomHelper.createElement(domConfig);\n\n        result.innerElement = result.firstChild;\n\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n\n        return result;\n    }\n\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    // Fn can be called with layout date or event records (from EventNavigation)\n    eventSorter(a, b) {\n        if (this.overlappingEventSorter) {\n            return this.overlappingEventSorter(a.eventRecord || a, b.eventRecord || b);\n        }\n\n        const\n            // TODO: Rename startMS -> startDateMS to not have to have isModel check here (and to be consistent)\n            startA    = a.isModel ? a.startDateMS : a.dataStartMS || a.startMS, // dataXX are used if configured with fillTicks\n            endA      = a.isModel ? a.endDateMS : a.dataEndMS || a.endMS,\n            startB    = b.isModel ? b.startDateMS : b.dataStartMS || b.startMS,\n            endB      = b.isModel ? b.endDateMS :  b.dataEndMS || b.endMS,\n            nameA     = a.isModel ? a.name : a.eventRecord.name,\n            nameB     = b.isModel ? b.name : b.eventRecord.name;\n\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n\n    /**\n     * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with\n     * `fillTicks: true` the value returned will be snapped to tick start/end.\n     * @private\n     * @param {Scheduler.model.TimeSpan} eventRecord\n     * @param {String} startDateField\n     * @param {String} endDateField\n     * @param {Boolean} useEventBuffer\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Object} Object of format { startMS, endMS, durationMS }\n     */\n    calculateMS(eventRecord, startDateField, endDateField, useEventBuffer, resourceRecord) {\n        const\n            me                    = this,\n            { scheduler }         = me,\n            { timeAxisViewModel } = scheduler;\n\n        let startMS    = getStartEnd(scheduler, eventRecord, false, startDateField, useEventBuffer),\n            endMS      = getStartEnd(scheduler, eventRecord, true, endDateField, useEventBuffer),\n            durationMS = endMS - startMS;\n\n        if (scheduler.milestoneLayoutMode !== 'default' && durationMS === 0) {\n            const\n                pxPerMinute = timeAxisViewModel.getSingleUnitInPixels('minute'),\n                lengthInPx  = scheduler.getMilestoneLabelWidth(eventRecord, resourceRecord),\n                duration    = lengthInPx * (1 / pxPerMinute);\n\n            durationMS = duration * 60 * 1000;\n\n            if (scheduler.milestoneTextPosition === 'always-outside') {\n                // Milestone is offset half a diamond to the left (compensated in CSS with padding) for the layout pass,\n                // to take diamond corner into account\n                const\n                    diamondSize = scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent).contentHeight,\n                    diamondMS   = diamondSize * (1 / pxPerMinute) * 60 * 1000;\n                startMS -= diamondMS / 2;\n                endMS = startMS + durationMS;\n            }\n            else {\n                switch (scheduler.milestoneAlign) {\n                    case 'start':\n                    case 'left':\n                        endMS = startMS + durationMS;\n                        break;\n                    case 'end':\n                    case 'right':\n                        endMS = startMS;\n                        startMS = endMS - durationMS;\n                        break;\n                    default: // using center as default\n                        endMS = startMS + durationMS / 2;\n                        startMS = endMS - durationMS;\n                        break;\n                }\n            }\n        }\n\n        return {\n            startMS,\n            endMS,\n            durationMS\n        };\n    }\n\n    /**\n     * Returns event render data except actual position information.\n     * @param timeSpan\n     * @param rowRecord\n     * @returns {HorizontalRenderData}\n     * @private\n     */\n    setupRenderData(timeSpan, rowRecord) {\n        const\n            me                             = this,\n            { scheduler }                  = me,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }                              = scheduler,\n            {\n                preamble,\n                postamble\n            }                              = timeSpan,\n            useEventBuffer                 = me.isProHorizontalRendering && scheduler.features.eventBuffer?.enabled &&\n                (preamble || postamble) && !timeSpan.isMilestone,\n            pxPerMinute                    = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            { isBatchUpdating }            = timeSpan,\n            startDateField                 = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField                   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            // Use endDate accessor if duration has not been propagated to create endDate\n            timespanStart                  = isBatchUpdating && !useEventBuffer ? timeSpan.get(startDateField) : timeSpan[startDateField],\n            // Allow timespans to be rendered even when they are missing an end date\n            timespanEnd                    = isBatchUpdating && !useEventBuffer ? timeSpan.get(endDateField) : timeSpan[endDateField] || timespanStart,\n            viewStartMS                    = timeAxis.startMS,\n            viewEndMS                      = timeAxis.endMS,\n            { startMS, endMS, durationMS } = me.calculateMS(timeSpan, startDateField, endDateField, useEventBuffer, rowRecord),\n            // These flags have two components because includeOutsideViewport\n            // means that we can be calculating data for events either side of\n            // the TimeAxis.\n            // The start is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the start is before the TimeAxis\n            // 2 set means the start is after the TimeAxis\n            // Either way, a truthy value means that the start is outside of the TimeAxis.\n            startsOutsideView              = startMS < viewStartMS | ((startMS > viewEndMS) << 1),\n            // The end is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the end is after the TimeAxis\n            // 2 set means the end is before the TimeAxis\n            // Either way, a truthy value means that the end is outside of the TimeAxis.\n            endsOutsideView                = endMS > viewEndMS | ((endMS <= viewStartMS) << 1),\n            durationMinutes                = durationMS / (1000 * 60),\n            width                          = endsOutsideView ? pxPerMinute * durationMinutes : null,\n            row                            = scheduler.getRowById(rowRecord);\n\n        return {\n            eventRecord : timeSpan,\n            taskRecord  : timeSpan, // Helps with using Gantt projects in Scheduler Pro\n            start       : timespanStart,\n            end         : timespanEnd,\n            rowId       : rowRecord.id,\n            children    : [],\n            startMS,\n            endMS,\n            durationMS,\n            startsOutsideView,\n            endsOutsideView,\n            width,\n            row,\n            useEventBuffer\n        };\n    }\n\n    /**\n     * Populates render data with information about width and horizontal position of the wrap.\n     * @param {HorizontalRenderData} renderData\n     * @returns {Boolean}\n     * @private\n     */\n    fillTimeSpanHorizontalPosition(renderData) {\n        const\n            { startMS, endMS, durationMS } = renderData,\n            // With delayed calculation there is no guarantee data is normalized, might be missing a crucial component\n            result = startMS != null && endMS != null && this.calculateHorizontalPosition(renderData, startMS, endMS, durationMS);\n\n        if (result) {\n            Object.assign(renderData, result);\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Fills render data with `left` and `width` properties\n     * @param {HorizontalRenderData} renderData\n     * @param {Number} startMS\n     * @param {Number} endMS\n     * @param {Number} durationMS\n     * @returns {{left: number, width: number, clippedStart: boolean, clippedEnd: boolean}|null}\n     * @private\n     */\n    calculateHorizontalPosition(renderData, startMS, endMS, durationMS) {\n        const\n            { scheduler }   = this,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }               = scheduler,\n            {\n                startsOutsideView,\n                endsOutsideView,\n                eventRecord\n            }               = renderData,\n            viewStartMS     = timeAxis.startMS,\n            pxPerMinute     = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            durationMinutes = durationMS / (1000 * 60),\n            width           = endsOutsideView ? pxPerMinute * durationMinutes : null;\n\n        let endX = scheduler.getCoordinateFromDate(endMS, {\n                local            : true,\n                respectExclusion : true,\n                isEnd            : true\n            }), startX, clippedStart = false, clippedEnd = false;\n\n        // If event starts outside of view, estimate where.\n        if (startsOutsideView) {\n            startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;\n\n            // Flip -ve startX to being to the right of the viewport end\n            if (scheduler.rtl) {\n                startX = scheduler.timeAxisSubGrid.scrollable.scrollWidth - startX;\n            }\n        }\n        // Starts in view, calculate exactly\n        else {\n            // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : endX !== -1\n            });\n\n            clippedStart = startX === -1;\n        }\n\n        if (endsOutsideView) {\n            // Have to clip the events in Safari when using stickyEvents, it does not support `overflow: clip`\n            if (BrowserHelper.isSafari && scheduler.features.stickyEvents) {\n                endX = scheduler.getCoordinateFromDate(timeAxis.endMS);\n            }\n            else {\n                // Parentheses needed\n                endX = startX + width * (scheduler.rtl ? -1 : 1);\n            }\n        }\n        else {\n            clippedEnd = endX === -1;\n        }\n\n        if (clippedEnd && !clippedStart) {\n            // We know where to start but not where to end, snap it (the opposite is already handled by the\n            // snapToNextIncluded flag when calculating startX above)\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true\n            });\n        }\n\n        // If the element is very wide there's no point in displaying it all.\n        // Indeed the element may not be displayable at extremely large widths.\n        if (width > MAX_WIDTH) {\n            // The start is before the TimeAxis start\n            if (startsOutsideView === 1) {\n                // Both ends outside - spans TimeAxis\n                if (endsOutsideView === 1) {\n                    startX = -100;\n                    endX = scheduler.timeAxisColumn.width + 100;\n                }\n                // End is in view\n                else {\n                    startX = endX - MAX_WIDTH;\n                }\n            }\n            // The end is after, but the start is in view\n            else if (endsOutsideView === 1) {\n                endX = startX + MAX_WIDTH;\n            }\n        }\n\n        if (clippedStart && clippedEnd) {\n            // Both ends excluded, but there might be some part in between that should be displayed...\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : true,\n                max                : endMS\n            });\n\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true,\n                min                : startMS\n            });\n\n            if (startX === endX) {\n                // Raise flag on instance meta to avoid duplicating this logic\n                eventRecord.instanceMeta(scheduler).excluded = true;\n                // Excluded by time axis exclusion rules, render nothing\n                return null;\n            }\n        }\n\n        return {\n            left  : Math.min(startX, endX),\n            // Use min width 5 for normal events, 0 for milestones (wont have width specified at all in the\n            // end). During drag create a normal event can get 0 duration, in this case we still want it to\n            // get a min width of 5 (6px for wrapper, -1 px for event element\n            width : Math.abs(endX - startX) || (eventRecord.isMilestone && !eventRecord.meta.isDragCreating ? 0 : 6),\n            clippedStart,\n            clippedEnd\n        };\n    }\n\n    fillTimeSpanVerticalPosition(renderData, rowRecord) {\n        const\n            { scheduler }  = this,\n            { start, end } = renderData,\n            {\n                resourceMargin,\n                contentHeight\n            }              = scheduler.getResourceLayoutSettings(rowRecord);\n\n        // If filling ticks we need to also keep data's MS values, since they are used for sorting timespans\n        if (scheduler.fillTicks) {\n            renderData.dataStartMS = start.getTime();\n            renderData.dataEndMS = end.getTime();\n        }\n\n        renderData.top = Math.max(0, resourceMargin);\n\n        if (scheduler.managedEventSizing) {\n            // Timespan height should be at least 1px\n            renderData.height = contentHeight;\n        }\n    }\n\n    /**\n     * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in\n     * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans\n     * are rendered, then `undefined` is returned.\n     * @private\n     * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record\n     * @param {Core.data.Model} rowRecord Row record\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.\n     * @returns {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMS: number, endMS: number, startsOutsideView: boolean, endsOutsideView: boolean}}\n     */\n    getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {\n        const\n            me                     = this,\n            { scheduler }          = me,\n            { timeAxis }           = scheduler,\n            includeOutsideTimeAxis = includeOutside === true || includeOutside.timeAxis,\n            includeOutsideViewport = includeOutside === true || includeOutside.viewport;\n\n        // If timespan is outside the TimeAxis, give up trying to calculate a layout (Unless we're including timespans\n        // outside our zone)\n        if (includeOutsideTimeAxis || timeAxis.isTimeSpanInAxis(timeSpan)) {\n            const row = scheduler.getRowById(rowRecord);\n\n            if (row || includeOutsideViewport) {\n                const data = me.setupRenderData(timeSpan, rowRecord);\n\n                if (!me.fillTimeSpanHorizontalPosition(data)) {\n                    return null;\n                }\n\n                me.fillTimeSpanVerticalPosition(data, rowRecord);\n\n                return data;\n            }\n        }\n    }\n\n    // Layout a set of events, code shared by normal event render path and nested events\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me                   = this,\n            { scheduler }        = me,\n            { timeAxis }         = scheduler,\n            // Generate layout data\n            eventsData           = allEvents.reduce((result, eventRecord) => {\n                // Only those in time axis (by default)\n                if ((includeOutside || timeAxis.isTimeSpanInAxis(eventRecord))) {\n                    const eventBox = scheduler.generateRenderData(eventRecord, resourceRecord, false);\n\n                    // Collect layouts of visible events\n                    if (eventBox) {\n                        result.push(eventBox);\n                    }\n                }\n\n                return result;\n            }, []);\n\n        // Ensure the events are rendered in natural order so that navigation works.\n        eventsData.sort(eventSorter ?? me.eventSorter);\n\n        let rowHeight = scheduler.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n\n        const\n            // Only events and tasks should be considered during layout (not resource time ranges if any, or events\n            // being drag created when configured with lockLayout)\n            layoutEventData = eventsData.filter(({ eventRecord }) => eventRecord.isEvent && !eventRecord.meta.excludeFromLayout),\n            eventLayout     = scheduler.getEventLayout(resourceRecord, parentEventRecord),\n            layoutHandler   = scheduler.getEventLayoutHandler(eventLayout);\n\n        if (layoutHandler) {\n            const\n                {\n                    barMargin,\n                    resourceMargin,\n                    contentHeight\n                }              = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord),\n                bandsRequired  = layoutHandler.applyLayout(layoutEventData, resourceRecord) || 1;\n\n            if (layoutHandler.type === 'layoutFn') {\n                rowHeight = bandsRequired;\n            }\n            else {\n                rowHeight = (bandsRequired * contentHeight) + ((bandsRequired - 1) * barMargin) + resourceMargin * 2;\n            }\n        }\n        // Apply z-index when event elements might overlap, to keep \"overlap order\" consistent\n        else if (layoutEventData.length > 0) {\n            for (let i = 0; i < layoutEventData.length; i++) {\n                const data = layoutEventData[i];\n                // $event-zindex scss var is 5\n                data.wrapperStyle += `;z-index:${i + 5}`;\n            }\n        }\n\n        return { rowHeight, eventsData };\n    }\n\n    // Lay out events within a resource, relative to the resource\n    layoutResourceEvents(resourceRecord, includeOutside = false) {\n        const\n            me                   = this,\n            { scheduler }        = me,\n            {\n                eventStore,\n                assignmentStore,\n                timeAxis\n            }                    = scheduler,\n            // Events for this resource\n            resourceEvents = eventStore.getEvents({\n                includeOccurrences : scheduler.enableRecurringEvents,\n                resourceRecord,\n                startDate          : timeAxis.startDate,\n                endDate            : timeAxis.endDate,\n                filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a)))\n            }),\n            // Call a chainable template function on scheduler to allow features to add additional \"events\" to render\n            // Currently used by ResourceTimeRanges, CalendarHighlight & NestedEvents\n            allEvents            = scheduler.getEventsToRender(resourceRecord, resourceEvents) || [];\n\n        return me.layoutEvents(resourceRecord, allEvents, includeOutside);\n    }\n\n    // Generates a DOMConfig for an EventRecord\n    renderEvent(data, rowHeight) {\n        const\n            { scheduler }                                     = this,\n            { resourceRecord, assignmentRecord, eventRecord } = data,\n            {\n                milestoneLayoutMode    : layoutMode,\n                milestoneTextPosition  : textPosition\n            }    = scheduler,\n            // Sync using assignment id for events and event id for ResourceTimeRanges. Add eventId for occurrences to make them unique\n            syncId                                            = assignmentRecord\n                // Assignment, might be an occurrence\n                ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id\n                // Something else, probably a ResourceTimeRange\n                : data.eventId,\n            eventElementConfig = {\n                className : data.cls,\n                style     : data.style || '',\n                children  : data.children,\n                role      : 'presentation',\n                dataset   : {\n                    // Each feature putting contents in the event wrap should have this to simplify syncing and\n                    // element retrieval after sync\n                    taskFeature : 'event'\n                },\n                syncOptions : {\n                    syncIdField : 'taskBarFeature'\n                }\n            },\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig                        = {\n                className : data.wrapperCls,\n                tabIndex  : ('tabIndex' in data) ? data.tabIndex : -1,\n                children  : [\n                    eventElementConfig,\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top    : data.absoluteTop,\n                    left   : data.left,\n                    // ResourceTimeRanges fill row height, cannot be done earlier than this since row height is not\n                    // known initially\n                    height : data.fillSize ? rowHeight : data.height,\n                    // DomHelper appends px to dimensions when using numbers.\n                    // Do not ignore width for normal milestones, use height value. It is required to properly center\n                    // pseudo element with top/bottom labels.\n                    // Milestone part of layout that contain the label gets a width\n                    width  : (eventRecord.isMilestone && !eventRecord.meta.isDragCreating) &&\n                             ((layoutMode === 'default' && (textPosition === 'outside' || (textPosition === 'inside' && !data.width))) ||\n                                 textPosition === 'always-outside') ? data.height : data.width,\n                    style    : data.wrapperStyle,\n                    fontSize : data.height + 'px'\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    syncId     : resourceRecord.isLinked ? `${syncId}_${resourceRecord.id}` : syncId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : data,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : assignmentRecord?.instanceMeta(scheduler).retainElement || eventRecord.instanceMeta(scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n\n        // Write back the correct height for elements filling the row, to not derender them later based on wrong height\n        if (data.fillSize) {\n            data.height = rowHeight;\n        }\n\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n\n        data.elementConfig = elementConfig;\n\n        return elementConfig;\n    }\n\n    /**\n     * Refresh events for resource record (or Row), clearing its cache and forcing DOM refresh.\n     * @param {Scheduler.model.ResourceModel} recordOrRow Record or row to refresh\n     * @param {Boolean} [force] Specify `false` to prevent clearing cache and forcing DOM refresh\n     * @internal\n     */\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        const\n            me     = this,\n            record = me.scheduler.store.getById(recordOrRow.isRow ? recordOrRow.id : recordOrRow),\n            row    = me.scheduler.rowManager.getRowFor(record);\n\n        if (force) {\n            me.clearResources([record]);\n        }\n\n        if (row && record) {\n            me.renderer({ row, record });\n\n            if (force && draw) {\n                me.onRenderDone();\n            }\n        }\n    }\n\n    // Returns layout for the current resource. Used by the renderer and exporter\n    getResourceLayout(resourceRecord) {\n        const me = this;\n\n        // Use cached layout if available\n        let resourceLayout = me.resourceMap.get(resourceRecord.id);\n\n        if (!resourceLayout || resourceLayout.invalid) {\n            // Previously we would bail out here if engine wasn't ready. Now we instead allow drawing in most cases,\n            // since data can be read and written during commit (previously it could not)\n            if (me.suspended) {\n                return;\n            }\n\n            resourceLayout = me.layoutResourceEvents(resourceRecord, false);\n            me.resourceMap.set(resourceRecord.id, resourceLayout);\n        }\n\n        return resourceLayout;\n    }\n\n    getEventDOMConfigForCurrentView(resourceLayout, row, left, right) {\n        const\n            me                        = this,\n            { bufferSize, scheduler } = me,\n            { labels, eventBuffer }   = scheduler.features,\n            // Left/right labels and event buffer elements require using a buffer to not derender too early\n            usesLabels                = eventBuffer?.enabled || (labels?.enabled && (labels.left || labels.right || labels.before || labels.after)),\n            { eventsData }            = resourceLayout,\n            // When scrolling, layout will be reused and any events that are still in view can reuse their DOM configs\n            reusableDOMConfigs        = me.fromScroll ? me.rowMap.get(row) : null,\n            eventDOMConfigs           = [];\n\n        let useLeft, useRight;\n\n        // Only collect configs for those actually in view\n        for (let i = 0; i < eventsData.length; i++) {\n            const layout = eventsData[i];\n\n            useLeft = left;\n            useRight = right;\n\n            // Labels/milestones requires keeping events rendered longer\n            if (usesLabels || layout.width === 0) {\n                useLeft -= bufferSize;\n                useRight += bufferSize;\n            }\n\n            if ((layout.left + layout.width) >= useLeft && layout.left <= useRight) {\n                layout.absoluteTop = layout.top + row.top;\n                // TODO: Consider using a map of maps instead of having to find() here. But it is anyhow much faster\n                //  than not reusing dom configs\n                const prevDomConfig = reusableDOMConfigs?.find(config => config.elementData.eventId === layout.eventId);\n                eventDOMConfigs.push(prevDomConfig ?? me.renderEvent(layout, resourceLayout.rowHeight));\n            }\n        }\n\n        return eventDOMConfigs;\n    }\n\n    // Called per row in \"view\", collect configs\n    renderer({ row, record : resourceRecord, size = {} }) {\n        const me = this;\n\n        // Bail out for group headers/footers\n        if (resourceRecord.isSpecialRow) {\n            // Clear any cached layout for row retooled to special row, and bail out\n            me.rowMap.delete(row);\n            return;\n        }\n\n        const\n            { left, right } = me.viewportCoords,\n            resourceLayout  = me.getResourceLayout(resourceRecord);\n\n        // Layout is suspended\n        if (!resourceLayout) {\n            return;\n        }\n\n        // Size row to fit events\n        size.height = resourceLayout.rowHeight;\n        // Avoid storing our calculated height as the rows max height, to not affect next round of calculations\n        size.transient = true;\n\n        const eventDOMConfigs = me.getEventDOMConfigForCurrentView(resourceLayout, row, left, right);\n\n        me.rowMap.set(row, eventDOMConfigs);\n\n        // Keep track if we need to draw on vertical scroll or not, to not get multiple onRenderDone() calls\n        me.rendererCalled = true;\n    }\n\n    // Called when the current row rendering \"pass\" is complete, sync collected configs to DOM\n    onRenderDone() {\n        const\n            { scheduler, rowMap, verticalBufferSize }  = this,\n            visibleEventDOMConfigs                     = [],\n            bodyTop                                    = scheduler._scrollTop ?? 0,\n            viewTop                                    = bodyTop - verticalBufferSize,\n            viewBottom                                 = bodyTop + scheduler._bodyRectangle.height + verticalBufferSize,\n            unbuffered                                 = verticalBufferSize < 0,\n            unmanagedSize                              = !scheduler.managedEventSizing;\n\n        // Event configs are collected when rows are rendered, but we do not want to waste resources on rendering\n        // events far out of view. Especially with many events per row giving large row heights, rows in the RowManagers\n        // buffer might far away -> collect events for rows within viewport + small vertical buffer\n        rowMap.forEach((eventDOMConfigs, row) => {\n            // Render events \"in view\". Export specifies a negative verticalBufferSize to disable it\n            if (unbuffered || (row.bottom > viewTop && row.top < viewBottom)) {\n                for (let i = 0; i < eventDOMConfigs.length; i++) {\n                    const\n                        config = eventDOMConfigs[i],\n                        data   = config.elementData,\n                        {\n                            absoluteTop,\n                            eventRecord\n                        } = data;\n\n                    // Conditions under which event bars are included in the DOM:\n                    //   If bufferSize is -ve, meaning render all events.\n                    //   scheduler.managedEventSizing is false.\n                    //   The event is beig drag-created or drag-resized\n                    //   The event is within the bounds of the rendered region.\n                    if (unbuffered || unmanagedSize || eventRecord.meta.isDragCreating || eventRecord.meta.isResizing || (absoluteTop + data.height > viewTop && absoluteTop < viewBottom)) {\n                        visibleEventDOMConfigs.push(config);\n                    }\n                }\n            }\n\n            // We are using cached DomConfigs. When DomSync releases an element, it also flags the config as released.\n            // Next time we pass it that very same config, it says it is released and nothing shows up.\n            //\n            // We are breaching the DomSync contract a bit with the cached approach. DomSync expects new configs on each\n            // call, so to facilitate that we clone the configs shallowly (nothing deep is affected by sync releasing).\n            // That way we can always pass it fresh unreleased configs.\n            for (let i = 0; i < eventDOMConfigs.length; i++) {\n                eventDOMConfigs[i] = { ...eventDOMConfigs[i] };\n            }\n        });\n\n        this.fromScroll = false;\n        this.visibleEventDOMConfigs = visibleEventDOMConfigs;\n\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : visibleEventDOMConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n\n            // Called by DomSync when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const { reactComponent } = scheduler;\n                const\n                    // Some actions are considered first a release and then a render (reusing another element).\n                    // This gives clients code a chance to clean up before reusing an element\n                    isRelease = releaseEventActions[action],\n                    isRender  = renderEventActions[action];\n\n                if (!isRelease && scheduler.processEventContent?.({\n                    jsx,\n                    action,\n                    domConfig,\n                    targetElement,\n                    isRelease,\n                    reactComponent\n                })) return;\n\n                if (action === 'none' || !domConfig?.elementData?.isWrap) {\n                    return;\n                }\n\n                // Trigger release for events (it might be a proxy element, skip those)\n                if (isRelease && lastDomConfig?.elementData) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = lastDomConfig.elementData,\n                        event = {\n                            renderData : lastDomConfig.elementData,\n                            element    : targetElement,\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n\n                    // Process event necessary in the case of release\n                    scheduler.processEventContent?.({\n                        isRelease,\n                        targetElement,\n                        reactComponent,\n                        assignmentRecord\n                    });\n\n                    // Some browsers do not blur on set to display:none, so releasing the active element\n                    // must *explicitly* move focus outwards to the view.\n                    if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                        scheduler.focusElement.focus();\n                    }\n\n                    // This event is documented on Scheduler\n                    scheduler.trigger('releaseEvent', event);\n                }\n\n                if (isRender) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = domConfig.elementData,\n                        event = {\n                            renderData       : domConfig.elementData,\n                            element          : targetElement,\n                            isReusingElement : action === 'reuseElement',\n                            isRepaint        : action === 'reuseOwnElement',\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n\n                    // This event is documented on Scheduler\n                    scheduler.trigger('renderEvent', event);\n                }\n            }\n        });\n    }\n\n    //endregion\n\n    //region Cache\n\n    // Clears cached resource layout\n    clearResources(recordsOrIds) {\n        recordsOrIds = ArrayHelper.asArray(recordsOrIds);\n\n        const resourceIds = recordsOrIds.map(Model.asId);\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            console.log('%Clearing resources ' + Array.from(resourceIds).join(','), 'color: #770000');\n        }\n        //</debug>\n\n        resourceIds.forEach(resourceId => {\n            // Invalidate resourceLayout, keeping it around in case we need it before next refresh\n            const cached = this.resourceMap.get(resourceId);\n            if (cached) {\n                cached.invalid = true;\n            }\n\n            const row = this.scheduler.getRowById(resourceId);\n            row && this.rowMap.delete(row);\n        });\n    }\n\n    clearAll({ clearDom = false, clearLayoutCache = false } = {}) {\n        const\n            me                            = this,\n            { layouts, foregroundCanvas } = me.scheduler;\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            console.log('%Clearing all', 'color: #770000');\n        }\n        //</debug>\n\n        if (clearLayoutCache && layouts) {\n            for (const layout in layouts) {\n                layouts[layout].clearCache();\n            }\n        }\n\n        // it seems `foregroundCanvas` can be missing at this point\n        // for example if scheduler instance is created w/o of `appendTo` config\n        if (foregroundCanvas && clearDom) {\n            // Start from scratch when replacing the project, to not retain anything in maps or released elements\n            foregroundCanvas.syncIdMap = foregroundCanvas.lastDomConfig = null;\n\n            for (const child of foregroundCanvas.children) {\n                child.lastDomConfig = child.elementData = null;\n            }\n        }\n\n        me.resourceMap.clear();\n        me.rowMap.clear();\n    }\n\n    //endregion\n}\n","import PackMixin from './PackMixin.js';\n\n/**\n * @module Scheduler/eventlayout/VerticalLayout\n */\n\n/**\n * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`\n * @private\n * @mixes Scheduler/eventlayout/PackMixin\n */\nexport default class VerticalLayout extends PackMixin() {\n\n    static get defaultConfig() {\n        return {\n            coordProp : 'leftFactor',\n            sizeProp  : 'widthFactor'\n        };\n    }\n\n    // Try to pack the events to consume as little space as possible\n    applyLayout(events, columnWidth, resourceMargin, barMargin, columnIndex, eventLayout) {\n        const\n            me         = this,\n            layoutType = eventLayout.type;\n\n        return me.packEventsInBands(events, (tplData, clusterIndex, slot, slotSize) => {\n            // Stretch events to fill available width\n            if (layoutType === 'none') {\n                tplData.width = columnWidth - resourceMargin * 2;\n                tplData.left += resourceMargin;\n            }\n            else {\n                // Fractions of resource column\n                tplData.widthFactor = slotSize;\n\n                const\n                    leftFactor      = tplData.leftFactor = slot.start + (clusterIndex * slotSize),\n                    // Number of \"columns\" in the current slot\n                    packColumnCount = Math.round(1 / slotSize),\n                    // Index among those columns for current event\n                    packColumnIndex = leftFactor / slotSize,\n                    // Width with all bar margins subtracted\n                    availableWidth  = columnWidth - resourceMargin * 2 - barMargin * (packColumnCount - 1);\n\n                // Allowing two events to overlap? Slightly offset the second\n                if (layoutType === 'mixed' && packColumnCount === 2) {\n                    tplData.left += leftFactor * columnWidth / 5 + barMargin;\n                    tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;\n                    tplData.zIndex = 5 + packColumnIndex;\n                }\n                // Pack by default\n                else {\n                    // Fractional width\n                    tplData.width = slotSize * availableWidth;\n                    // Translate to absolute position\n                    tplData.left += leftFactor * availableWidth + resourceMargin + barMargin * packColumnIndex;\n                }\n            }\n            tplData.cls['b-sch-event-narrow'] = tplData.width < me.scheduler.narrowEventWidth;\n        });\n    }\n}\n","import Base from '../../../Core/Base.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VerticalLayout from '../../eventlayout/VerticalLayout.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n\n/**\n * @module Scheduler/view/orientation/VerticalRendering\n */\n\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    },\n    emptyObject        = Object.freeze({});\n\n/**\n * Handles event rendering in Schedulers vertical mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class VerticalRendering extends Base.mixin(Delayable, AttachToProjectMixin) {\n\n    //region Config & Init\n\n    static get properties() {\n        return {\n            eventMap               : new Map(),\n            resourceMap            : new Map(),\n            releasedElements       : {},\n            toDrawOnProjectRefresh : new Set(),\n            resourceBufferSize     : 1\n        };\n    }\n\n    construct(scheduler) {\n        this.client         = this.scheduler = scheduler;\n        this.verticalLayout = new VerticalLayout({ scheduler });\n\n        super.construct({});\n    }\n\n    init() {\n        const\n            me                             = this,\n            { scheduler, resourceColumns } = me;\n\n        // Resource header/columns\n        resourceColumns.resourceStore = me.resourceStore;\n\n        resourceColumns.ion({\n            name              : 'resourceColumns',\n            columnWidthChange : 'onResourceColumnWidthChange',\n            thisObj           : me\n        });\n\n        me.initialized = true;\n\n        if (scheduler.isPainted) {\n            me.renderer();\n        }\n\n        resourceColumns.availableWidth = scheduler.timeAxisSubGridElement.offsetWidth;\n    }\n\n    //endregion\n\n    //region Elements <-> Records\n\n    resolveRowRecord(elementOrEvent, xy) {\n        const\n            me            = this,\n            { scheduler } = me,\n            event         = elementOrEvent.nodeType ? null : elementOrEvent,\n            element       = event ? event.target : elementOrEvent,\n            coords        = event ? [event.borderOffsetX, event.borderOffsetY] : xy,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventElement  = el.closest(scheduler.eventSelector);\n\n        if (eventElement) {\n            return scheduler.resourceStore.getById(eventElement.dataset.resourceId);\n        }\n\n        // Need to be inside schedule at least\n        if (!element.closest('.b-sch-timeaxis-cell')) {\n            return null;\n        }\n\n        if (!coords) {\n            throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser\n                event instead of element to extract element and coordinates from`);\n        }\n\n        if (scheduler.variableColumnWidths || scheduler.resourceStore.isGrouped) {\n            let totalWidth = 0;\n\n            for (const col of me.resourceStore) {\n                if (!col.isSpecialRow) {\n                    totalWidth += col.columnWidth || me.resourceColumns.columnWidth;\n                }\n                if (totalWidth >= coords[0]) {\n                    return col;\n                }\n            }\n\n            return null;\n        }\n\n        const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);\n\n        return me.allResourceRecords[index];\n    }\n\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const eventData = this.eventMap.get(assignmentRecord.eventId)?.[assignmentRecord.resourceId];\n\n        if (eventData) {\n            eventData.renderData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n            // Element from the map cannot be trusted, might be reused in which case map is not updated to reflect that.\n            // To be safe, retrieve using `getElementFromAssignmentRecord`\n            const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper);\n\n            if (element) {\n                element.classList[add ? 'add' : 'remove'](cls);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Coordinate <-> Date\n\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        let coord = xy[1];\n\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n\n        return this.scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n\n    translateToScheduleCoordinate(y) {\n        return y - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top - globalThis.scrollY;\n    }\n\n    translateToPageCoordinate(y) {\n        return y + this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top + globalThis.scrollY;\n    }\n\n    //endregion\n\n    //region Regions\n\n    getResourceEventBox(event, resource) {\n        const\n            eventId    = event.id,\n            resourceId = resource.id;\n\n        let { renderData } = this.eventMap.get(eventId)?.[resourceId] || emptyObject;\n\n        if (!renderData) {\n            // Never been in view, lay it out\n            this.layoutResource(this.scheduler.resourceStore.getById(resourceId));\n\n            // Have another go at getting the layout data\n            renderData = this.eventMap.get(eventId)?.[resourceId]?.renderData;\n        }\n\n        return renderData\n            ? new Rectangle(renderData.left, renderData.top, renderData.width, renderData.bottom - renderData.top)\n            : null;\n    }\n\n    getScheduleRegion(resourceRecord, eventRecord, local) {\n        const\n            me            = this,\n            { scheduler } = me,\n            // Only interested in width / height (in \"local\" coordinates)\n            region        = Rectangle.from(scheduler.timeAxisSubGridElement, scheduler.timeAxisSubGridElement);\n\n        if (resourceRecord) {\n            // TODO: How to account for eventRecord here?\n            region.left  = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n            region.right = region.left + scheduler.resourceColumnWidth;\n        }\n\n        const\n            start           = scheduler.timeAxis.startDate,\n            end             = scheduler.timeAxis.endDate,\n            dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n                start,\n                end\n            },\n            startY          = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),\n            endY            = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));\n\n        if (!local) {\n            region.top    = me.translateToPageCoordinate(startY);\n            region.bottom = me.translateToPageCoordinate(endY);\n        }\n        else {\n            region.top    = startY;\n            region.bottom = endY;\n        }\n\n        return region;\n    }\n\n    getRowRegion(resourceRecord, startDate, endDate) {\n        const\n            me            = this,\n            { scheduler } = me,\n            x             = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            taStart       = scheduler.timeAxis.startDate,\n            taEnd         = scheduler.timeAxis.endDate,\n            start         = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end           = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startY        = scheduler.getCoordinateFromDate(start),\n            endY          = scheduler.getCoordinateFromDate(end, true, true),\n            y             = Math.min(startY, endY),\n            height        = Math.abs(startY - endY);\n\n        return new Rectangle(x, y, scheduler.resourceColumnWidth, height);\n    }\n\n    get visibleDateRange() {\n        const\n            scheduler = this.scheduler,\n            scrollPos = scheduler.scrollable.y,\n            height    = scheduler.scrollable.clientHeight,\n            startDate = scheduler.getDateFromCoordinate(scrollPos) || scheduler.timeAxis.startDate,\n            endDate   = scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate;\n\n        return {\n            startDate,\n            endDate,\n            startMS : startDate.getTime(),\n            endMS   : endDate.getTime()\n        };\n    }\n\n    //endregion\n\n    //region Events\n\n    // Column width changed, rerender fully\n    onResourceColumnWidthChange({ width, oldWidth }) {\n        const\n            me            = this,\n            { scheduler } = me;\n\n        // Fix width of column & header\n        me.resourceColumns.width = scheduler.timeAxisColumn.width = me.allResourceRecords.length * width;\n        me.clearAll();\n\n        // Only transition large changes, otherwise it is janky when dragging slider in demo\n        me.refresh(Math.abs(width - oldWidth) > 30);\n\n        // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update\n        //        scheduler.callEachSubGrid('refreshFakeScroll');\n        //        scheduler.refreshVirtualScrollbars();\n    }\n\n    //endregion\n\n    //region Project\n\n    attachToProject(project) {\n        super.attachToProject(project);\n\n        if (project) {\n            project.ion({\n                name    : 'project',\n                refresh : 'onProjectRefresh',\n                thisObj : this\n            });\n        }\n    }\n\n    onProjectRefresh() {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.rendered && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset)\n                if (me.refreshAllWhenReady) {\n                    me.clearAll();\n                    //scheduler.refreshWithTransition();\n                    me.refresh();\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refresh();\n                }\n\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n\n    //endregion\n\n    //region EventStore\n\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n\n        this.refreshAllWhenReady = true;\n\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            this.refreshAllWhenReady = true;\n        }\n    }\n\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, isAssign }) {\n        const\n            me          = this,\n            resourceIds = new Set();\n\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n\n        switch (action) {\n            // No-ops\n            case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n            case 'group':\n            case 'move':\n            case 'remove': // Remove is a no-op since assignment will also be removed\n                return;\n\n            case 'dataset':\n                me.refreshAllResourcesWhenReady();\n                return;\n\n            case 'add':\n            case 'updateMultiple':\n                // Just refresh below\n                break;\n\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([, newEvent]) => {\n                    // Old cleared by changed assignment\n                    newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                });\n                // And clear them\n                me.clearResources(resourceIds);\n                break;\n\n            case 'removeall':\n            case 'filter':\n                // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                // figure out which events was filtered out and only clear their resources.\n                me.clearAll();\n                me.refresh();\n                return;\n\n            case 'update': {\n                // Check if changes are graph related or not\n                const allChrono = record.$entity\n                    ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                    : !Object.keys(changes).some(name => !chronoFields[name]);\n\n                // If any one of these in changes, it will affect visuals\n                let changeCount = 0;\n                if ('startDate' in changes) changeCount++;\n                if ('endDate' in changes) changeCount++;\n                if ('duration' in changes) changeCount++;\n\n                // Always redraw non chrono changes (name etc)\n                if (!allChrono || changeCount || 'percentDone' in changes || 'inactive' in changes || 'segments' in changes) {\n                    me.clearResources(resourceIds);\n                    me.refresh();\n                }\n                return;\n            }\n        }\n\n        me.refreshResourcesWhenReady(resourceIds);\n    }\n\n    //endregion\n\n    //region ResourceStore\n\n    attachToResourceStore(resourceStore) {\n        const me = this;\n\n        super.attachToResourceStore(resourceStore);\n\n        me.refreshAllWhenReady = true;\n\n        if (me.resourceColumns) {\n            me.resourceColumns.resourceStore = resourceStore;\n        }\n\n        resourceStore.ion({\n            name             : 'resourceStore',\n            changePreCommit  : 'onResourceStoreChange',\n            refreshPreCommit : 'onResourceStoreRefresh',\n            // In vertical, resource store is not the row store but should toggle the load mask\n            load             : () => me.scheduler.unmaskBody(),\n            thisObj          : me,\n            prio             : 1 // Call before others to clear cache before redraw\n        });\n\n        if (me.initialized && me.scheduler.isPainted) {\n            // Invalidate resource range and events\n            me.firstResource = me.lastResource = null;\n            me.clearAll();\n\n            me.renderer();\n        }\n    }\n\n    onResourceStoreChange({ source : resourceStore, action, records = [], record, replaced, changes }) {\n        const\n            me              = this,\n            // records for add, record for update, replaced [[old, new]] for replace\n            resourceRecords = replaced ? replaced.map(r => r[1]) : records,\n            resourceIds     = new Set(resourceRecords.map(resourceRecord => resourceRecord.id));\n\n        // Invalidate resource range\n        me.firstResource                  = me.lastResource = null;\n        resourceStore._allResourceRecords = null;\n\n        const { allResourceRecords } = resourceStore;\n\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'update':\n                    if (changes?.id) {\n                        me.clearResources([changes.id.oldValue, changes.id.value]);\n                    }\n                    else {\n                        me.clearResources([record.id]);\n                    }\n                    // Only the invalidation above needed\n                    break;\n\n                case 'filter':\n                    // All filtered out resources needs clearing and so does those not filtered out since they might have\n                    // moved horizontally when others hide\n                    me.clearAll();\n                    break;\n            }\n\n            // Changing a column width means columns after that will have to be recalculated\n            // so clear all cached layouts.\n            if (changes && ('columnWidth' in changes)) {\n                me.clearAll();\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            switch (action) {\n                case 'dataset':\n                case 'remove': // Cannot tell from which index it was removed\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n\n                case 'replace':\n                case 'add': {\n                    // Make sure all existing events following added resources are offset correctly\n                    const\n                        firstIndex = resourceRecords.reduce(\n                            (index, record) => Math.min(index, allResourceRecords.indexOf(record)),\n                            allResourceRecords.length\n                        );\n\n                    for (let i = firstIndex; i < allResourceRecords.length; i++) {\n                        resourceIds.add(allResourceRecords[i].id);\n                    }\n                }\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    onResourceStoreRefresh({ action }) {\n        const me = this;\n\n        if (action === 'sort' || action === 'group') {\n            // Invalidate resource range & cache\n            me.firstResource = me.lastResource = me.resourceStore._allResourceRecords = null;\n            me.clearAll();\n            me.refresh();\n        }\n    }\n\n    //endregion\n\n    //region AssignmentStore\n\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n\n        this.refreshAllWhenReady = true;\n\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n\n    onAssignmentStoreChange({ action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me          = this,\n            resourceIds = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));\n\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'remove':\n                    me.clearResources(resourceIds);\n                    break;\n\n                case 'filter':\n                    me.clearAll();\n                    break;\n\n                case 'update': {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n\n                    // Ignore engine resolving resourceId -> resource, eventId -> event\n                    if (!Object.keys(changes).filter(field => field !== 'resource' && field !== 'event').length) {\n                        return;\n                    }\n\n                    me.clearResources(resourceIds);\n                }\n            }\n\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            if (changes && 'resourceId' in changes) {\n                resourceIds.add(changes.resourceId.oldValue);\n            }\n\n            switch (action) {\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([oldAssignment, newAssignment]) => {\n                        resourceIds.add(oldAssignment.resourceId);\n                        resourceIds.add(newAssignment.resourceId);\n                    });\n            }\n\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.refreshAllResourcesWhenReady();\n        }\n    }\n\n    //endregion\n\n    //region View hooks\n\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n            this.scheduler.refreshFromRerender = false;\n        }\n    }\n\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.renderResource(resourceRecord);\n    }\n\n    updateFromHorizontalScroll(scrollX) {\n        if (scrollX !== this.prevScrollX) {\n            this.renderer();\n            this.prevScrollX = scrollX;\n        }\n    }\n\n    updateFromVerticalScroll() {\n        this.renderer();\n    }\n\n    scrollResourceIntoView(resourceRecord, options) {\n        const\n            { scheduler } = this,\n            x             = this.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n\n        return scheduler.scrollHorizontallyTo(x, options);\n    }\n\n    get allResourceRecords() {\n        return this.scheduler.resourceStore.allResourceRecords;\n    }\n\n    // Called when viewport size changes\n    onViewportResize(width) {\n        this.resourceColumns.availableWidth = width;\n        this.renderer();\n    }\n\n    get resourceColumns() {\n        return this.scheduler.timeAxisColumn?.resourceColumns;\n    }\n\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n\n    // No need to do anything special\n    onDragAbort() {}\n\n    onBeforeRowHeightChange() {}\n\n    onTimeAxisViewModelUpdate() {}\n\n    updateElementId() {}\n\n    releaseTimeSpanDiv() {}\n\n    //endregion\n\n    //region Dependency connectors\n\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'top';\n    }\n\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'bottom';\n    }\n\n    //endregion\n\n    //region Refresh resources\n\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n\n    /**\n     * Clears all resources directly and redraws them on next project refresh\n     * @private\n     */\n    refreshAllResourcesWhenReady() {\n        this.clearAll();\n        this.refreshAllWhenReady = true;\n    }\n\n    //region Rendering\n\n    // Resources in view + buffer\n    get resourceRange() {\n        return this.getResourceRange(true);\n    }\n\n    // Resources strictly in view\n    get visibleResources() {\n        const { first, last } = this.getResourceRange();\n\n        return {\n            first : this.allResourceRecords[first],\n            last  : this.allResourceRecords[last]\n        };\n    }\n\n    getResourceRange(withBuffer) {\n        const\n            {\n                scheduler,\n                resourceStore\n            }                  = this,\n            {\n                resourceColumnWidth,\n                scrollX\n            }                  = scheduler,\n            {\n                scrollWidth\n            }                  = scheduler.timeAxisSubGrid.scrollable,\n            resourceBufferSize = withBuffer ? this.resourceBufferSize : 0,\n            viewportStart      = scrollX - resourceBufferSize,\n            viewportEnd        = scrollX + scrollWidth + resourceBufferSize;\n\n        if (!resourceStore?.count) {\n            return { first : -1, last : -1 };\n        }\n\n        // Some resources define their own width\n        if (scheduler.variableColumnWidths) {\n            let first, last, start, end = 0;\n            this.allResourceRecords.forEach((resource, i) => {\n                resource.instanceMeta(scheduler).insetStart = start = end;\n                end                                         = start + resource.columnWidth;\n\n                if (start > viewportEnd) {\n                    return false;\n                }\n                if (end > viewportStart && first == null) {\n                    first = i;\n                }\n                else if (start < viewportEnd) {\n                    last = i;\n                }\n            });\n            return { first, last };\n        }\n        // We are using fixed column widths\n        else {\n            return {\n                first : Math.max(Math.floor(scrollX / resourceColumnWidth) - resourceBufferSize, 0),\n                last  : Math.min(\n                    Math.floor((scrollX + scheduler.timeAxisSubGrid.width) / resourceColumnWidth) + resourceBufferSize,\n                    this.allResourceRecords.length - 1\n                )\n            };\n        }\n    }\n\n    // Dates in view + buffer\n    get dateRange() {\n        const\n            { scheduler } = this;\n\n        let bottomDate = scheduler.getDateFromCoordinate(Math.min(\n            scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,\n            (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1)\n        );\n\n        // Might end up below time axis (out of ticks)\n        // TODO: Change call order on refresh to make sure this is not needed?\n        if (!bottomDate) {\n            bottomDate = scheduler.timeAxis.last.endDate;\n        }\n\n        let topDate = scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0));\n\n        // Might end up above time axis when reconfiguring (since this happens as part of rendering)\n        if (!topDate) {\n            topDate    = scheduler.timeAxis.first.startDate;\n            bottomDate = scheduler.getDateFromCoordinate(scheduler.bodyHeight + scheduler.tickSize - 1);\n        }\n\n        return {\n            topDate,\n            bottomDate\n        };\n    }\n\n    getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            {\n                scheduler\n            }              = me,\n            {\n                preamble,\n                postamble\n            }              = eventRecord,\n            {\n                variableColumnWidths\n            }              = scheduler,\n            useEventBuffer = scheduler.features.eventBuffer?.enabled && me.isProVerticalRendering &&\n                (preamble || postamble) && !eventRecord.isMilestone,\n            startDateField = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            startDate      = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(startDateField) && !useEventBuffer\n                ? eventRecord.get(startDateField) : eventRecord[startDateField],\n            endDate        = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(endDateField) && !useEventBuffer\n                ? eventRecord.get(endDateField) : eventRecord[endDateField],\n            resourceMargin = scheduler.getResourceMargin(resourceRecord),\n            top            = scheduler.getCoordinateFromDate(startDate),\n            instanceMeta   = resourceRecord.instanceMeta(scheduler),\n            // Preliminary values for left & width, used for proxy. Will be changed on layout.\n            // The property \"left\" is utilized based on Scheduler's rtl setting.\n            // If RTL, then it's used as the \"right\" style position.\n            left           = variableColumnWidths ? instanceMeta.insetStart : me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            resourceWidth  = scheduler.getResourceWidth(resourceRecord),\n            width          = resourceWidth - resourceMargin * 2,\n            startDateMS    = startDate.getTime(),\n            endDateMS      = endDate.getTime();\n\n        let bottom = scheduler.getCoordinateFromDate(endDate),\n            height = bottom - top;\n\n        // Below, estimate height\n        if (bottom === -1) {\n            height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('millisecond'));\n            bottom = top + height;\n        }\n\n        return {\n            eventRecord,\n            resourceRecord,\n            left,\n            top,\n            bottom,\n            resourceWidth,\n            width,\n            height,\n            startDate,\n            endDate,\n            startDateMS,\n            endDateMS,\n            useEventBuffer,\n\n            children : [],\n\n            // to match horizontal, TODO: should change there\n            start   : startDate,\n            end     : endDate,\n            startMS : startDateMS,\n            endMS   : endDateMS\n        };\n    }\n\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    eventSorter(a, b) {\n        const\n            startA = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks\n            endA   = a.dataEndMs || a.endDateMS,\n            startB = b.dataStartMs || b.startDateMS,\n            endB   = b.dataEndMs || b.endDateMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n\n    // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one\n    // resource will never affect the others\n    layoutResource(resourceRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            {\n                variableColumnWidths\n            }                   = scheduler,\n            { id : resourceId } = resourceRecord,\n            instanceMeta        = resourceRecord.instanceMeta(scheduler),\n            // Used in loop, reduce access time a wee bit\n            {\n                assignmentStore,\n                eventStore,\n                timeAxis\n            }                   = scheduler,\n            // Cache per resource\n            cache               = me.resourceMap.set(resourceId, {}).get(resourceId),\n            // Resource \"column\"\n            resourceIndex       = me.allResourceRecords.indexOf(resourceRecord),\n            {\n                barMargin,\n                resourceMargin\n            }                   = scheduler.getResourceLayoutSettings(resourceRecord);\n\n        // Events for the resource, minus those that are filtered out by filtering assignments and events\n\n        let events = eventStore.getEvents({\n            includeOccurrences : scheduler.enableRecurringEvents,\n            resourceRecord,\n            startDate          : timeAxis.startDate,\n            endDate            : timeAxis.endDate,\n            filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                eventRecord.assignments.some(a => a.resource === resourceRecord && assignmentStore.includes(a)))\n        });\n\n        // Hook for features to inject additional timespans to render\n        events = scheduler.getEventsToRender(resourceRecord, events);\n\n        const layoutData = events.reduce((toLayout, eventRecord) => {\n            if (eventRecord.isScheduled) {\n                const\n                    renderData     = scheduler.generateRenderData(eventRecord, resourceRecord, false),\n                    // Elements will be appended to eventData during syncing\n                    eventData      = { renderData },\n                    eventResources = ObjectHelper.getMapPath(me.eventMap, renderData.eventId, {});\n\n                // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }\n                // Uses renderData.eventId in favor of eventRecord.id to work with ResourceTimeRanges\n                eventResources[resourceId] = eventData;\n\n                // Cache per resource\n                cache[renderData.eventId] = eventData;\n\n                // Position ResourceTimeRanges directly, they do not affect the layout of others\n                if (renderData.fillSize) {\n                    // The property \"left\" is utilized based on Scheduler's rtl setting.\n                    // If RTL, then it's used as the \"right\" style position.\n                    renderData.left = variableColumnWidths ? instanceMeta.insetStart : resourceIndex * scheduler.resourceColumnWidth;\n\n                    renderData.width = scheduler.getResourceWidth(resourceRecord);\n                }\n                // Anything not flagged with `fillSize` should take part in layout\n                else {\n                    toLayout.push(renderData);\n                }\n            }\n\n            return toLayout;\n        }, []);\n\n        // Ensure the events are rendered in natural order so that navigation works.\n        layoutData.sort(me.eventSorter);\n\n        // Apply per resource event layout (pack, overlap or mixed)\n        me.verticalLayout.applyLayout(\n            layoutData,\n            scheduler.getResourceWidth(resourceRecord),\n            resourceMargin,\n            barMargin,\n            resourceIndex,\n            scheduler.getEventLayout(resourceRecord)\n        );\n\n        return cache;\n    }\n\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(\n                eventRecord,\n                eventRecord.resource,\n                { timeAxis : true, viewport : true }\n            );\n\n        renderData.top = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;\n\n        const\n            domConfig   = this.renderEvent({ renderData }),\n            { dataset } = domConfig;\n\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n\n        const result = DomHelper.createElement(domConfig);\n\n        result.innerElement = result.firstChild;\n\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n\n        return result;\n    }\n\n    // TODO: Pretty much identical to HorizontalRendering#renderEvent. Make shared base class\n    // Render a single event, aborting if already in DOM. To update an event, first release its element and then render\n    // it again. The element will be reused and updated. Keeps code simpler\n    renderEvent(eventData) {\n        // No point in rendering event that already has an element\n        const\n            { scheduler } = this,\n            data          = eventData.renderData,\n            {\n                resourceRecord,\n                assignmentRecord,\n                eventRecord\n            }             = data,\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig = {\n                className : data.wrapperCls,\n                tabIndex  : -1,\n                children  : [\n                    {\n                        role      : 'presentation',\n                        className : data.cls,\n                        style     : (data.internalStyle || '') + (data.style || ''),\n                        children  : data.children,\n                        dataset   : {\n                            // Each feature putting contents in the event wrap should have this to simplify syncing and\n                            // element retrieval after sync\n                            taskFeature : 'event'\n                        },\n                        syncOptions : {\n                            syncIdField : 'taskBarFeature'\n                        }\n                    },\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top                                : data.top,\n                    [scheduler.rtl ? 'right' : 'left'] : data.left,\n                    // DomHelper appends px to dimensions when using numbers\n                    height                             : eventRecord.isMilestone ? '1em' : data.height,\n                    width                              : data.width,\n                    style                              : data.wrapperStyle || '',\n                    fontSize                           : eventRecord.isMilestone ? Math.min(data.width, 40) : null\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    // Sync using assignment id for events and event id for ResourceTimeRanges\n                    syncId     : assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId\n\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : eventData,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : (assignmentRecord || eventRecord).instanceMeta(this.scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n\n        elementConfig.className['b-sch-vertical'] = 1;\n\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n\n        // Allows access to the used config later, for example to retrieve element\n        eventData.elementConfig = elementConfig;\n\n        return elementConfig;\n    }\n\n    renderResource(resourceRecord) {\n        const\n            me                          = this,\n            // Date at top and bottom for determining which events to include\n            { topDateMS, bottomDateMS } = me,\n            // Will hold element configs\n            eventDOMConfigs             = [];\n\n        let resourceEntry = me.resourceMap.get(resourceRecord.id);\n\n        // Layout all events for the resource unless already done\n        if (!resourceEntry) {\n            resourceEntry = me.layoutResource(resourceRecord);\n        }\n\n        // Iterate over all events for the resource\n        for (const eventId in resourceEntry) {\n            const\n                eventData                               = resourceEntry[eventId],\n                { endDateMS, startDateMS, eventRecord } = eventData.renderData;\n\n            if (\n                // Only collect configs for those actually in view\n                endDateMS >= topDateMS && startDateMS <= bottomDateMS &&\n                // And not being dragged, those have a temporary element already\n                !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement\n            ) {\n                // Reuse DomConfig if available, otherwise render event to create one\n                const domConfig = eventData.elementConfig?.className !== 'b-released' && eventData.elementConfig || me.renderEvent(eventData);\n                eventDOMConfigs.push(domConfig);\n            }\n        }\n\n        return eventDOMConfigs;\n    }\n\n    isEventElement(domConfig) {\n        const className = domConfig && domConfig.className;\n\n        return className && className[this.scheduler.eventCls + '-wrap'];\n    }\n\n    // Single cell so only one call to this renderer, determine which events are in view and draw them.\n    // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`\n    renderer() {\n        const\n            me                                           = this,\n            { scheduler }                                = me,\n            // Determine resource range to draw events for\n            { first : firstResource, last : lastResource } = me.resourceRange,\n            // Date at top and bottom for determining which events to include\n            { topDate, bottomDate }                        = me.dateRange,\n            syncConfigs                                    = [],\n            featureDomConfigs                              = [];\n\n        // If scheduler is creating a new event, the render needs to be synchronous, so\n        // we cannot wait for the engine to normalize - the new event will have correct data set.\n        if (!me.initialized || (!scheduler.isEngineReady && !scheduler.isCreating)) {\n            return;\n        }\n\n        //<debug>\n        if (globalThis.DEBUG) {\n            if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n                console.log(`Resources in view ${me.allResourceRecords[firstResource].id} -> ${me.allResourceRecords[lastResource].id}`);\n            }\n        }\n        //</debug>\n\n        // Update current time range, reflecting the change on the vertical time axis header\n        if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {\n            // Calculated values used by `renderResource()`\n            me.topDate      = topDate;\n            me.bottomDate   = bottomDate;\n            me.topDateMS    = topDate.getTime();\n            me.bottomDateMS = bottomDate.getTime();\n\n            const range = me.timeView.range = { startDate : topDate, endDate : bottomDate };\n\n            scheduler.onVisibleDateRangeChange(range);\n        }\n\n        if (firstResource !== -1 && lastResource !== -1) {\n            // Collect all events for resources in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                syncConfigs.push.apply(syncConfigs, me.renderResource(me.allResourceRecords[i]));\n            }\n        }\n\n        scheduler.getForegroundDomConfigs(featureDomConfigs);\n\n        syncConfigs.push.apply(syncConfigs, featureDomConfigs);\n\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : syncConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n\n            // Called by DomHelper when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const { reactComponent } = scheduler;\n                // If element is an event wrap, trigger appropriate events\n                if (me.isEventElement(domConfig) || jsx || domConfig?.elementData?.jsx) {\n                    const\n                        // Some actions are considered first a release and then a render (reusing another element).\n                        // This gives clients code a chance to clean up before reusing an element\n                        isRelease = releaseEventActions[action],\n                        isRender  = renderEventActions[action];\n\n                    if (scheduler.processEventContent?.({\n                        action,\n                        domConfig,\n                        isRelease : false,\n                        targetElement,\n                        reactComponent,\n                        jsx\n\n                    })) return;\n\n                    // If we are reusing an element that was previously released we should not trigger again\n                    if (isRelease && me.isEventElement(lastDomConfig) && !lastDomConfig.isReleased) {\n                        const\n                            data  = lastDomConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement\n                            };\n\n                        // Release any portal in React event content\n                        scheduler.processEventContent?.({\n                            isRelease,\n                            targetElement,\n                            reactComponent,\n                            assignmentRecord : data.assignmentRecord\n                        });\n\n                        // Some browsers do not blur on set to display:none, so releasing the active element\n                        // must *explicitly* move focus outwards to the view.\n                        if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                            scheduler.focusElement.focus();\n                        }\n\n                        // This event is documented on Scheduler\n                        scheduler.trigger('releaseEvent', event);\n                    }\n\n                    if (isRender) {\n                        const\n                            data  = domConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement,\n                                isReusingElement : action === 'reuseElement',\n                                isRepaint        : action === 'reuseOwnElement'\n                            };\n\n                        event.reusingElement = action === 'reuseElement';\n\n                        // This event is documented on Scheduler\n                        scheduler.trigger('renderEvent', event);\n                    }\n                }\n            }\n        });\n\n        // Change in displayed resources?\n        if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n            // Update header to match\n            const range = me.resourceColumns.visibleResources = { firstResource, lastResource };\n\n            // Store which resources are currently in view\n            me.firstResource = firstResource;\n            me.lastResource  = lastResource;\n\n            scheduler.onVisibleResourceRangeChange(range);\n            scheduler.trigger('resourceRangeChange', range);\n        }\n    }\n\n    refresh(transition) {\n        this.scheduler.runWithTransition(() => this.renderer(), transition);\n    }\n\n    // To match horizontals API, used from EventDrag\n    refreshResources(resourceIds) {\n        this.clearResources(resourceIds);\n        this.refresh();\n    }\n\n    // To match horizontals API, used from EventDrag\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        this.refreshResources([recordOrRow.id]);\n    }\n\n    onRenderDone() {\n\n    }\n\n    //endregion\n\n    //region Other\n\n    get timeView() {\n        return this.scheduler.timeView;\n    }\n\n    //endregion\n\n    //region Cache\n\n    // Clears cached resource layout\n    clearResources(resourceIds) {\n        const { resourceMap, eventMap } = this;\n\n        //<debug>\n        if (globalThis.DEBUG) console.log('%Clearing resources ' + Array.from(resourceIds).join(','), 'color: #770000');\n        //</debug>\n\n        resourceIds.forEach(resourceId => {\n            if (resourceMap.has(resourceId)) {\n                // The *keys* of an Object are strings, so we must iterate the values\n                // and use the original eventId to look up in the Map which preserves key type.\n                Object.values(resourceMap.get(resourceId)).forEach(({ renderData : { eventId } }) => {\n                    delete eventMap.get(eventId)[resourceId];\n                });\n\n                resourceMap.delete(resourceId);\n            }\n        });\n    }\n\n    clearAll() {\n        //<debug>\n        if (globalThis.DEBUG) console.log('%Clearing all', 'color: #770000');\n        //</debug>\n\n        this.resourceMap.clear();\n        this.eventMap.clear();\n    }\n\n    //endregion\n}\n","import TimelineBase from './TimelineBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport CrudManager from '../data/CrudManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../localization/En.js';\n\nimport CurrentConfig from './mixin/CurrentConfig.js';\nimport Describable from './mixin/Describable.js';\nimport SchedulerDom from './mixin/SchedulerDom.js';\nimport SchedulerDomEvents from './mixin/SchedulerDomEvents.js';\nimport SchedulerEventRendering from './mixin/SchedulerEventRendering.js';\nimport SchedulerStores from './mixin/SchedulerStores.js';\nimport SchedulerScroll from './mixin/SchedulerScroll.js';\nimport SchedulerRegions from './mixin/SchedulerRegions.js';\nimport SchedulerState from './mixin/SchedulerState.js';\nimport EventSelection from './mixin/EventSelection.js';\nimport EventNavigation from './mixin/EventNavigation.js';\nimport CrudManagerView from '../crud/mixin/CrudManagerView.js';\nimport HorizontalRendering from './orientation/HorizontalRendering.js';\nimport VerticalRendering from './orientation/VerticalRendering.js';\nimport '../column/TimeAxisColumn.js';\nimport '../column/VerticalTimeAxisColumn.js';\n\n// Should always be present in Scheduler\nimport '../../Grid/feature/RegionResize.js';\n\n/**\n * @module Scheduler/view/SchedulerBase\n */\n\nconst\n    descriptionFormats = {\n        month : 'MMMM, YYYY',\n        week  : ['MMMM YYYY (Wp)', 'S{MMM} - E{MMM YYYY} (S{Wp})'],\n        day   : 'MMMM D, YYYY'\n    };\n\n/**\n * A thin base class for {@link Scheduler.view.Scheduler}. Does not include any features by default, allowing smaller\n * custom built bundles if used in place of {@link Scheduler.view.Scheduler}.\n *\n * **NOTE:** In most scenarios you do probably want to use Scheduler instead of SchedulerBase.\n *\n * @mixes Scheduler/view/mixin/Describable\n * @mixes Scheduler/view/mixin/EventNavigation\n * @mixes Scheduler/view/mixin/EventSelection\n * @mixes Scheduler/view/mixin/SchedulerDom\n * @mixes Scheduler/view/mixin/SchedulerDomEvents\n * @mixes Scheduler/view/mixin/SchedulerEventRendering\n * @mixes Scheduler/view/mixin/SchedulerRegions\n * @mixes Scheduler/view/mixin/SchedulerScroll\n * @mixes Scheduler/view/mixin/SchedulerState\n * @mixes Scheduler/view/mixin/SchedulerStores\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes Scheduler/data/mixin/ProjectConsumer\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/Dependencies\n * @features Scheduler/feature/DependencyEdit\n * @features Scheduler/feature/EventCopyPaste\n * @features Scheduler/feature/EventDrag\n * @features Scheduler/feature/EventDragCreate\n * @features Scheduler/feature/EventDragSelect\n * @features Scheduler/feature/EventEdit\n * @features Scheduler/feature/EventFilter\n * @features Scheduler/feature/EventMenu\n * @features Scheduler/feature/EventNonWorkingTime\n * @features Scheduler/feature/EventResize\n * @features Scheduler/feature/EventTooltip\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/Labels\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/ScheduleContext\n * @features Scheduler/feature/ScheduleMenu\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/SimpleEventEdit\n * @features Scheduler/feature/StickyEvents\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n * @features Scheduler/feature/TimeSelection\n *\n * @features Scheduler/feature/experimental/ExcelExporter\n *\n * @features Scheduler/feature/export/PdfExport\n * @features Scheduler/feature/export/exporter/MultiPageExporter\n * @features Scheduler/feature/export/exporter/MultiPageVerticalExporter\n * @features Scheduler/feature/export/exporter/SinglePageExporter\n *\n * @extends Scheduler/view/TimelineBase\n * @widget\n */\nexport default class SchedulerBase extends TimelineBase.mixin(\n    CrudManagerView,\n    Describable,\n    SchedulerDom,\n    SchedulerDomEvents,\n    SchedulerStores,\n    SchedulerScroll,\n    SchedulerState,\n    SchedulerEventRendering,\n    SchedulerRegions,\n    EventSelection,\n    EventNavigation,\n    CurrentConfig\n) {\n    //region Config\n\n    static get $name() {\n        return 'SchedulerBase';\n    }\n\n    // Factoryable type name\n    static get type() {\n        return 'schedulerbase';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Get/set the scheduler's read-only state. When set to `true`, any UIs for modifying data are disabled.\n             * @member {Boolean} readOnly\n             */\n            /**\n             * Configure as `true` to make the scheduler read-only, by disabling any UIs for modifying data.\n             *\n             * __Note that checks MUST always also be applied at the server side.__\n             * @config {Boolean} readOnly\n             * @default false\n             */\n\n            /**\n             * The date to display when used as a component of a Calendar.\n             *\n             * This is required by the Calendar Mode Interface.\n             *\n             * @config {Date}\n             * @category Calendar integration\n             */\n            date : {\n                value : null,\n\n                $config : {\n                    equal : 'date'\n                }\n            },\n\n            /**\n             * Unit used to control how large steps to take when clicking the previous and next buttons in the Calendar\n             * UI. Only applies when used as a component of a Calendar.\n             *\n             * Suitable units depend on configured {@link #config-range}, a smaller or equal unit is recommended.\n             *\n             * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n             * @category Calendar integration\n             */\n            stepUnit : 'week',\n\n            /**\n             * Unit used to set the length of the time axis when used as a component of a Calendar. Suitable units are\n             * `'month'`, `'week'` and `'day'`.\n             *\n             * @config {'day'|'week'|'month'}\n             * @category Calendar integration\n             */\n            range : 'week',\n\n            /**\n             * When the scheduler is used in a Calendar, this function provides the textual description for the\n             * Calendar's toolbar.\n             *\n             * ```javascript\n             *  descriptionRenderer : scheduler => {\n             *      const\n             *          count = scheduler.eventStore.records.filter(\n             *              eventRec => DateHelper.intersectSpans(\n             *                  scheduler.startDate, scheduler.endDate,\n             *                  eventRec.startDate, eventRec.endDate)).length,\n             *          startDate = DateHelper.format(scheduler.startDate, 'DD/MM/YYY'),\n             *          endData = DateHelper.format(scheduler.endDate, 'DD/MM/YYY');\n             *\n             *      return `${startDate} - ${endData}, ${count} event${count === 1 ? '' : 's'}`;\n             *  }\n             * ```\n             * @config {Function}\n             * @param {Scheduler.view.SchedulerBase} view The active view.\n             * @category Calendar integration\n             */\n\n            /**\n             * A method allowing you to define date boundaries that will constrain resize, create and drag drop\n             * operations. The method will be called with the Resource record, and the Event record.\n             *\n             * ```javascript\n             *  new Scheduler({\n             *      getDateConstraints(resourceRecord, eventRecord) {\n             *          // Assuming you have added these extra fields to your own EventModel subclass\n             *          const { minStartDate, maxEndDate } = eventRecord;\n             *\n             *          return {\n             *              start : minStartDate,\n             *              end   : maxEndDate\n             *          };\n             *      }\n             *  });\n             * ```\n             * @param {Scheduler.model.ResourceModel} [resourceRecord] The resource record\n             * @param {Scheduler.model.EventModel} [eventRecord] The event record\n             * @returns {Object} Constraining object containing `start` and `end` constraints. Omitting either\n             * will mean that end is not constrained. So you can prevent a resize or move from moving *before*\n             * a certain time while not constraining the end date.\n             * @returns {Date} [return.start] Start date\n             * @returns {Date} [return.end] End date\n             * @config {Function}\n             * @category Scheduled events\n             */\n            getDateConstraints : null,\n\n            /**\n             * The time axis column config for vertical {@link Scheduler.view.SchedulerBase#config-mode}.\n             *\n             * Object with {@link Scheduler.column.VerticalTimeAxisColumn} configuration.\n             *\n             * This object will be used to configure the vertical time axis column instance.\n             *\n             * The config allows configuring the `VerticalTimeAxisColumn` instance used in vertical mode with any Column options that apply to it.\n             *\n             * Example:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     mode     : 'vertical',\n             *     features : {\n             *         filterBar : true\n             *     },\n             *     verticalTimeAxisColumn : {\n             *         text  : 'Filter by event name',\n             *         width : 180,\n             *         filterable : {\n             *             // add a filter field to the vertical column access header\n             *             filterField : {\n             *                 type        : 'text',\n             *                 placeholder : 'Type to search',\n             *                 onChange    : ({ value }) => {\n             *                     // filter event by name converting to lowerCase to be equal comparison\n             *                     scheduler.eventStore.filter({\n             *                         filters : event => event.name.toLowerCase().includes(value.toLowerCase()),\n             *                         replace : true\n             *                     });\n             *                 }\n             *             }\n             *         }\n             *     },\n             *     ...\n             * });\n             * ```\n             *\n             * @config {VerticalTimeAxisColumnConfig}\n             * @category Time axis\n             */\n            verticalTimeAxisColumn : {},\n\n            /**\n             * See {@link Scheduler.view.Scheduler#keyboard-shortcuts Keyboard shortcuts} for details\n             * @config {Object<String,String>} keyMap\n             * @category Common\n             */\n\n            /**\n             * If true, a new event will be created when user double-clicks on a time axis cell (if scheduler is not in\n             * read only mode).\n             *\n             * The duration / durationUnit of the new event will be 1 time axis tick (default), or it can be read from\n             * the {@link Scheduler.model.EventModel#field-duration} and\n             * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n             *\n             * Set to `false` to not create events on double click.\n             * @config {Boolean|Object} createEventOnDblClick\n             * @param {Boolean} [createEventOnDblClick.useEventModelDefaults] set to `true` to set default duration\n             * based on the defaults specified by the {@link Scheduler.model.EventModel#field-duration} and\n             * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n             * @default\n             * @category Scheduled events\n             */\n            createEventOnDblClick : true,\n\n            // A CSS class identifying areas where events can be scheduled using drag-create, double click etc.\n            schedulableAreaSelector : '.b-sch-timeaxis-cell',\n            scheduledEventName      : 'event',\n            sortFeatureStore        : 'resourceStore'\n        };\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Scheduler mode. Supported values: horizontal, vertical\n             * @config {'horizontal'|'vertical'} mode\n             * @default\n             */\n            mode : 'horizontal',\n\n            /**\n             * CSS class to add to rendered events\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            eventCls : 'b-sch-event',\n\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            timeCellCls : 'b-sch-timeaxis-cell',\n\n            /**\n             * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : 'b-sch-event-hover',\n\n            /**\n             * Set to false if you don't want to allow events overlapping times for any one resource (defaults to true).\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            allowOverlap : true,\n\n            /**\n             * The height in pixels of Scheduler rows.\n             * @config {Number}\n             * @default\n             */\n            rowHeight : 60,\n\n            /**\n             * Scheduler overrides Grids default implementation of {@link Grid.view.GridBase#config-getRowHeight} to\n             * pre-calculate row heights based on events in the rows.\n             *\n             * The amount of rows that are pre-calculated is limited for performance reasons. The limit is configurable\n             * by specifying the {@link Scheduler.view.SchedulerBase#config-preCalculateHeightLimit} config.\n             *\n             * The results of the calculation are cached internally.\n             *\n             * @config {Function} getRowHeight\n             * @param {Scheduler.model.ResourceModel} getRowHeight.record Resource record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n\n            /**\n             * Maximum number of resources for which height is pre-calculated. If you have many events per\n             * resource you might want to lower this number to gain some initial rendering performance.\n             *\n             * Specify a falsy value to opt out of row height pre-calculation.\n             *\n             * @config {Number}\n             * @default\n             * @category Layout\n             */\n            preCalculateHeightLimit : 10000,\n\n            crudManagerClass : CrudManager,\n\n            testConfig : {\n                loadMaskError : {\n                    autoClose : 10,\n                    showDelay : 0\n                }\n            }\n        };\n    }\n\n    static properties = {\n        timeCellSelector          : '.b-sch-timeaxis-cell',\n        resourceTimeRangeSelector : '.b-sch-resourcetimerange'\n    }\n\n    // Keep this commented out to have easy access to the syntax next time we need to use it\n    // static get deprecatedEvents() {\n    //     return {\n    //         eventContextMenuBeforeShow : {\n    //             product            : 'Scheduler',\n    //             invalidAsOfVersion : '5.0.0',\n    //             message            : '`eventContextMenuBeforeShow` event is deprecated, in favor of `eventMenuBeforeShow` event. Please see https://bryntum.com/products/scheduler/docs/guide/Scheduler/upgrades/3.1.0 for more information.'\n    //         }\n    //     };\n    // }\n\n    //endregion\n\n    //region Store & model docs\n\n    // Documented here instead of in SchedulerStores since SchedulerPro uses different types\n\n    // Configs\n\n    /**\n     * Inline events, will be loaded into an internally created EventStore.\n     * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events\n     * @category Data\n     */\n\n    /**\n     * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required).\n     * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore\n     * @category Data\n     */\n\n    /**\n     * Inline resources, will be loaded into an internally created ResourceStore.\n     * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources\n     * @category Data\n     */\n\n    /**\n     * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required).\n     * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore\n     * @category Data\n     */\n\n    /**\n     * Inline assignments, will be loaded into an internally created AssignmentStore.\n     * @config {Scheduler.model.AssignmentModel[]|Object[]} assignments\n     * @category Data\n     */\n\n    /**\n     * The optional {@link Scheduler.data.AssignmentStore}, holding assignments between resources and events.\n     * Required for multi assignments.\n     * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore\n     * @category Data\n     */\n\n    /**\n     * Inline dependencies, will be loaded into an internally created DependencyStore.\n     * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies\n     * @category Data\n     */\n\n    /**\n     * The optional {@link Scheduler.data.DependencyStore}.\n     * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore\n     * @category Data\n     */\n\n    // Properties\n\n    /**\n     * Get/set events, applies to the backing project's EventStore.\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Data\n     */\n\n    /**\n     * Get/set resources, applies to the backing project's ResourceStore.\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the resource store instance of the backing project\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Data\n     */\n\n    /**\n     * Get/set assignments, applies to the backing project's AssignmentStore.\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|Object[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Data\n     */\n\n    /**\n     * Get/set dependencies, applies to the backing projects DependencyStore.\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}\n     * @category Data\n     */\n\n    /**\n     * Get/set the dependencies store instance of the backing project.\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Data\n     */\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Fired after rendering an event, when its element is available in DOM.\n     * @event renderEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering, see\n     *   {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details\n     * @param {Boolean} isRepaint `true` if this render is a repaint of the event, updating its existing element\n     * @param {Boolean} isReusingElement `true` if this render lead to the event reusing a released events element\n     * @param {HTMLElement} element The event bar element\n     */\n\n    /**\n     * Fired after releasing an event, useful to cleanup of custom content added on `renderEvent` or in `eventRenderer`.\n     * @event releaseEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering\n     * @param {HTMLElement} element The event bar element\n     */\n\n    /**\n     * Fired when clicking a resource header cell\n     * @event resourceHeaderClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Fired when double clicking a resource header cell\n     * @event resourceHeaderDblclick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Fired when activating context menu on a resource header cell\n     * @event resourceHeaderContextmenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n\n    /**\n     * Triggered when a keydown event is observed if there are selected events.\n     * @event eventKeyDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n\n    /**\n     * Triggered when a keyup event is observed if there are selected events.\n     * @event eventKeyUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n\n    //endregion\n\n    //region Functions injected by features\n\n    // For documentation & typings purposes\n\n    /**\n     * Opens an editor UI to edit the passed event.\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*\n     *\n     * @function editEvent\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @category Feature shortcuts\n     */\n\n    /**\n     * Returns the dependency record for a DOM element\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/Dependencies Dependencies} feature is enabled.*\n     *\n     * @function resolveDependencyRecord\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     * @category Feature shortcuts\n     */\n\n    //endregion\n\n    //region Init\n\n    afterConstruct() {\n        const me = this;\n\n        super.afterConstruct();\n\n        me.ion({ scroll : 'onVerticalScroll', thisObj : me });\n\n        if (me.createEventOnDblClick) {\n            me.ion({ scheduledblclick : me.onTimeAxisCellDblClick });\n        }\n    }\n\n    //endregion\n\n    //region Overrides\n\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onPaint() because it may be chained on instance and Override won't be applied\n    }\n\n    //endregion\n\n    //region Config getters/setters\n\n    // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead\n    get store() {\n        return super.store;\n    }\n\n    set store(store) {\n        super.store = store;\n    }\n\n    /**\n     * Returns an object defining the range of visible resources\n     * @property {Object}\n     * @property {Scheduler.model.ResourceModel} visibleResources.first First visible resource\n     * @property {Scheduler.model.ResourceModel} visibleResources.last Last visible resource\n     * @readonly\n     */\n    get visibleResources() {\n        const me = this;\n\n        if (me.isVertical) {\n            return me.currentOrientation.visibleResources;\n        }\n\n        return {\n            first : me.store.getById(me.firstVisibleRow?.id),\n            last  : me.store.getById(me.lastVisibleRow?.id)\n        };\n    }\n\n    //endregion\n\n    //region Event handlers\n\n    onLocaleChange() {\n        this.currentOrientation.onLocaleChange();\n\n        super.onLocaleChange();\n    }\n\n    onTimeAxisCellDblClick({ date : startDate, resourceRecord, row }) {\n        const me = this;\n\n        if (me.readOnly || resourceRecord.isSpecialRow || resourceRecord.readOnly) {\n            return;\n        }\n\n        me.createEvent(startDate, resourceRecord, row);\n    }\n\n    onVerticalScroll({ scrollTop }) {\n        this.currentOrientation.updateFromVerticalScroll(scrollTop);\n    }\n\n    /**\n     * Called when new event is created.\n     * Сan be overridden to supply default record values etc.\n     * @param {Scheduler.model.EventModel} eventRecord Newly created event\n     * @category Scheduled events\n     */\n    onEventCreated(eventRecord) {}\n\n    //endregion\n\n    //region Mode\n\n    /**\n     * Checks if scheduler is in horizontal mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isHorizontal() {\n        return this.mode === 'horizontal';\n    }\n\n    /**\n     * Checks if scheduler is in vertical mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n\n    /**\n     * Get mode (horizontal/vertical)\n     * @property {'horizontal'|'vertical'}\n     * @readonly\n     * @category Common\n     */\n    get mode() {\n        return this._mode;\n    }\n\n    set mode(mode) {\n        const me = this;\n\n        me._mode = mode;\n\n        if (!me[mode]) {\n            me.element.classList.add(`b-sch-${mode}`);\n\n            if (mode === 'horizontal') {\n                me.horizontal = new HorizontalRendering(me);\n                if (me.isPainted) {\n                    me.horizontal.init();\n                }\n            }\n            else if (mode === 'vertical') {\n                me.vertical = new VerticalRendering(me);\n\n                if (me.rendered) {\n                    me.vertical.init();\n                }\n            }\n        }\n    }\n\n    get currentOrientation() {\n        return this[this.mode];\n    }\n\n    //endregion\n\n    //region Dom event dummies\n\n    // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...\n\n    onElementKeyDown(event) {\n        return super.onElementKeyDown(event);\n    }\n\n    onElementKeyUp(event) {\n        return super.onElementKeyUp(event);\n    }\n\n    onElementMouseOver(event) {\n        return super.onElementMouseOver(event);\n    }\n\n    onElementMouseOut(event) {\n        return super.onElementMouseOut(event);\n    }\n\n    //endregion\n\n    //region Feature hooks\n\n    // Called for each event during drop\n    processEventDrop() {}\n    processCrossSchedulerEventDrop() {}\n\n    // Called before event drag starts\n    beforeEventDragStart() {}\n\n    // Called after event drag starts\n    afterEventDragStart() {}\n\n    // Called after aborting a drag\n    afterEventDragAbortFinalized() {}\n\n    // Called during event drag validation\n    checkEventDragValidity() {}\n\n    // Called after event resizing starts\n    afterEventResizeStart() {}\n\n    //endregion\n\n    //region Scheduler specific date mapping functions\n\n    get hasEventEditor() {\n        const {\n            eventEdit,\n            taskEdit,\n            simpleEventEdit\n        } = this.features;\n\n        return Boolean(\n            eventEdit?.enabled || taskEdit?.enabled || simpleEventEdit?.enabled\n        );\n    }\n\n    // Method is chained by event editing features. Ensure that the event is in the store.\n    editEvent(eventRecord, resourceRecord, element) {\n        const\n            me = this,\n            {\n                eventStore,\n                assignmentStore\n            } = me;\n\n        // Abort the chain if no event editing features available\n        if (!me.hasEventEditor) {\n            return false;\n        }\n\n        if (eventRecord.eventStore !== eventStore) {\n            const\n                { enableEventAnimations } = me,\n                resourceRecords           = [];\n\n            // It's only a provisional event because we are going to edit it which will\n            // allow an opportunity to cancel the add (by removing it).\n            eventRecord.isCreating = true;\n\n            let assignmentRecords = [];\n\n            if (resourceRecord) {\n                resourceRecords.push(resourceRecord);\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n\n            // Vetoable beforeEventAdd allows cancel of this operation\n            if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n                // Remove any assignment created above, to leave store as it was\n                assignmentStore?.remove(assignmentRecords);\n\n                return false;\n            }\n\n            me.enableEventAnimations = false;\n            eventStore.add(eventRecord);\n            me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n\n            // Element must be created synchronously, not after the project's normalizing delays.\n            me.refreshRows();\n        }\n    }\n\n    /**\n     * Creates an event on the specified date, for the specified resource which conforms to this\n     * scheduler's {@link #config-createEventOnDblClick} setting.\n     *\n     * NOTE: If the scheduler is readonly, or resource type is invalid (group header), or if `allowOverlap` is `false`\n     * and slot is already occupied - no event is created.\n     *\n     * This method may be called programmatically by application code if the `createEventOnDblClick` setting\n     * is `false`, in which case the default values for `createEventOnDblClick` will be used.\n     *\n     * If the {@link Scheduler.feature.EventEdit} feature is active, the new event\n     * will be displayed in the event editor.\n     * @param {Date} date The date to add the event at.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource to create the event for.\n     * @category Scheduled events\n     */\n    async createEvent(startDate, resourceRecord) {\n        const\n            me                    = this,\n            {\n                enableEventAnimations,\n                features,\n                eventStore,\n                assignmentStore\n            }                     = me,\n            resourceRecords       = [resourceRecord],\n            useEventModelDefaults = me.createEventOnDblClick.useEventModelDefaults,\n            defaultDuration       = useEventModelDefaults ? eventStore.modelClass.defaultValues.duration : 1,\n            defaultDurationUnit   = useEventModelDefaults ? eventStore.modelClass.defaultValues.durationUnit : me.timeAxis.unit,\n            eventRecord           = eventStore.createRecord({\n                startDate,\n                endDate      : DateHelper.add(startDate, defaultDuration, defaultDurationUnit),\n                duration     : defaultDuration,\n                durationUnit : defaultDurationUnit,\n                name         : me.L('L{Object.newEvent}')\n            }),\n            eventEditAvailable    = Boolean(features.eventEdit?.enabled || features.taskEdit?.enabled || features.simpleEventEdit?.enabled);\n\n        if (me.readOnly || resourceRecord.isSpecialRow || (!me.allowOverlap && !me.isDateRangeAvailable(\n            eventRecord.startDate,\n            eventRecord.endDate,\n            null,\n            resourceRecord\n        ))) {\n            return;\n        }\n\n        // It's only a provisional event if there is an event edit feature available to\n        // cancel the add (by removing it). Otherwise it's a definite event creation.\n        eventRecord.isCreating = eventEditAvailable;\n\n        me.onEventCreated(eventRecord);\n\n        const assignmentRecords = assignmentStore?.assignEventToResource(eventRecord, resourceRecord);\n\n        /**\n         * Fires before an event is added. Can be triggered by schedule double click or drag create action.\n         * @event beforeEventAdd\n         * @param {Scheduler.view.Scheduler} source The Scheduler instance\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be added\n         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records\n         * @preventable\n         */\n        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            // Remove any assignment created above, to leave store as it was\n            assignmentStore?.remove(assignmentRecords);\n\n            return;\n        }\n\n        me.enableEventAnimations = false;\n        eventStore.add(eventRecord);\n        me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        me.isCreating = true;\n        me.refreshRows();\n        me.isCreating = false;\n\n        /**\n         * Fired when a double click or drag gesture has created a new event and added it to the event store.\n         * @event eventAutoCreated\n         * @param {Scheduler.view.Scheduler} source This Scheduler.\n         * @param {Scheduler.model.EventModel} eventRecord The new event record.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The resource assigned to the new event.\n         */\n        me.trigger('eventAutoCreated', {\n            eventRecord,\n            resourceRecord\n        });\n\n        if (eventEditAvailable) {\n            me.editEvent(eventRecord, resourceRecord, me.getEventElement(eventRecord));\n        }\n    }\n\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Dates\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);\n    }\n    //endregion\n\n    /**\n     * Suspends UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * @function suspendRefresh\n     * @category Rendering\n     */\n\n    /**\n     * Resumes UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * Specify `true` as the first param to trigger a refresh if this call unblocked the refresh suspension.\n     * If the underlying project is calculating changes, the refresh will be postponed until it is done.\n     *\n     * @param {Boolean} trigger `true` to trigger a refresh, if this resume unblocks suspension\n     * @category Rendering\n     */\n    async resumeRefresh(trigger) {\n        super.resumeRefresh(false);\n\n        const me = this;\n\n        if (!me.refreshSuspended && trigger) {\n            // Do not refresh until project is in a valid state\n            if (!me.isEngineReady) {\n                // Refresh will happen because of the commit, bail out of this one after forcing rendering to consider\n                // next one a full refresh\n                me.currentOrientation.refreshAllWhenReady = true;\n                return me.project.commitAsync();\n            }\n\n            // View could've been destroyed while we waited for engine\n            if (!me.isDestroyed) {\n                // If it already is, refresh now\n                me.refreshWithTransition();\n            }\n        }\n    }\n\n    //region Appearance\n\n    // Overrides grid to take crudManager loading into account\n    toggleEmptyText() {\n        const\n            me = this;\n\n        if (me.bodyContainer) {\n            DomHelper.toggleClasses(me.bodyContainer, 'b-grid-empty', !(me.resourceStore.count > 0 || me.crudManager?.isLoading));\n        }\n    }\n\n    // Overrides Grids base implementation to return a correctly calculated height for the row. Also stores it in\n    // RowManagers height map, which is used to calculate total height etc.\n    getRowHeight(resourceRecord) {\n        if (this.isHorizontal) {\n            const height = this.currentOrientation.calculateRowHeight(resourceRecord);\n            this.rowManager.storeKnownHeight(resourceRecord.id, height);\n            return height;\n        }\n    }\n\n    // Calculates the height for specified rows. Call when changes potentially makes its height invalid\n    calculateRowHeights(resourceRecords, silent = false) {\n        // Array allowed to have nulls in it for easier code when calling this fn\n        resourceRecords.forEach(resourceRecord => resourceRecord && this.getRowHeight(resourceRecord));\n\n        if (!silent) {\n            this.rowManager.estimateTotalHeight(true);\n        }\n    }\n\n    // Calculate heights for all rows (up to the preCalculateHeightLimit)\n    calculateAllRowHeights(silent = false) {\n        const\n            { store, rowManager } = this,\n            count                 = Math.min(store.count, this.preCalculateHeightLimit);\n\n        // Allow opt out by specifying falsy value.\n        if (count) {\n            rowManager.clearKnownHeights();\n\n            for (let i = 0; i < count; i++) {\n                // This will both calculate and store the height\n                this.getRowHeight(store.getAt(i));\n            }\n\n            // Make sure height is reflected on scroller etc.\n            if (!silent) {\n                rowManager.estimateTotalHeight(true);\n            }\n        }\n    }\n\n    //endregion\n\n    //region Calendar Mode Interface\n\n    // These are all internal and match up w/CalendarMixin\n\n    /**\n     * Returns the date or ranges of included dates as an array. If only the {@link #config-startDate} is significant,\n     * the array will have that date as its only element. Otherwise, a range of dates is returned as a two-element\n     * array with `[0]` is the {@link #config-startDate} and `[1]` is the {@link #property-lastDate}.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        const\n            me  = this,\n            ret = [me.startDate];\n\n        if (me.range === 'week') {\n            ret.push(me.lastDate);\n        }\n\n        return ret;\n    }\n\n    get defaultDescriptionFormat() {\n        return descriptionFormats[this.range];\n    }\n\n    /**\n     * The last day that is included in the date range. This is different than {@link #config-endDate} since that date\n     * is not inclusive. For example, an `endDate` of 2022-07-21 00:00:00 indicates that the time range ends at that\n     * time, and so 2022-07-21 is _not_ in the range. In this example, `lastDate` would be 2022-07-20 since that is the\n     * last day included in the range.\n     * @member {Date}\n     * @internal\n     */\n    get lastDate() {\n        const lastDate = this.endDate;\n\n        // endDate is \"exclusive\" because it means 00:00:00 of that day, so subtract 1\n        // to keep description consistent with human expectations.\n        return lastDate && DateHelper.add(lastDate, -1, 'day');\n    }\n\n    getEventRecord(target) {\n        target = DomHelper.getEventElement(target);\n\n        return this.resolveEventRecord(target);\n    }\n\n    getEventElement(eventRecord) {\n        return this.getElementFromEventRecord(eventRecord);\n    }\n\n    changeRange(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n\n    updateRange(unit) {\n        if (!this.isConfiguring) {\n            const\n                currentDate = this.date,\n                newDate     = this.date = DateHelper.startOf(currentDate, unit);\n\n            // Force a span update if changing the range did not change the date\n            if (currentDate.getTime() === newDate.getTime()) {\n                this.updateDate(newDate);\n            }\n        }\n    }\n\n    changeStepUnit(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n\n    updateDate(newDate) {\n        const\n            me    = this,\n            start = DateHelper.startOf(newDate, me.range);\n\n        me.setTimeSpan(start, DateHelper.add(start, 1, me.range));\n\n        // Cant always use newDate here in case timeAxis is filtered\n        me.visibleDate = {\n            date    : DateHelper.max(newDate, me.timeAxis.startDate),\n            block   : 'start',\n            animate : true\n        };\n\n        me.trigger('descriptionChange');\n    }\n\n    previous() {\n        this.date = DateHelper.add(this.date, -1, this.stepUnit);\n    }\n\n    next() {\n        this.date = DateHelper.add(this.date, 1, this.stepUnit);\n    }\n\n    //endregion\n\n    /**\n     * Assigns and schedules an unassigned event record (+ adds it to this Scheduler's event store unless already in it).\n     * @param {Object} config The config containing data about the event record to schedule\n     * @param {Date} config.startDate The start date\n     * @param {Scheduler.model.EventModel|EventModelConfig} config.eventRecord Event (or data for it) to assign and schedule\n     * @param {Scheduler.model.EventModel} [config.parentEventRecord] Parent event to add the event to (to nest it),\n     * only applies when using the NestedEvents feature\n     * @param {Scheduler.model.ResourceModel} config.resourceRecord Resource to assign the event to\n     * @param {HTMLElement} [config.element] The element if you are dragging an element from outside the scheduler\n     * @category Scheduled events\n     */\n    async scheduleEvent({ startDate, eventRecord, resourceRecord, element }) {\n        const me = this;\n\n        // NestedEvents has an override for this function to handle parentEventRecord\n\n        if (!me.eventStore.includes(eventRecord)) {\n            [eventRecord] = me.eventStore.add(eventRecord);\n        }\n\n        eventRecord.startDate = startDate;\n        eventRecord.assign(resourceRecord);\n\n        if (element) {\n            const eventRect = Rectangle.from(element, me.foregroundCanvas);\n\n            // Clear translate styles used by DragHelper\n            DomHelper.setTranslateXY(element, 0, 0);\n            DomHelper.setTopLeft(element, eventRect.y, eventRect.x);\n\n            DomSync.addChild(me.foregroundCanvas, element, eventRecord.assignments[0].id);\n        }\n\n        await me.project.commitAsync();\n    }\n\n    // This GridSelection override disables drag-selection in timeaxis column for scheduler\n    onSelectionDrag(event) {\n        if (event.target.classList.contains('b-timeaxis-cell')) {\n            return;\n        }\n        super.onSelectionDrag(event);\n    }\n}\n\n// Register this widget type with its Factory\nSchedulerBase.initClass();\n\n// Scheduler version is specified in TimelineBase because Gantt extends it\n"],"names":["VerticalTimeAxis","TimeAxisBase","$name","configurable","cls","sizeProperty","positionProperty","wrapText","buildHorizontalCells","me","this","client","stickyHeaders","featureHeaderConfigs","cellConfigs","levels","reduce","result","level","i","_level$cells","cells","push","filter","cell","start","endDate","end","startDate","map","j","role","className","headerCellCls","align","length","dataset","_objectSpread","tickIndex","index","cellId","headerPosition","globalThis","DEBUG","date","getTime","style","top","coord","height","width","minHeight","children","html","value","getHeaderDomConfigs","widgetClassList","headerFeature","syncOptions","releaseThreshold","syncIdField","size","_$name","VerticalTimeAxisColumn","Column","type","defaults","draggable","groupable","hideable","showColumnPicker","filterable","sortable","searchable","editor","enableCellContextMenu","tooltipRenderer","minWidth","resizable","cellCls","flex","alwaysClearCell","isFocusable","construct","data","super","arguments","view","model","grid","timeAxisViewModel","renderer","cellElement","render","getCurrentConfig","options","id","region","field","ariaLabel","cellAriaLabel","_defineProperty","ColumnStore","registerColumnType","HorizontalLayout","Base","defaultConfig","nbrOfBandsByResource","bandIndexToPxConvertFn","bandIndexToPxConvertThisObj","clearCache","resource","applyLayout","events","layoutEventsInBands","Error","HorizontalLayoutPack","mixin","PackMixin","packEventsInBands","event","slot","slotSize","forEach","Object","assign","call","eventRecord","resourceRecord","HorizontalLayoutStack","heightRun","verticalPosition","eventIndex","splice","findClosestSuccessor","eventRenderData","endMS","group","isMilestone","duration","closest","gap","minGap","Infinity","l","startMS","grouped","ResourceTimeRangesBase","InstancePlugin","AttachToProjectMixin","pluginConfig","chain","override","noFeatureElementsInAxis","timeAxis","needsRefresh","store","storage","values","some","t","isTimeSpanInAxis","doDisable","disable","isPainted","refresh","updateTabIndex","isConfiguring","getEventsToRender","onEventDataGenerated","renderData","iconCls","shouldInclude","isVertical","columnWidth","resourceColumnWidth","fillSize","wrapperCls","rangeCls","timeRangeColor","eventContent","text","name","tabIndex","String","unshift","tag","toString","eventId","generateElementId","record","domId","resolveResourceTimeRangeRecord","rangeElement","_rangeElement$closest","elementData","getElementFromResourceTimeRangeRecord","foregroundCanvas","syncIdMap","resolveResourceRecord","_this$resolveResource","overridden","target","onStoreChange","action","onInternalEventStoreChange","featureClass","DependencyEditor","Popup","items","handleSelector","axisLock","processWidgetConfig","widget","dependencyEditFeature","ref","showLagField","showDeleteButton","afterShow","args","deleteButton","widgetMap","hidden","isPartOfStore","onInternalKeyDown","trigger","DependencyEdit","autoClose","saveAndCloseOnEnter","triggerEvent","dependencyRecord","editorConfig","title","localeClass","closable","fromNameField","weight","label","toNameField","typeField","editable","valueField","displayField","localizeDisplayFields","buildItems","dialog","parent","keys","DependencyModel","Type","L","localeKey","lagField","allowNegative","bbar","foo","saveButton","color","cancelButton","config","dependencyEdit","features","dependencies","clientListenersDetacher","ion","onActivateEditor","thisObj","doDestroy","_this$editor","destroy","changeEditorConfig","ObjectHelper","owner","autoShow","anchor","scrollAction","clippedBy","timeAxisSubGridElement","bodyContainer","constrainTo","isValid","every","eachWidget","onBeforeSave","onAfterSave","updateRecord","lag","lagUnit","unit","magnitude","fromSide","toSide","cleanupProperties","set","onPopupKeyDown","key","tagName","toLowerCase","preventDefault","onSaveClick","save","hide","onDeleteClick","deleteDependency","onCancelClick","internalShowEditor","showPoint","lastPointerDownCoordinate","getEditor","loadRecord","center","Rectangle","from","element","x","y","showBy","editDependency","readOnly","_me$saveButton","_me$deleteButton","_me$cancelButton","new","rootElement","internalListeners","keydown","console","warn","click","dependency","fromEvent","toEvent","Duration","dependencyStore","_client$project","stores","add","project","commitAsync","_client$project2","containsFocus","revertFocus","remove","disabled","clientX","clientY","GridFeatureManager","registerFeature","ScheduleContext","Delayable","listeners","datachange","timeaxisviewmodelupdate","presetchange","timelineContextChange","schedulecontextmenu","useBackgroundCanvas","rowManager","rowheight","changeTriggerEvent","_element","DomHelper","createElement","backgroundCanvas","onTimelineContextChange","context","onScheduleContextGesture","onTimeAxisViewModelUpdate","source","_this$context","includes","tick","syncContextElement","clearContext","updateContext","oldContext","enabled","row","rows","getRowFor","tickStartDate","tickEndDate","currentOrientation","getTimeSpanRenderData","startDateMS","endDateMS","resourceWidth","display","setTranslateXY","left","innerHTML","callback","$config","equal","c1","c2","tickParentIndex","EventCopyPaste","constructor","scheduler","eventclick","onEventClick","scheduleclick","onScheduleClick","projectChange","clearClipboard","_cellClickedContext","eventData","assignmentRecord","meta","isCut","isActionAvailable","keyCombination","_this$client$focusedC","cellEdit","getSelection","isEditing","Boolean","focusedCell","isSpecialRow","copy","copyEvents","cut","undefined","paste","pasteEvents","records","selectedAssignments","entityName","assignmentRecords","slice","isEventModel","r","assignments","flat","a","eventRecords","_isCut","clipboard","assignmentStore","assignment","refreshWithTransition","$original","toFocus","pastedEvents","Set","targetResourceRecord","targetDate","has","eventStore","usesSingleAssignment","copyPasteAction","generateNewName","last","resources","newAssignmentRecord","constraintDate","detacher","renderEvent","navigateTo","scrollIntoView","populateEventMenu","copyEvent","icon","onItem","concat","rec","cutEvent","populateScheduleMenu","pasteEvent","resourceStore","count","originalName","nameField","counter","findRecord","keyMap","EventDrag","DragBase","constrainDragToResource","constrainDragToTimeSlot","externalDropTargetSelector","validatorFn","validatorFnThisObj","unifiedDrag","snapToPosition","copyKey","copyMode","mode","capitalizedEventName","afterConstruct","changeMode","dragData","isRecurring","updateMode","setCopying","setMoving","eventBarCopies","el","isConnected","classList","grabbedParent","appendChild","retainElement","onAfterDragStart","handleKeyDownOrMove","keyEventDetacher","EventHelper","on","getRootElement","keyup","handleKeyUp","onDragReset","_this$keyEventDetache","onDrop","_this$dragData$eventB","getDraggableElement","drag","targetSelector","resolveEventRecord","eventElement","isElementDraggable","_client","matches","isDraggable","getTriggerParams","browserEvent","domEvent","triggerBeforeEventDrag","eventType","triggerEventDrag","newResource","triggerDragStart","navigator","skipNextClick","triggerDragAbort","triggerDragAbortFinalized","triggerAfterDrop","valid","currentOverClient","initialAssignmentsState","find","_me$dragData$assignme","resourceId","setTimeout","specialKeyFromEventKey","isValidDrop","sourceRecord","draggedEntities","constrainDragToTimeline","checkDragValidity","_dragData$newResource","_scheduler$checkEvent","_scheduler$checkEvent2","allowOverlap","isDateRangeAvailable","message","updateRecords","fromScheduler","toScheduler","copyKeyPressed","externalDropTarget","suspendAutoCommit","updateAssignments","resumeAutoCommit","isCopy","targetEventRecord","isCrossScheduler","fromAssignmentStore","fromEventStore","toAssignmentStore","toEventStore","fromResourceStore","toResourceStore","timeDiff","fromResource","toResource","useSingleAssignment","event1Date","adjustStartDate","eventsToAdd","eventsToRemove","assignmentsToAdd","assignmentsToRemove","eventsToCheck","eventsToBatch","resourcesInStore","getAllDataRecords","suspendRefresh","indexDiff","updated","updatedEvent","indexOf","constainDragToResource","isGrouped","draggedEvent","eventBar","eventBarEls","instanceMeta","hasTemporaryDragElement","transient","addedEvents","copiedAssignmentsMap","originalAssignment","draggedAssignment","isOccurrenceAssignment","initialState","originalEventRecord","originalStartDate","originalResourceRecord","newStartDate","keepEvent","newAssignment","getById","createRecord","calendar","reassignedFrom","draggedEventResourceIndex","getAt","_newResource","newIndex","Math","max","min","getNext","getPrevious","isEvent","isOccurrence","ev","DateHelper","isEqual","isBatchUpdating","endBatch","processEventDrop","relatedElements","entries","originalId","cloneRecord","originalDraggedEvent","inTimeAxis","isInTimeAxis","DomSync","removeChild","parentElement","isRoot","elRect","setTopLeft","addChild","processCrossSchedulerEventDrop","added","beginBatch","Promise","all","resumeRefresh","fillTicks","lastDomConfig","selectedEvents","getProductDragContext","previousResolvedResource","previousTargetEventRecord","resolveResource","isOverNewResource","dirty","proxyElements","getMinimalDragData","info","getElementFromContext","resolveAssignmentRecord","isAssignmentSelected","startEvent","ctrlKey","apply","getRelatedRecords","setupProductDragData","_dateConstraints","dateConstraints","_me$getDateConstraint","getDateConstraints","constrainRectangle","getConstrainingRectangle","eventRegion","setupConstraints","snapPixelAmount","eventBarEl","getElementFromAssignmentRecord","addTemporaryDragElement","createProxy","_scheduler$getDateCon","externalDateConstraints","minDate","maxDate","dateRange","getScheduleRegion","getDragData","selectedRecord","getCoordinate","isHorizontal","milestoneLayoutMode","milestoneAlign","offsetWidth","offsetHeight","dragProxy","pageRect","localRect","lx","ly","eventTarget","getMouseMoveEventTarget","contains","getRowAt","dataIndex","querySelector","roundDate","Date","snapRelativeToEventStartDate","getRecordElement","getProxyElement","isDragging","EventDragCreate","DragCreateBase","updateLockLayout","lock","dragActiveCls","handleBeforeDragCreate","isSchedulerPro","ignoreResourceCalendar","isWorkingTime","mousedownDate","dragStart","_client$onEventCreate","enableEventAnimations","createEventRecord","resourceRecords","diff","durationUnit","isCreating","isDragCreating","taskEdit","doCancel","assignEventToResource","lockLayout","excludeFromLayout","onEventCreated","addAsync","then","refreshRows","itemElement","getElementFromEventRecord","isInView","scrollable","animate","edgeOffset","barMargin","checkValidity","dragging","createValidatorFn","isRowEmpty","getEventsForResource","triggerBeforeFinalize","dimension","weekStartDay","draggingEnd","eventConfig","modelClass","fieldMap","defaultValue","floor","resolution","ceil","isGanttProjectMixin","constraintType","finalizeDragCreate","hasEventEditor","getTipHtml","tip","toggle","tooNarrow","onAborted","_this$store$unassignE","_this$store","unassignEventFromResource","EventTooltip","TooltipBase","template","StringHelper","xss","startClockHtml","endClockHtml","monitorRecordUpdate","onPaint","firstPaint","configuredOffset","offset","tooltip","beforeShow","zeroMargins","StickyEvents","toUpdate","scroll","horizontalScroll","prio","stickyContents","syncEventContentPosition","updateStyles","onSchedulerScroll","verticalSyncAllEventsContentPosition","onHorizontalScroll","subGrid","timeAxisSubGrid","contentEl","applyStyle","clear","resourceMap","eventsData","elementConfig","isResourceTimeRange","duringGeneration","useEventBuffer","bufferAfterWidth","bufferBeforeWidth","scrollPosition","wrapperEl","getChild","parseStyle","contentSize","contentWidth","c","parentNode","getStyleValue","eventStart","eventEnd","edgeSizes","getEventContentMargins","maxOffset","Number","MAX_SAFE_INTEGER","transform","stuck","getEdgeSize","TimeRanges","AbstractTimeRanges","_this$storeDetacher","storeDetacher","timeRanges","_timeRanges","recurringEvents","flatMap","timeSpan","getOccurrencesForDateRange","currentTimeLine","attachToProject","_me$projectTimeZoneCh","_me$client$project","projectTimeZoneChangeDetacher","showCurrentTimeLine","timeZoneChange","updateCurrentTimeLine","initCurrentTimeLine","currentTimeInterval","setInterval","currentTimeLineUpdateInterval","_me$project","_inTimeZone","timeZone","setLocalDate","originalData","format","currentDateFormat","renderRanges","hideCurrentTimeLine","clearInterval","updateShowCurrentTimeLine","show","populateTimeAxisHeaderMenu","column","checked","onToggle","attachToStore","change","timeRangeStore","updateStore","_timeRangesExposed","attachToTimeRangeStore","resolveTimeRangeRecord","baseSelector","isVisible","runWithTransition","refreshSuspended","onDragStart","rangeBodyEl","getBodyElementByRecord","originRangeX","getTranslateX","originRangeY","getTranslateY","showTip","onInvalidDrop","box","newStart","getDateFromCoordinate","getStart","rtl","setStartDate","destroyTip","onResizeStart","onResizeDrag","edge","setTranslateY","newY","newHeight","setTranslateX","newX","newWidth","onResize","startPos","endPos","getEnd","isStart","newEnd","setEndDate","onInvalidResize","resize","reset","TimeSpan","Target","returnWrapper","_this$foregroundCanva","_wrapper","_wrapper$syncIdMap","wrapper","hasLinks","link","$links","_this$foregroundCanva2","_eventRecord$resource","_this$foregroundCanva3","getAssignmentForEventAndResource","getElementsFromEventRecord","elementOrEvent","xy","resolveRowRecord","_elementOrEvent","Event","eventSelector","assignmentId","resolveTimeSpanRecord","getOccurrence","isRowVisible","widgetClass","getTimeSpanMouseEventParams","getScheduleMouseEventParams","cellData","onElementKeyDown","scheduledEventName","onElementKeyUp","milestoneTextPosition","milestoneCharWidth","eventLayout","overlappingEventSorter","horizontalEventSorterFn","resourceMargin","useInitialAnimation","eventRenderer","eventRendererThisObj","eventBarTextField","eventBodyTemplate","horizontalLayoutPackClass","horizontalLayoutStackClass","resourceColumns","resourceImagePath","defaultResourceImageName","resourceImageExtension","isFirstRender","initialAnimationDuration","narrowEventWidth","internalEventLayout","eventPositionMode","eventScrollMode","changeEventLayout","changeInternalEventLayout","getEventLayout","updateInternalEventLayout","oldEventLayout","changeHorizontalEventSorterFn","fn","VersionHelper","deprecate","updateOverlappingEventSorter","_value","isModel","getEventLayoutHandler","horizontal","layouts","horizontalStack","layoutEventVerticallyStack","horizontalPack","layoutEventVerticallyPack","_this$timeAxisColumn","timeAxisColumn","_resourceColumns","_this$resourceColumns","repaintEventsForResource","repaintEvent","getResourcesForEvent","getResourceMargin","_resourceRecord$resou","getBarMargin","_resourceRecord$barMa","getResourceHeight","_resourceRecord$rowHe","rowHeight","getResourceWidth","_resourceRecord$colum","getAppliedResourceHeight","_row$maxRequestedHeig","getRowById","maxRequestedHeight","getResourceLayoutSettings","parentEventRecord","contentHeight","getEventStyle","eventStyle","getEventColor","_eventRecord$event","_eventRecord$parent","eventColor","generateRenderData","includeOutside","viewport","eventResize","$originalId","taskBarFeature","_renderData$iconCls2","isResizable","startsOutsideView","endsOutsideView","leftHandle","rightHandle","topHandle","bottomHandle","isDirty","hasPersistableChanges","clsListObj","generatedIdCls","hasGeneratedId","dirtyCls","committingCls","isCommitting","endsOutsideViewCls","startsOutsideViewCls","clippedStart","clippedEnd","wrapperClsListObj","eventCls","isParent","isLinked","clsList","DomClassList","internalCls","clone","wrapperClsList","wrapperStyle","isWrap","selected","fixedEventCls","eventSelectedCls","eventAssignHighlightCls","isEventSelected","inactive","hasAnimation","bryntum","noAnimations","delayMS","scrollTop","tickSize","maxDelay","initialAnimationDetacher","delegate","once","animationend","delay","cancelOutstanding","expires","alt","get","eventBarIconClsField","rowId","childContent","milestoneLabelConfig","rendererValue","encodeHtml","_renderData$iconCls","Array","isArray","isHtml","class","isNamedColor","colorProp","wrapperChildren","changeUseInitialAnimation","updateUseInitialAnimation","old","BrowserHelper","isFirefox","restartInitialAnimation","initialAnimation","_me$initialAnimationD","stopInitialAnimation","getMilestoneLabelWidth","milestoneMeasureElement","fontSize","firstElementChild","bounds","milestoneWidth","updateMilestoneLayoutMode","alwaysOutside","updateMilestoneTextPosition","position","updateMilestoneAlign","updateMilestoneCharWidth","ProjectConsumer","projectStores","dataName","batchedUpdate","changePreCommit","commitStart","commit","exception","idchange","beforeLoad","beforeRemove","calendarManagerStore","resourceTimeRangeStore","startParamName","endParamName","passStartEndParameters","crudManagerClass","crudManager","updateProject","oldProject","detachListeners","onProjectRefresh","isInitialCommit","refreshAfterProjectRefresh","navigateToAfterRefresh","whenVisible","changeCrudManager","isCrudManager","_crudManager","bindCrudManager","_store","Store","refreshFromRowOnStoreAdd","isExpand","suspended","onStoreAdd","calculateRowHeights","onStoreUpdateRecord","changes","ignoreCount","updateResourceStore","metaMapId","usesDisplayStore","onEventIdChange","params","onEventStoreIdChange","onEventStoreBatchedUpdate","listenToBatchedUpdates","_mode","isAssign","isRemovingAssignment","onEventStoreChange","onEventCommit","resourcesToRepaint","modified","prototype","onEventCommitStart","toggleCls","onEventException","removed","onAssignmentCommit","repaintEventsForAssignmentChanges","onAssignmentCommitStart","onAssignmentException","getResource","onAssignmentBeforeRemove","removingAll","moveTo","activeAssignment","GlobalEvents","lastInteractionType","next","focusWithoutScrolling","focusElement","resourceTimeRanges","applyStartEndParameters","print","getResourcesEventsPerTick","filterFn","eventsByTick","startTick","getTickFromDate","endTick","ticks","defaultScrollOptions","block","unrenderedScrollOptions","highlight","focus","scrollEventIntoView","scrollResourceEventIntoView","scrollAssignmentIntoView","eventIsOutside","isScheduled","extendTimeAxis","currentTimeSpanRange","setTimeSpan","valueOf","_me$expandTo","tree","expandTo","scroller","forceScrollUpdate","isAvailable","scrollUnrenderedEventIntoView","scrollResourceIntoView","resourceRec","eventRec","resolve","modifiedOptions","getResourceEventBox","scrollerViewport","translate","totalSize","scrollLeft","async","targetElement","initialScrollPromise","scrollRowIntoView","local","getResourceRegion","getRowRegion","getAssignmentEventBox","includesOutside","roughly","getItemBox","copyProperties","getState","applyState","state","_state$zoomLevelOptio","propsToCopy","zoomLevelOptions","p","releaseEventActions","releaseElement","reuseElement","renderEventActions","newElement","reuseOwnElement","heightEventSorter","lhs","rhs","chronoFields","getStartEnd","useEnd","fieldName","_eventRecord$hasBatch","hasBatchedChange","isResizing","round","HorizontalRendering","scrollBuffer","bufferSize","verticalBufferSize","properties","Map","rowMap","eventConfigs","isFirstRefresh","toDrawOnProjectRefresh","toDrawOnDataReady","eventSorter","bind","renderDone","removeRows","translateRow","offsetRows","beforeRowHeight","init","updateVerticalBufferSize","renderRows","visibleDateRange","_visibleDateRange","getDateFromXY","roundingMethod","allowOutOfRange","translateToScheduleCoordinate","getRtlX","getDateFromPosition","getBoundingClientRect","scrollX","maxX","abs","translateToPageCoordinate","stretch","getElement","bottom","scrollWidth","taStart","taEnd","startX","getCoordinateFromDate","endX","right","rowRecord","resourceData","approx","d","rowBox","getRecordCoords","absoluteTop","layout","rowTop","rowBottom","nodeType","Element","TEXT_NODE","eventNode","getRecordFromElement","refreshAllWhenReady","clearAll","clearDom","commitFinalized","onProjectCommitFinalized","ignoreRecordChanges","clearResources","refreshResources","isCalculated","calculateAllRowHeights","topRow","reinitialize","attachToAssignmentStore","refreshPreCommit","onAssignmentStoreChange","replaced","resourceIds","_assignmentRecord$res","_assignmentRecord$res2","_assignmentRecord$res3","isRemoving","isChangingId","refreshResourcesWhenReady","oldAssignment","oldValue","refreshResourcesOnDataReady","onAssignmentStoreRefresh","attachToEventStore","onEventStoreRefresh","isEngineReady","isResourceTimeRangeStore","_eventRecord$$linkedR","renderedEventResources","$linkedResources","newEvent","allChrono","$entity","getField","dateChanges","_me$project2","propagatingLoadChanges","isWritingData","attachToResourceStore","clearLayoutCache","onResourceStoreChange","isBatchingChanges","isLeaf","onTranslateRow","refreshEventsForResource","onOffsetRows","doUpdateTimeView","calculateRowHeight","_resourceRecord$assig","assigned","eventFilter","isFiltered","getEvents","includeOccurrences","enableRecurringEvents","sort","layoutHandler","nbrOfBandsRequired","updateFromHorizontalScroll","getConnectorStartSide","getConnectorEndSide","reLayoutEvents","onLocaleChange","onViewportResize","oldWidth","oldHeight","onRenderDone","onDragAbort","useWrapper","onRemoveRows","delete","onEarlyScroll","rendererCalled","updateFromVerticalScroll","fromScroll","returnEnd","getDateFromCoord","ignoreRTL","_viewPresetChanging","viewportCoords","range","timeView","onVisibleDateRangeChange","onBeforeRowHeightChange","ids","transition","noRows","bandIndex","topFraction","heightFraction","domConfig","syncId","innerElement","firstChild","b","startA","dataStartMS","endA","dataEndMS","startB","endB","nameA","nameB","calculateMS","startDateField","endDateField","durationMS","pxPerMinute","getSingleUnitInPixels","setupRenderData","_scheduler$features$e","preamble","postamble","isProHorizontalRendering","eventBuffer","timespanStart","timespanEnd","viewStartMS","viewEndMS","taskRecord","fillTimeSpanHorizontalPosition","calculateHorizontalPosition","respectExclusion","isEnd","snapToNextIncluded","isSafari","stickyEvents","excluded","fillTimeSpanVerticalPosition","managedEventSizing","includeOutsideTimeAxis","includeOutsideViewport","layoutEvents","allEvents","eventBox","layoutEventData","bandsRequired","layoutResourceEvents","resourceEvents","layoutMode","textPosition","eventElementConfig","taskFeature","zIndex","recordOrRow","force","draw","isRow","getResourceLayout","resourceLayout","invalid","getEventDOMConfigForCurrentView","labels","usesLabels","before","after","reusableDOMConfigs","eventDOMConfigs","useLeft","useRight","prevDomConfig","_scheduler$_scrollTop","visibleEventDOMConfigs","bodyTop","_scrollTop","viewTop","viewBottom","_bodyRectangle","unbuffered","unmanagedSize","sync","onlyChildren","jsx","_scheduler$processEve","_domConfig$elementDat","reactComponent","isRelease","isRender","processEventContent","_scheduler$processEve2","getActiveElement","isReusingElement","isRepaint","recordsOrIds","ArrayHelper","asArray","Model","asId","cached","child","VerticalLayout","coordProp","sizeProp","columnIndex","layoutType","tplData","clusterIndex","widthFactor","leftFactor","packColumnCount","packColumnIndex","availableWidth","emptyObject","freeze","VerticalRendering","eventMap","releasedElements","resourceBufferSize","verticalLayout","columnWidthChange","initialized","coords","borderOffsetX","borderOffsetY","variableColumnWidths","totalWidth","col","allResourceRecords","_this$eventMap$get","scrollY","_this$eventMap$get2","_this$eventMap$get3","_this$eventMap$get3$r","layoutResource","startY","endY","scrollPos","clientHeight","onResourceColumnWidthChange","rendered","refreshAllResourcesWhenReady","changeCount","load","unmaskBody","firstResource","lastResource","_allResourceRecords","onResourceStoreRefresh","refreshFromRerender","renderResource","prevScrollX","scrollHorizontallyTo","_this$scheduler$timeA","updateElementId","releaseTimeSpanDiv","resourceRange","getResourceRange","visibleResources","first","withBuffer","viewportStart","viewportEnd","insetStart","bottomDate","bodyHeight","virtualScrollHeight","scrollHeight","topDate","isProVerticalRendering","dataStartMs","dataEndMs","cache","resourceIndex","layoutData","toLayout","getMapPath","internalStyle","topDateMS","bottomDateMS","resourceEntry","_eventData$elementCon","isEventElement","syncConfigs","featureDomConfigs","getForegroundDomConfigs","isReleased","reusingElement","onVisibleResourceRangeChange","descriptionFormats","month","week","day","SchedulerBase","TimelineBase","CrudManagerView","Describable","SchedulerDom","SchedulerDomEvents","SchedulerStores","SchedulerScroll","SchedulerState","SchedulerEventRendering","SchedulerRegions","EventSelection","EventNavigation","CurrentConfig","stepUnit","verticalTimeAxisColumn","createEventOnDblClick","schedulableAreaSelector","sortFeatureStore","timeCellCls","overScheduledEventClass","preCalculateHeightLimit","CrudManager","testConfig","loadMaskError","showDelay","scheduledblclick","onTimeAxisCellDblClick","onPaintOverride","_me$firstVisibleRow","_me$lastVisibleRow","firstVisibleRow","lastVisibleRow","createEvent","onVerticalScroll","vertical","onElementMouseOver","onElementMouseOut","beforeEventDragStart","afterEventDragStart","afterEventDragAbortFinalized","checkEventDragValidity","afterEventResizeStart","eventEdit","simpleEventEdit","editEvent","_features$eventEdit","_features$taskEdit","_features$simpleEvent","useEventModelDefaults","defaultDuration","defaultValues","defaultDurationUnit","eventEditAvailable","getEventElement","excludeEvent","isDestroyed","toggleEmptyText","_me$crudManager","toggleClasses","isLoading","getRowHeight","storeKnownHeight","silent","estimateTotalHeight","clearKnownHeights","dateBounds","ret","lastDate","defaultDescriptionFormat","getEventRecord","changeRange","normalizeUnit","updateRange","currentDate","newDate","startOf","updateDate","changeStepUnit","visibleDate","previous","scheduleEvent","eventRect","onSelectionDrag","timeCellSelector","resourceTimeRangeSelector","initClass"],"mappings":"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"}