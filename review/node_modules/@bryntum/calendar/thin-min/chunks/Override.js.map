{"version":3,"file":"Override.js","sources":["../../../../Core/lib/Core/mixin/Override.js"],"sourcesContent":["import VersionHelper from '../helper/VersionHelper.js';\n\n/**\n * @module Core/mixin/Override\n */\n\nconst excludedPropNames = {\n    constructor : 1,\n    prototype   : 1,\n    name        : 1,\n    length      : 1,\n    arguments   : 1,\n    caller      : 1,\n    callee      : 1,\n    __proto__   : 1\n};\n\n/**\n * Simplifies overriding class methods by allowing methods from another class to be used as overrides.\n * Overrides are defined as own classes. They must at a minimum contain a static getter named targetClass, which\n * should return the class to override. Apply the override by calling {@link #function-apply-static apply()}.\n *\n * @example\n * class TemplateColumnOverride {\n *     static get target() {\n *         return {\n *             class      : TemplateColumn,\n *             product    : 'grid',\n *             minVersion : '1.0',\n *             maxVersion : '1.5'\n *         }\n *     }\n *\n *     renderer(renderData) {\n *         // call overridden function (optional)\n *         const value = this._overridden.renderer.call(this, renderData);\n *\n *         return 'HELLO' + value;\n *     }\n * }\n * Override.apply(TemplateColumnOverride);\n */\nexport default class Override {\n    /**\n     * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.\n     * ```\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * ```\n     * @param {Object} override An override class definition\n     */\n    static apply(override) {\n        if (!override.target) throw new Error('Override must specify what it overrides, using static getter target');\n        if (!override.target.class) throw new Error('Override must specify which class it overrides, using target.class');\n\n        if (!this.shouldApplyOverride(override)) return false;\n\n        const staticKeys   = Object.getOwnPropertyNames(override),\n            instanceKeys = Object.getOwnPropertyNames(override.prototype);\n\n        staticKeys.splice(staticKeys.indexOf('target'), 1);\n\n        this.internalOverrideAll(override.target.class, staticKeys, override);\n        this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);\n\n        return true;\n    }\n\n    static internalOverrideAll(targetClass, properties, overrideDefinition) {\n        Reflect.ownKeys(overrideDefinition).forEach(key => {\n            if (properties.includes(key) && !excludedPropNames[key]) {\n                const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);\n                let currentTargetClass = targetClass;\n\n                let targetProperty = null;\n\n                // Walk up the prototype chain to find fn, needed for mixin overrides applied to class that has them\n                // mixed in\n                while (!targetProperty && currentTargetClass) {\n                    targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);\n                    if (!targetProperty) {\n                        currentTargetClass = Object.getPrototypeOf(currentTargetClass);\n                    }\n                }\n\n                if (targetProperty) {\n                    this.internalOverride(currentTargetClass, key, desc, targetProperty);\n                }\n            }\n        });\n    }\n\n    static internalOverride(target, key, desc, targetDesc) {\n        const overrides = target._overridden = target._overridden || {};\n\n        overrides[key] = target[key];\n\n        if (targetDesc.get) {\n            Object.defineProperty(target, key, {\n                enumerable   : false,\n                configurable : true,\n                get          : desc.get\n            });\n        }\n        else {\n            target[key] = desc.value;\n        }\n    }\n\n    /**\n     * Checks versions if an override should be applied. Specify version in your overrides target config\n     * @param override\n     * @returns {Boolean}\n     * @example\n     * class OriginalOverride {\n     *     static get target() {\n     *         return {\n     *             class      : Original,\n     *             product    : 'grid',\n     *             minVersion : '1.0',\n     *             maxVersion : '1.5'\n     *         }\n     *     }\n     * }\n     * @private\n     */\n    static shouldApplyOverride(override) {\n        const config = override.target;\n        // not using versioning, allow override\n        if (!config.maxVersion && !config.minVersion) return true;\n\n        // must specify product to be able to lookup versions\n        if (!config.product) throw new Error('Override must specify product when using versioning');\n\n        // override is for older version, disallow\n        if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for an older version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for newer version, disallow\n        if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {\n            //<debug>\n            console.log(`Override ${override.name} for class ${config.class.name} is for a newer version of ${config.product} and will not be applied`);\n            //</debug>\n            return false;\n        }\n\n        // override is for current version, allow\n        return true;\n    }\n}\n"],"names":["excludedPropNames","constructor","prototype","name","length","arguments","caller","callee","__proto__","Override","apply","override","target","Error","class","this","shouldApplyOverride","staticKeys","Object","getOwnPropertyNames","instanceKeys","splice","indexOf","internalOverrideAll","targetClass","properties","overrideDefinition","Reflect","ownKeys","forEach","key","includes","desc","getOwnPropertyDescriptor","currentTargetClass","targetProperty","getPrototypeOf","internalOverride","targetDesc","_overridden","get","defineProperty","enumerable","configurable","value","config","maxVersion","minVersion","product","VersionHelper","isNewerThan","isOlderThan","_$name"],"mappings":"4CAIA,MAAMA,EAAoB,CACtBC,YAAc,EACdC,UAAc,EACdC,KAAc,EACdC,OAAc,EACdC,UAAc,EACdC,OAAc,EACdC,OAAc,EACdC,UAAc,GA2BH,MAAMC,EAiBjBC,aAAaC,GACT,IAAKA,EAASC,OAAQ,MAAM,IAAIC,MAAM,uEACtC,IAAKF,EAASC,OAAOE,MAAO,MAAM,IAAID,MAAM,sEAC5C,IAAKE,KAAKC,oBAAoBL,GAAW,OAAO,EAChD,MAAMM,EAAeC,OAAOC,oBAAoBR,GAC5CS,EAAeF,OAAOC,oBAAoBR,EAAST,WAIvD,OAHAe,EAAWI,OAAOJ,EAAWK,QAAQ,UAAW,GAChDP,KAAKQ,oBAAoBZ,EAASC,OAAOE,MAAOG,EAAYN,GAC5DI,KAAKQ,oBAAoBZ,EAASC,OAAOE,MAAMZ,UAAWkB,EAAcT,EAAST,YAC1E,EAEXqB,2BAA2BC,EAAaC,EAAYC,GAChDC,QAAQC,QAAQF,GAAoBG,SAAQC,IACxC,GAAIL,EAAWM,SAASD,KAAS9B,EAAkB8B,GAAM,CACrD,MAAME,EAAOd,OAAOe,yBAAyBP,EAAoBI,GACjE,IAAII,EAAqBV,EACrBW,EAAiB,KAGrB,MAAQA,GAAkBD,GACtBC,EAAiBjB,OAAOe,yBAAyBC,EAAoBJ,GAChEK,IACDD,EAAqBhB,OAAOkB,eAAeF,IAG/CC,GACApB,KAAKsB,iBAAiBH,EAAoBJ,EAAKE,EAAMG,OAKrEE,wBAAwBzB,EAAQkB,EAAKE,EAAMM,IACrB1B,EAAO2B,YAAc3B,EAAO2B,aAAe,IACnDT,GAAOlB,EAAOkB,GACpBQ,EAAWE,IACXtB,OAAOuB,eAAe7B,EAAQkB,EAAK,CAC/BY,YAAe,EACfC,cAAe,EACfH,IAAeR,EAAKQ,MAIxB5B,EAAOkB,GAAOE,EAAKY,MAoB3B5B,2BAA2BL,GACvB,MAAMkC,EAASlC,EAASC,OAExB,IAAKiC,EAAOC,aAAeD,EAAOE,WAAY,OAAO,EAErD,IAAKF,EAAOG,QAAS,MAAM,IAAInC,MAAM,uDAErC,QAAIgC,EAAOC,aAAcG,EAAcJ,EAAOG,SAASE,YAAYL,EAAOC,gBAItED,EAAOE,aAAcE,EAAcJ,EAAOG,SAASG,YAAYN,EAAOE,cAOlFtC,EAAS2C,OAAS"}