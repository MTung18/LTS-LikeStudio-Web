{"version":3,"file":"ExcelExporter.js","sources":["../../../../Grid/lib/Grid/feature/GroupSummary.js","../../../../Grid/lib/Grid/util/TableExporter.js","../../../../Grid/lib/Grid/util/BooleanUnicodeSymbol.js","../../../../Grid/lib/Grid/feature/experimental/ExcelExporter.js"],"sourcesContent":["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/GroupSummary\n */\n\n/**\n * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as\n * {@link Grid.feature.Summary}.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```\n * features : {\n *     group        : 'city',\n *     groupSummary : true\n * }\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/groupsummary\n * @classtype groupSummary\n * @feature\n *\n * @inlineexample Grid/feature/GroupSummary.js\n */\nexport default class GroupSummary extends SummaryFormatter(InstancePlugin) {\n    //region Init\n\n    static get $name() {\n        return 'GroupSummary';\n    }\n\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @member {Boolean} collapseToHeader\n             */\n            /**\n             * Configure as `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            collapseToHeader : true\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @config {Boolean}\n             */\n            collapseToHeader : null,\n\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * @member {'header'|'footer'} target\n             */\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            target : 'header'\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * @config {'header'|'footer'}\n             * @default\n             */\n            target : 'footer'\n        };\n    }\n\n    construct(grid, config) {\n        this.grid = grid;\n\n        super.construct(grid, config);\n\n        if (!grid.features.group) {\n            throw new Error('Requires Group feature to work, please enable');\n        }\n\n        this.bindStore(grid.store);\n\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n\n            // The feature gets to see cells being rendered after the Group feature\n            // because the Group feature injects header content into group header rows\n            // and adds rendering info to the cells renderData which we must comply with.\n            // In particular, it calculates the isFirstColumn flag which it adds to\n            // the cell renderData which we interrogate.\n            prio    : 1000,\n            thisObj : this\n        });\n    }\n\n    bindStore(store) {\n        this.detachListeners('store');\n\n        store.ion({\n            name    : 'store',\n            update  : 'onStoreUpdate',\n            // need to run before grids listener, to flag for full refresh\n            prio    : 1,\n            thisObj : this\n        });\n    }\n\n    get store() {\n        return this.grid.store;\n    }\n\n    doDisable(disable) {\n        // Toggle footers if needed\n        this.updateTarget(this.target);\n\n        super.doDisable(disable);\n    }\n\n    changeTarget(target) {\n        ObjectHelper.assertString(target, 'target');\n\n        return target;\n    }\n\n    updateTarget(target) {\n        // Flag that will make the Store insert rows for group footers\n        this.store.useGroupFooters = !this.disabled && target === 'footer';\n\n        // Refresh groups to show/hide footers\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    changeCollapseToHeader(collapseToHeader) {\n        ObjectHelper.assertBoolean(collapseToHeader, 'collapseToHeader');\n\n        return collapseToHeader;\n    }\n\n    updateCollapseToHeader() {\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n\n    //endregion\n\n    //region Plugin config\n\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['bindStore']\n        };\n    }\n\n    //endregion\n\n    //region Render\n\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group summary rows\n     * @private\n     */\n    onBeforeRenderRow({ row, record }) {\n        if (row.isGroupFooter && !('groupFooterFor' in record.meta)) {\n            // not a group row.\n            row.isGroupFooter = false;\n            // force full \"redraw\" when rendering cells\n            row.forceInnerHTML = true;\n        }\n        else if (row.isGroupHeader && !record.meta.collapsed) {\n            // remove any summary elements\n            row.eachElement(this.removeSummaryElements);\n        }\n    }\n\n    removeSummaryElements(rowEl) {}\n\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell({ column, cellElement, row, record, size, isFirstColumn }) {\n        const\n            me            = this,\n            { meta }      = record,\n            { rowHeight } = me.grid,\n            isGroupHeader = 'groupRowFor' in meta,\n            isGroupFooter = 'groupFooterFor' in meta,\n            targetsHeader = me.target === 'header',\n            rowClasses    = {\n                'b-group-footer'   : 0,\n                'b-header-summary' : 0\n            },\n            isSummaryTarget =\n                // Header cell should have summary content if we are targeting the header or if the group is collapsed\n                // and we are configured with collapseToHeader, excluding the first column which holds the group title\n                (isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn) ||\n                // Footer cell should have summary content if we are targeting the footer (wont render if collapsed)\n                (isGroupFooter && !targetsHeader);\n\n        // Needed to restore height when summary is no longer displayed\n        if (isGroupHeader || isGroupFooter) {\n            size.height = rowHeight;\n        }\n\n        if (me.store.isGrouped && isSummaryTarget && !me.disabled) {\n            // clear cell before add any HTML in it. if the cell contained widgets, they will be properly destroyed.\n            column.clearCell(cellElement);\n\n            const groupRecord = isGroupHeader ? record : meta.groupRecord;\n\n            row.isGroupFooter = isGroupFooter;\n            row.isGroupHeader = isGroupHeader;\n\n            // This is a group footer row, add css\n            if (isGroupFooter) {\n                rowClasses['b-group-footer'] = 1;\n            }\n            // This is a group header row, add css\n            else {\n                rowClasses['b-header-summary'] = 1;\n            }\n\n            // returns height config or count. config format is { height, count }. where `height is in px and should be\n            // added to value calculated from `count\n            const\n                heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord),\n                count         = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;\n\n            // number of summaries returned, use to calculate cell height\n            if (count > 1) {\n                size.height += (meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1);\n            }\n\n            // height config with height specified, added to cell height\n            if (heightSetting.height) {\n                size.height += heightSetting.height;\n            }\n        }\n\n        // Sync row's classes with its status as a group header or footer.\n        row.assignCls(rowClasses);\n    }\n\n    updateSummaryHtml(cellElement, column, groupRecord) {\n        const records = groupRecord.groupChildren.slice();\n\n        // Group footers should not be included in summary calculations\n        if (records[records.length - 1].isGroupFooter) {\n            records.pop();\n        }\n\n        const html = this.generateHtml(column, records, 'b-grid-group-summary', groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);\n\n        // First time, set table\n        if (!cellElement.children.length) {\n            cellElement.innerHTML = html;\n        }\n        // Following times, sync changes\n        else {\n            DomHelper.sync(html, cellElement.firstElementChild);\n        }\n\n        // return summary \"count\", used to set row height\n        return column.summaries ? column.summaries.length : column.sum ? 1 : 0;\n    }\n\n    //endregion\n\n    //region Events\n\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreUpdate({ source : store, changes }) {\n        if (!this.disabled && store.isGrouped) {\n            // If a grouping field is among the changes, StoreGroup#onDataChanged will\n            // take care of the update by re-sorting.\n            if (changes && store.groupers.find(grouper => grouper.field in changes)) {\n                return;\n            }\n            // only update summary when a field that affects summary is changed\n            // TODO: this should maybe be removed, another column might depend on the value for its summary?\n            const shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n\n            if (shouldUpdate) {\n                this.grid.forceFullRefresh = true;\n            }\n        }\n    }\n\n    //endregion\n\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.grid.columns.visibleColumns.forEach(column => {\n            if (this.hasSummary(column)) {\n                this.grid.refreshColumn(column);\n            }\n        });\n    }\n\n    hasSummary(column) {\n        return column.sum || column.summaries;\n    }\n}\n\nGroupSummary.featureClass = 'b-group-summary';\n\nGridFeatureManager.registerFeature(GroupSummary);\n","import DomHelper from '../../Core/helper/DomHelper.js';\nimport Base from '../../Core/Base.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/util/TableExporter\n */\n\n/**\n * This class transforms grid component into two arrays: rows and columns. Columns array contains objects with\n * meta information about column: field name, column name, width and type of the rendered value, rows array contains\n * arrays of cell values.\n *\n * ```javascript\n * const exporter = new TableExporter({ target : grid });\n * exporter.export()\n *\n * // Output\n * {\n *     columns : [\n *         { field : 'name',     value : 'First name', type : 'string',  width : 100 },\n *         { field : 'surname',  value : 'Last name',  type : 'string',  width : 100 },\n *         { field : 'age',      value : 'Age',        type : 'number',  width : 50  },\n *         { field : 'married',  value : 'Married',    type : 'boolean', width : 50  },\n *         { field : 'children', value : 'Children',   type : 'object',  width : 100 }\n *     ],\n *     rows : [\n *         ['Michael', 'Scott',   40, false, []],\n *         ['Jim',     'Halpert', 30, true,  [...]]\n *     ]\n * }\n * ```\n *\n * ## How data is exported\n *\n * Exporter iterates over store records and processes each record for each column being exported. Exporter uses same\n * approach to retrieve data as column: reading record field, configured on the column, or calling renderer function\n * if one is provided. This means data can be of any type: primitives or objects. So children array in the above code\n * snippet may contain instances of child record class.\n *\n * ## Column renderers\n *\n * Column renderers are commonly used to style the cell, or even render more HTML into it, like {@link Grid.column.WidgetColumn}\n * does. This is not applicable in case of export. Also, given grid uses virtual rendering (only renders visible rows) and\n * exporter iterates over all records, not just visible ones, we cannot provide all data necessary to the renderer. Some\n * arguments, like cellElement and row, wouldn't exist. Thus renderer is called with as much data we have: value,\n * record, column, grid, other {@link Grid.column.Column#config-renderer documented arguments} would be undefined.\n *\n * Exporter adds one more flag for renderer function: isExport. When renderer receives this flag it knows\n * data is being exported and can skip DOM work to return simpler value. Below snippet shows simplified code of the\n * widget column handling export:\n *\n * ```javascript\n * renderer({ isExport }) {\n *     if (isExport) {\n *         return null;\n *     }\n *     else {\n *         // widget rendering routine\n *         ...\n *     }\n * }\n * ```\n *\n * ## Column types\n *\n * Column types are not actually a complete list of JavaScript types (you can get actual type of the cell using typeof) it\n * is a simple and helpful meta information.\n *\n * Available column types are:\n *  * string\n *  * number\n *  * boolean\n *  * date\n *  * object\n *\n * Everything which is not primitive like string/number/bool (or a date) is considered an object. This includes null, undefined,\n * arrays, classes, functions etc.\n *\n * ## Getting column type\n *\n * If existing grid column is used, column type first would be checked with {@link Grid.column.Column#config-exportedType exportedType}\n * config. If exportedType is undefined or column does not exist in grid, type is read from a record field definition.\n * If the field is not defined, object type is used.\n *\n * Configuring exported type:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *             name         : 'Name',\n *             field        : 'name',\n *             exportedType : 'object',\n *             renderer     : ({ value, isExport }) => {\n *                 if (isExport) {\n *                     return { value }; // return value wrapped into object\n *                 }\n *             }\n *     ]\n * })\n * ```\n *\n * @extends Core/Base\n */\nexport default class TableExporter extends Base {\n    static get defaultConfig() {\n        return {\n            /**\n             * Target grid instance to export data from\n             * @config {Grid.view.Grid} target\n             */\n            target : null,\n\n            /**\n             * Specifies a default column width if no width specified\n             * @config {Number} defaultColumnWidth\n             * @default\n             */\n            defaultColumnWidth : 100,\n\n            /**\n             * Set to false to export date as it is displayed by Date column formatter\n             * @config {Boolean}\n             * @default\n             */\n            exportDateAsInstance : true,\n\n            /**\n             * If true and the grid is grouped, shows the grouped value in the first column. True by default.\n             * @config {Boolean} showGroupHeader\n             * @default\n             */\n            showGroupHeader : true,\n\n            /**\n             * An array of column configuration objects used to specify column widths, header text, and data fields to get the data from.\n             * 'field' config is required. If 'text' is missing, it will read it from the grid column or the 'field' config.\n             * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.\n             * If no columns provided the config will be generated from the grid columns.\n             *\n             * For example:\n             * ```javascript\n             * columns : [\n             *     'firstName', // field\n             *     'age', // field\n             *     { text : 'Starts', field : 'start', width : 140 },\n             *     { text : 'Ends', field : 'finish', width : 140 }\n             * ]\n             * ```\n             *\n             * @config {String[]|Object[]} columns\n             * @default\n             */\n            columns : null,\n\n            /**\n             * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}\n             * @config {Boolean}\n             * @default\n             */\n            indent : true,\n\n            /**\n             * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true\n             * @config {String}\n             * @default\n             */\n            indentationSymbol : '\\u00A0\\u00A0\\u00A0\\u00A0'\n        };\n    }\n\n    /**\n     * Exports grid data according to provided config\n     * @param {Object} config\n     * @returns {{ rows : Object[][], columns : Object[] }}\n     */\n    export(config = {}) {\n        const me = this;\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        me.normalizeColumns(config);\n\n        return me.generateExportData(config);\n    }\n\n    generateExportData(config) {\n        const\n            me      = this,\n            columns = me.generateColumns(config),\n            rows    = me.generateRows(config);\n\n        return { rows, columns };\n    }\n\n    normalizeColumns(config) {\n        // In case columns are provided we need to use normalized config. If those are not provided, we are going\n        // to use real columns, possible invoking renderers (we need to pass column instance to the renderer to\n        // avoid breaking API too much)\n        const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);\n\n        config.columns = columns.map(col => {\n            if (typeof col === 'string') {\n                return this.target.columns.find(column => column.field === col) || { field : col };\n            }\n            else {\n                return col;\n            }\n        });\n    }\n\n    generateColumns(config) {\n        return config.columns.map(col => this.processColumn(col, config));\n    }\n\n    generateRows(config) {\n        const { columns, rows } = config;\n\n        if (columns.length === 0 || rows?.length === 0) {\n            return [];\n        }\n\n        const\n            me         = this,\n            { target } = me;\n\n        return (rows || target.store)\n            // although columns are taken from config, it is convenient to provide them as a separate argument\n            // because that allows to override set of columns to process\n            .map(record => me.processRecord(record, columns, config))\n            // filter out empty rows\n            .filter(cells => cells?.length);\n    }\n\n    getColumnType(column, store = this.target.store) {\n        let result = column.exportedType || 'object';\n\n        if (column.exportedType === undefined) {\n            if (column.field) {\n                const fieldDefinition = store.modelClass.getFieldDefinition(column.field);\n\n                if (fieldDefinition && fieldDefinition.type !== 'auto') {\n                    result = fieldDefinition.type;\n                }\n            }\n        }\n\n        return result;\n    }\n\n    /**\n     * Extracts export data from the column instance\n     * @param {Grid.column.Column} column\n     * @param {Object} config\n     * @private\n     * @returns {Object}\n     */\n    processColumn(column, config) {\n        const\n            me                     = this,\n            { target }             = me,\n            { defaultColumnWidth } = config;\n\n        let { field, text : value, width, minWidth } = column;\n\n        // If column is not configured with field, field is generated (see Column.js around line 514).\n        // In export we want empty string there\n        if (!(field in target.store.modelClass.fieldMap)) {\n            field = '';\n        }\n\n        // If name or width is missing try to retrieve them from the grid column and the field, or use default values.\n        if (!value || !width) {\n            const gridColumn = target.columns.find(col => col.field === field);\n\n            if (!value) {\n                value = gridColumn && gridColumn.text || field;\n            }\n\n            // null or undefined\n            if (width == null) {\n                width = gridColumn && gridColumn.width || defaultColumnWidth;\n            }\n        }\n\n        width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);\n\n        return { field, value, width, type : me.getColumnType(column) };\n    }\n\n    /**\n     * Extracts export data from the record instance reading supplied column configs\n     * @param {Core.data.Model|null} record If null is passed, all columns will be filled with empty strings\n     * @param {Grid.column.Column[]} columns\n     * @param {Object} config\n     * @private\n     * @returns {Object[]}\n     */\n    processRecord(record, columns, config) {\n        const\n            { target } = this,\n            {\n                showGroupHeader,\n                indent,\n                indentationSymbol\n            }  = config;\n\n        let cells;\n\n        if (!record) {\n            cells = columns.map(() => '');\n        }\n        else if (record.isSpecialRow) {\n            if (showGroupHeader && record.meta.groupRowFor) {\n                cells = columns.map(column => {\n                    return target.features.group.buildGroupHeader({\n                        // Create dummy element to get html from\n                        cellElement : DomHelper.createElement(),\n                        grid        : target,\n                        record,\n                        column\n                    });\n                });\n            }\n        }\n        else {\n            cells = columns.map(column => {\n                let value = column.field?.includes('.') ? record.get(column.field) : record[column.field];\n                const useRenderer = column.renderer || column.defaultRenderer;\n\n                if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {\n                    value = useRenderer.call(column, {\n                        value,\n                        record,\n                        column,\n                        grid     : target,\n                        isExport : true\n                    });\n                }\n\n                if (indent && column.tree) {\n                    value = `${indentationSymbol.repeat(record.childLevel)}${value}`;\n                }\n\n                return value;\n            });\n        }\n\n        return cells;\n    }\n}\n","export default class BooleanUnicodeSymbol {\n    constructor(value) {\n        this._value = value;\n    }\n\n    get value() {\n        return this._value;\n    }\n\n    toString() {\n        return Boolean(this.value) ? '✓' : '';\n    }\n}\n","import GridFeatureManager from '../GridFeatureManager.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport TableExporter from '../../util/TableExporter.js';\nimport BooleanUnicodeSymbol from '../../util/BooleanUnicodeSymbol.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n\n/**\n * @module Grid/feature/experimental/ExcelExporter\n */\n\n/**\n * **NOTE**: This class requires a 3rd party library to operate.\n *\n * A feature that allows exporting Grid data to Excel without involving the server. It uses {@link Grid.util.TableExporter}\n * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)\n * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)\n * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).\n * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.\n *\n * ```\n * // Global scope\n * <script src=\"zipcelx.js\"></script>\n *\n * // importing from package\n * import zipcelx from 'zipcelx';\n *\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             zipcelx\n *         }\n *     }\n * })\n * ```\n *\n * Here is an example of how to add the feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             // Choose the date format for date fields\n *             dateFormat : 'YYYY-MM-DD HH:mm',\n *\n *             exporterConfig : {\n *                 // Choose the columns to include in the exported file\n *                 columns : ['name', 'role'],\n *                 // Optional, export only selected rows\n *                 rows    : grid.selectedRecords\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * And how to call it:\n *\n * ```javascript\n * grid.features.excelExporter.export({\n *     filename : 'Export',\n *     exporterConfig : {\n *         columns : [\n *             { text : 'First Name', field : 'firstName', width : 90 },\n *             { text : 'Age', field : 'age', width : 40 },\n *             { text : 'Starts', field : 'start', width : 140 },\n *             { text : 'Ends', field : 'finish', width : 140 }\n *         ]\n *     }\n * })\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/exporttoexcel\n * @classtype excelExporter\n * @feature\n */\nexport default class ExcelExporter extends InstancePlugin {\n    static get $name() {\n        return 'ExcelExporter';\n    }\n\n    static get defaultConfig() {\n        return {\n            /**\n             * Name of the exported file\n             * @config {String} filename\n             * @default\n             */\n            filename : null,\n\n            /**\n             * Defines how dates in a cell will be formatted\n             * @config {String} dateFormat\n             * @default\n             */\n            dateFormat : 'YYYY-MM-DD',\n\n            /**\n             * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.\n             * @config {Grid.util.TableExporter}\n             * @typings {typeof TableExporter}\n             * @default\n             */\n            exporterClass : TableExporter,\n\n            /**\n             * Configuration object for {@link #config-exporterClass exporter class}.\n             * @config {Object}\n             */\n            exporterConfig : null,\n\n            /**\n             * Reference to zipcelx library. If not provided, exporter will look in the global scope.\n             * @config {Object}\n             */\n            zipcelx : null,\n\n            /**\n             * If this config is true, exporter will convert all empty values to ''. Empty values are:\n             * * undefined, null, NaN\n             * * Objects/class instances that do not have toString method defined and are stringified to [object Object]\n             * * functions\n             * @config {Boolean}\n             */\n            convertEmptyValueToEmptyString : true\n        };\n    }\n\n    processValue(value) {\n        if (\n            value === undefined ||\n            value === null ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            (typeof value === 'object' && String(value) === '[object Object]')\n        ) {\n            return '';\n        }\n        else {\n            return value;\n        }\n    }\n\n    generateExportData(config) {\n        const\n            me                = this,\n            { rows, columns } = me.exporter.export(config.exporterConfig);\n\n        return {\n            rows : rows.map(row => {\n                return row.map((value, index) => {\n                    if (value instanceof Date) {\n                        value = DateHelper.format(value, config.dateFormat);\n                    }\n                    else if (typeof value === 'boolean') {\n                        value = new BooleanUnicodeSymbol(value);\n                    }\n\n                    if (me.convertEmptyValueToEmptyString) {\n                        value = me.processValue(value);\n                    }\n\n                    const type = columns[index]?.type === 'number' ? 'number' : 'string';\n\n                    return { value, type };\n                });\n            }),\n            columns : columns.map(col => {\n                let { field, value, width, type } = col;\n\n                // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair\n                // repair works, but having error on open doesn't look acceptable\n                // type = type === 'number' ? 'number' : 'string';\n                type = 'string';\n\n                return { field, value, width, type };\n            })\n        };\n    }\n\n    /**\n     * Generate and download an Excel file (.xslx).\n     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.\n     * @param {String} [config.filename] Name of the exported file\n     * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted\n     * @param {String[]|Object[]} [config.columns] An array of column configuration objects\n     * @param {Core.data.Model[]} [config.rows] An array of records to export\n     * @returns {Promise} Promise that resolves when the export is completed\n     */\n    export(config = {}) {\n        const\n            me      = this,\n            zipcelx = me.zipcelx || globalThis.zipcelx;\n\n        if (!zipcelx) {\n            throw new Error('ExcelExporter: \"zipcelx\" library is required');\n        }\n\n        if (me.disabled) {\n            return;\n        }\n\n        config = ObjectHelper.assign({}, me.config, config);\n\n        if (!config.filename) {\n            config.filename = me.client.$$name;\n        }\n\n        const\n            { filename }      = config,\n            { rows, columns } = me.generateExportData(config);\n\n        return zipcelx({\n            filename,\n            sheet : {\n                data : [columns].concat(rows),\n                cols : columns\n            }\n        });\n    }\n\n    construct(grid, config) {\n        super.construct(grid, config);\n\n        if (!this.zipcelx) {\n            if (typeof zipcelx !== 'undefined') {\n                this.zipcelx = globalThis.zipcelx;\n            }\n        }\n    }\n\n    get exporter() {\n        const me = this;\n\n        return me._exporter || (me._exporter = me.exporterClass.new({ target : me.client }, me.exporterConfig));\n    }\n}\n\nGridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');\n"],"names":["GroupSummary","SummaryFormatter","InstancePlugin","$name","configurable","collapseToHeader","target","construct","grid","config","this","super","features","group","Error","bindStore","store","rowManager","ion","beforeRenderRow","renderCell","prio","thisObj","detachListeners","name","update","doDisable","disable","updateTarget","changeTarget","ObjectHelper","assertString","useGroupFooters","disabled","isConfiguring","changeCollapseToHeader","assertBoolean","updateCollapseToHeader","pluginConfig","chain","onBeforeRenderRow","row","record","isGroupFooter","meta","forceInnerHTML","isGroupHeader","collapsed","eachElement","removeSummaryElements","rowEl","column","cellElement","size","isFirstColumn","me","rowHeight","targetsHeader","rowClasses","isSummaryTarget","height","isGrouped","clearCell","groupRecord","heightSetting","updateSummaryHtml","count","assignCls","records","groupChildren","slice","length","pop","html","generateHtml","groupField","groupRowFor","children","DomHelper","sync","firstElementChild","innerHTML","summaries","sum","onStoreUpdate","source","changes","groupers","find","grouper","field","Object","keys","some","colField","columns","get","Boolean","forceFullRefresh","refresh","visibleColumns","forEach","hasSummary","refreshColumn","featureClass","_$name","GridFeatureManager","registerFeature","TableExporter","Base","defaultConfig","defaultColumnWidth","exportDateAsInstance","showGroupHeader","indent","indentationSymbol","export","assign","normalizeColumns","generateExportData","generateColumns","rows","generateRows","filter","rec","exportable","map","col","processColumn","processRecord","cells","getColumnType","result","exportedType","undefined","fieldDefinition","modelClass","getFieldDefinition","type","text","value","width","minWidth","fieldMap","gridColumn","Math","max","isSpecialRow","buildGroupHeader","createElement","_column$field","includes","useRenderer","renderer","defaultRenderer","isDateColumn","call","isExport","tree","repeat","childLevel","BooleanUnicodeSymbol","constructor","_value","toString","ExcelExporter","filename","dateFormat","exporterClass","exporterConfig","zipcelx","convertEmptyValueToEmptyString","processValue","Number","isNaN","String","exporter","index","_columns$index","Date","DateHelper","format","globalThis","client","$$name","sheet","data","concat","cols","_exporter","new"],"mappings":"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"}