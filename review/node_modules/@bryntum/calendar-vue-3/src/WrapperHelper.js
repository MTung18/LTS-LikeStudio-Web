/**
 * Vue 2 / Vue 3 widget helper
 */

import {  WidgetHelper, StringHelper } from '@bryntum/calendar';

export default function() {

    /**
     * Development warning. Showed when environment is set to 'development'
     * @param {String} clsName vue component instance
     * @param {String} msg console message
     */
    function devWarning(clsName, msg) {
        if (window.bryntum && window.bryntum.isTestEnv || process.env.NODE_ENV === 'development') {
            console.warn(`Bryntum${clsName}Component development warning!\n${msg}\n` +
                'Please check Vue integration guide: https://bryntum.com/products/calendar/docs/guide/Calendar/integration/vue/guide'
            );
        }
    }

    function devWarningContainer(clsName, containerParam) {
        devWarning(clsName,
            `Using "${containerParam}" parameter for configuration is not recommended.\n` +
            'Widget is placed automatically inside it\'s container element.\n' +
            `Solution: remove "${containerParam}" parameter from configuration.`
        );
    }

    function devWarningConfigProp(clsName, prop) {
        devWarning(clsName,
            `Using "${prop}" parameter for configuration is not recommended.\n` +
            `Solution: Use separate parameter for each "${prop}" value to enable reactive updates of the API instance`
        );
    }

    function devWarningUpdateProp(clsName, prop) {
        devWarning(clsName,
            `"${prop}" is a static config option for component constructor only. No runtime changes are supported!`
        );
    }

    /**
     * Creates bryntum component config from vue component
     * @param {Object} context
     * @param {Object} context.me vue component instance
     * @param {Object} context.props reference to props
     * @param {Object} context.data reference to data
     * @param {Function} context.emit reference to emit
     * @param {Object} context.element HTML element
     * @param {Function} context.processCellContent cell renderer method
     * @param {Function} context.hasFrameworkRenderer checks presence of vue renderer
     * @returns {Object} config object
     */
    function createConfig({ me, props, listeners, data, emit, element, processCellContent, hasFrameworkRenderer }) {
        const
            {
                instanceClass,
                instanceName
            }                   = data,
            filter              = arr => arr.filter(prop => props[prop] !== undefined),
            configNames         = filter(data.configNames || []),
            propertyConfigNames = filter(data.propertyConfigNames || []),
            propertyNames       = filter(data.propertyNames || []),
            featureNames        = filter(data.featureNames || []),
            eventNames          = data.eventNames.filter(event => listeners[event] !== undefined || listeners[event.toLowerCase()] !== undefined),
            bryntumConfig       = {
                vueComponent : instanceClass.isModel ? undefined : me,
                listeners    : {},
                features     : {},
                processCellContent,
                hasFrameworkRenderer
            };

        // Setup events listeners
        eventNames.forEach(eventName => {
            const onFunctionName = `on${StringHelper.capitalize(eventName)}`;

            // Vue prefixes DOM events with on, for example click becomes onClick which
            // is same as our on-Function. Therefore the DOM events' handlers are called twice.
            // This prevents firing the event if we already have on-Function created by Vue.
            if (!props[onFunctionName]) {
                bryntumConfig.listeners[eventName] = event => emit(eventName.toLowerCase(), event);
            }
        });

        // Assign configs. Skip properties
        configNames
            .concat(propertyConfigNames)
            .concat(featureNames)
            .forEach(prop => {
                applyPropValue(bryntumConfig, prop, props[prop]);
                if (['features', 'config'].includes(prop)) {
                    devWarningConfigProp(instanceClass.$name, prop);
                }
            });

        // Add vue wrapper class name
        bryntumConfig.cls = (bryntumConfig.cls || '') + ` b-vue-${instanceClass.$name.toLowerCase()}-container`;

        // Prepare watch arrays
        data.configNames = configNames;
        data.propertyNames = configNames.concat(propertyNames).concat(propertyConfigNames).concat(featureNames);

        // Cleanup unused instance arrays
        data.eventNames && delete data.eventNames;
        data.propertyConfigNames && delete data.propertyConfigNames;
        data.featureNames && delete data.featureNames;

        // If component has no container specified in config then use adopt to Wrapper's element
        const
            containerParam = [
                'adopt',
                'appendTo',
                'insertAfter',
                'insertBefore'
            ].find(prop => bryntumConfig[prop]);
        if (!containerParam) {
            if (instanceName === 'Button') {
                // Button should always be <a> or <button> inside owner element
                bryntumConfig.appendTo = element;
            }
            else {
                bryntumConfig.adopt = element;
            }
        }
        else {
            devWarningContainer(instanceClass.$name, containerParam);
        }

        return bryntumConfig;
    }

    /**
     * Setup store events relay
     * @param {Object} data reference to data
     * @param {Object} instance bryntum widget instance
     */
    function relayStores(data, instance) {
        const { dataStores, projectStores } = data;

        if (dataStores) {
            Object.keys(dataStores).forEach(storeName => {
                const store =  projectStores ? instance.project[storeName] : instance[storeName];
                if (store) {
                    // Set `syncDataOnLoad` to `true` by default
                    // TODO: remove when https://github.com/bryntum/support/issues/2764 is done
                    store.syncDataOnLoad = store.syncDataOnLoad == null ? true : store.syncDataOnLoad;
                    // Vue-3 fails to compile nullish coalescing https://github.com/bryntum/support/issues/2872
                    // store.syncDataOnLoad = store.syncDataOnLoad ?? true;

                    // Makes relaying store events configurable but off by default
                    if (instance && instance.relayStoreEvents) {
                        store.relayAll(instance, dataStores[storeName]);
                    }
                }
            });
            delete data.dataStores;
        }
    }

    /**
     * Creates bryntum Widget from vue component
     * @param {Object} context
     * @param {Object} context.me vue component instance
     * @param {Object} context.props reference to props
     * @param {Object} context.data reference to data
     * @param {Function} context.emit reference to emit
     * @param {Object} context.element HTML element
     * @param {Function} context.processCellContent cell renderer method
     * @param {Function} context.hasFrameworkRenderer check the presence of vue renderer
     * @returns {Object} widget object
     */
    function createWidget(context) {
        const
            { instanceClass } = context.data,
            config            = createConfig(context);
        return instanceClass.$name === 'Widget' ? WidgetHelper.createWidget(config) : new instanceClass(config);
    }

    /**
     * Applies property value to Bryntum config or instance.
     * @param {Object} configOrInstance target object
     * @param {String} prop property name
     * @param {Object} value value
     * @param {Boolean} isConfig config setting mode
     */
    function applyPropValue(configOrInstance, prop, value, isConfig = true) {

        if (prop === 'project') {
            // Allow use ProjectModel component as project
            if (value && typeof value === 'object') {
                configOrInstance[prop] = value.instance ? value.instance.value || value.instance : value;
            }
        }
        else if (prop === 'features' && typeof value === 'object') {
            Object.keys(value).forEach(key => applyPropValue(configOrInstance, `${key}Feature`, value[key], isConfig));
        }
        else if (prop === 'config' && typeof value === 'object') {
            Object.keys(value).forEach(key => applyPropValue(configOrInstance, key, value[key], isConfig));
        }
        else if (prop === 'columns' && !isConfig) {
            configOrInstance['columns'].data = value;
        }
        else if (prop.endsWith('Feature')) {
            const
                features    = configOrInstance['features'],
                featureName = prop.replace('Feature', '');
            if (isConfig) {
                features[featureName] = value;
            }
            else {
                const feature = features[featureName];
                if (feature) {
                    feature.setConfig(value);
                }
            }
        }
        else {
            configOrInstance[prop] = value;
        }
    }

    /**
     * Creates watches for vue component properties
     * @param {Object} me vue component instance
     * @param {Object} instance bryntum widget instance
     * @param {Object} props reference to props
     * @param {Object} data reference to data
     * @param {Function} watcher watch method reference (Accepts: prop and newValue)
     */
    function watchProps(me, instance, props, data, watcher) {
        const
            {
                configNames,
                propertyNames,
                instanceClass
            }   = data;

        propertyNames.forEach(prop => watcher(prop, newValue => {
            const value = Array.isArray(newValue) ? newValue.slice() : newValue;
            applyPropValue(instance, prop, value, false);

            // Check if property is a config and notify
            if (configNames.includes(prop)) {
                devWarningUpdateProp(instanceClass.$name, prop);
            }
        }));

        // Cleanup unused instance arrays
        delete data.configNames;
        delete data.propertyNames;
    }

    return {
        createWidget,
        relayStores,
        watchProps
    };
}
