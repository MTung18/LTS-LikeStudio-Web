/**
 * Vue 3 wrapper helper
 */
import { nextTick } from 'vue';

export default function() {
    /**
     * Cell renderer method
     * @param cellContent
     * @param cellElement
     * @param record
     * @param rendererData
     * @returns {boolean}
     */
    function processCellContent({
        rendererData,
        rendererData: { record },
        rendererData: { cellElement },
        rendererData: { column },
        rendererHtml: cellContent
    }) {
        const { vueComponent } = this;
        const {
            refs,
            refs: { teleportsHolder }
        } = vueComponent;

        // `teleports` is javascript Map object
        const {
            teleports: { value: teleports }
        } = vueComponent.provides;
        const key = `${column.id}-${record.id}`;
        const renderElement = column.tree
            ? cellElement.querySelector('.b-tree-cell-value')
            : cellElement;

        // Only run for cells with vue renderers
        if (column.data.vue) {
            // Move the previous teleport to the hidden div
            const stale = renderElement.querySelector('[data-vue]');
            if (stale) {
                teleportsHolder.appendChild(stale);
            }

            // Find cached teleport
            let cached = refs[key];

            // Fix for new version of Vue (3.27) and #4879
            cached = Array.isArray(cached) ? cached[0] : cached;

            // Check if record changed
            if (cached && cached.$el.dataset.generation !== String(record.generation)) {
                teleports.delete(key);
                cached = null;
            }

            // Move cached back to the cell
            if (cached) {
                renderElement.appendChild(cached.$el);
            }
            else {
                // Teleport might have been deleted so let the DOM to settle down
                nextTick(() => {
                    const bind = { ...cellContent };
                    const { is } = bind;
                    delete bind.is;

                    // Create new teleport
                    teleports.set(key, {
                        bind,
                        key,
                        is,
                        to         : renderElement,
                        generation : record.generation
                    });
                });
            }
        }
    }

    /**
     *
     * @param { Object } context
     * @param { * } context.cellContent Content to be rendered in cell (set by renderer)
     * @param { Column } context.column Column being rendered
     * @returns { Boolean } `true` if there is a Vue Renderer in this cell, `false` otherwise
     */
    function hasFrameworkRenderer({ cellContent, column }) {
        return (
            cellContent &&
            typeof cellContent === 'object' &&
            column.data.vue
        );
    }

    return {
        processCellContent,
        hasFrameworkRenderer
    };
}
